---
phase: 07-multi-trail-sms-selection
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - backend/app/services/trail_selection.py
autonomous: true

must_haves:
  truths:
    - "User with saved trails sees main menu (1. My Trails, 2. Library)"
    - "User without saved trails jumps directly to library"
    - "Trail lists show 5 trails per page with pagination"
    - "Selecting a trail sets active_trail_id and confirms"
    - "Invalid input returns appropriate error message"
    - "Session expires after 30 minutes"
  artifacts:
    - path: "backend/app/services/trail_selection.py"
      provides: "Trail selection state machine service"
      exports: ["TrailSelectionService", "get_trail_selection_service"]
      min_lines: 200
  key_links:
    - from: "backend/app/services/trail_selection.py"
      to: "backend/app/models/trail_selection.py"
      via: "imports session store"
      pattern: "from app.models.trail_selection import"
    - from: "backend/app/services/trail_selection.py"
      to: "backend/app/models/custom_route.py"
      via: "queries user trails and library"
      pattern: "CustomRouteStore|RouteLibraryStore"
    - from: "backend/app/services/trail_selection.py"
      to: "backend/app/models/account.py"
      via: "sets active_trail_id"
      pattern: "account_store.set_active_trail"
---

<objective>
Implement the trail selection state machine for SMS-based trail switching.

Purpose: Allow registered users to select which trail to use for CAST commands via a conversational SMS flow with pagination.

Output: TrailSelectionService that processes user input through MAIN_MENU -> MY_TRAILS/LIBRARY -> trail selection -> confirmation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/specs/START-command-flow.md

# From Plan 01
@backend/app/models/trail_selection.py
@backend/app/models/account.py
@backend/app/models/custom_route.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TrailSelectionService core</name>
  <files>backend/app/services/trail_selection.py</files>
  <action>
Create `backend/app/services/trail_selection.py` with the state machine:

```python
"""
Trail Selection Service - Multi-trail SMS selection flow.

Based on START-command-flow.md specification.
Allows users to switch active trail via conversational SMS.
"""

import logging
from typing import Optional, Tuple, List
from dataclasses import dataclass

from app.models.trail_selection import (
    SelectionState, TrailSelectionSession, trail_selection_store
)
from app.models.account import account_store, Account
from app.models.custom_route import (
    custom_route_store, route_library_store,
    CustomRoute, RouteLibrary
)

logger = logging.getLogger(__name__)

# Constants from spec
TRAILS_PER_PAGE = 5
SESSION_TIMEOUT_MINUTES = 30


@dataclass
class TrailInfo:
    """Unified trail info for display."""
    id: int
    name: str
    country: Optional[str] = None  # For library trails
    waypoint_count: int = 0
    typical_days: Optional[str] = None


class TrailSelectionService:
    """
    State machine for SMS trail selection.

    Flow:
    1. START received
    2. If user has saved trails: show main menu (My Trails / Library)
    3. If user has no saved trails: skip to library
    4. User navigates with numbers, 0 for more pages
    5. Selecting a trail sets active_trail_id
    """

    def __init__(self):
        self.session_store = trail_selection_store

    def start_selection(self, phone: str, account: Account) -> str:
        """
        Begin trail selection flow for a registered user.

        Returns the first response message.
        """
        # Get user's saved trails
        user_trails = custom_route_store.get_by_account_id(account.id)
        has_saved_trails = len(user_trails) > 0

        if has_saved_trails:
            # Show main menu
            session = self.session_store.create(phone, SelectionState.MAIN_MENU)
            session.trail_ids = None  # Will be populated when entering a list
            return self._format_main_menu(account, len(user_trails))
        else:
            # Skip to library
            library_trails = route_library_store.list_active()
            session = self.session_store.create(phone, SelectionState.LIBRARY)
            session.trail_ids = [t.id for t in library_trails]
            session.page = 0
            return self._format_library_list(library_trails, page=0, is_new_user=True)

    def process_input(self, phone: str, text: str, account: Account) -> Tuple[str, bool]:
        """
        Process user input during trail selection.

        Args:
            phone: User's phone number
            text: User's SMS input
            account: User's account

        Returns:
            (response_message, is_complete)
            is_complete=True means selection is done, clear session
        """
        session = self.session_store.get(phone)

        if not session:
            # Session expired or doesn't exist
            return "Session expired. Send START to select a trail.", False

        text = text.strip()

        # Refresh session on interaction
        session.refresh_expiry()

        if session.state == SelectionState.MAIN_MENU:
            return self._handle_main_menu(session, text, account)
        elif session.state == SelectionState.MY_TRAILS:
            return self._handle_my_trails(session, text, account)
        elif session.state == SelectionState.LIBRARY:
            return self._handle_library(session, text, account)

        return "Something went wrong. Send START to try again.", False

    def _handle_main_menu(self, session: TrailSelectionSession, text: str, account: Account) -> Tuple[str, bool]:
        """Handle input when showing main menu."""
        if text == "1":
            # Go to My Trails
            user_trails = custom_route_store.get_by_account_id(account.id)
            session.state = SelectionState.MY_TRAILS
            session.trail_ids = [t.id for t in user_trails]
            session.page = 0
            self.session_store.update(session.phone, state=session.state, trail_ids=session.trail_ids, page=0)
            return self._format_my_trails_list(user_trails, page=0), False

        elif text == "2":
            # Go to Library
            library_trails = route_library_store.list_active()
            session.state = SelectionState.LIBRARY
            session.trail_ids = [t.id for t in library_trails]
            session.page = 0
            self.session_store.update(session.phone, state=session.state, trail_ids=session.trail_ids, page=0)
            return self._format_library_list(library_trails, page=0), False

        else:
            return "Reply 1 or 2", False

    def _handle_my_trails(self, session: TrailSelectionSession, text: str, account: Account) -> Tuple[str, bool]:
        """Handle input when showing user's trails."""
        user_trails = custom_route_store.get_by_account_id(account.id)
        total_trails = len(user_trails)
        total_pages = (total_trails + TRAILS_PER_PAGE - 1) // TRAILS_PER_PAGE

        if text == "0":
            # Next page
            session.page = (session.page + 1) % total_pages
            self.session_store.update(session.phone, page=session.page)
            return self._format_my_trails_list(user_trails, session.page), False

        # Try to parse as trail selection
        try:
            selection = int(text)
            # Selection is 1-indexed display number
            if 1 <= selection <= total_trails:
                trail_index = selection - 1
                selected_trail = user_trails[trail_index]
                return self._select_trail(account, selected_trail.id, selected_trail.name, session)
            else:
                valid_max = min(total_trails, (session.page + 1) * TRAILS_PER_PAGE)
                valid_min = session.page * TRAILS_PER_PAGE + 1
                return f"Reply {valid_min}-{valid_max} to select a trail, or 0 for more options.", False
        except ValueError:
            return f"Reply 1-{total_trails} to select, or 0 for more.", False

    def _handle_library(self, session: TrailSelectionSession, text: str, account: Account) -> Tuple[str, bool]:
        """Handle input when showing library trails."""
        library_trails = route_library_store.list_active()
        total_trails = len(library_trails)
        total_pages = (total_trails + TRAILS_PER_PAGE - 1) // TRAILS_PER_PAGE

        if text == "0":
            # Next page
            next_page = session.page + 1
            if next_page >= total_pages:
                # Wrap around or stay on last
                next_page = 0
            session.page = next_page
            self.session_store.update(session.phone, page=session.page)
            return self._format_library_list(library_trails, session.page), False

        # Try to parse as trail selection
        try:
            selection = int(text)
            if 1 <= selection <= total_trails:
                trail_index = selection - 1
                selected_trail = library_trails[trail_index]

                # For library trails, we need to create/find user's copy
                # or just set active to library trail directly
                # Per spec: "If selecting from library (not already saved), optionally add to user's saved trails"
                # For v1: Just set active trail ID to the library trail ID
                # This means we're treating library trails as usable directly

                return self._select_trail(
                    account,
                    selected_trail.id,
                    selected_trail.name,
                    session,
                    is_library=True,
                    typical_days=selected_trail.typical_days
                )
            else:
                # Calculate valid range for current page
                page_start = session.page * TRAILS_PER_PAGE + 1
                page_end = min(total_trails, (session.page + 1) * TRAILS_PER_PAGE)
                return f"Reply {page_start}-{page_end} to select, or 0 for more.", False
        except ValueError:
            page_start = session.page * TRAILS_PER_PAGE + 1
            page_end = min(total_trails, (session.page + 1) * TRAILS_PER_PAGE)
            return f"Reply {page_start}-{page_end} to select, or 0 for more.", False

    def _select_trail(
        self,
        account: Account,
        trail_id: int,
        trail_name: str,
        session: TrailSelectionSession,
        is_library: bool = False,
        typical_days: Optional[str] = None
    ) -> Tuple[str, bool]:
        """
        Set the selected trail as active and return confirmation.

        Returns (message, is_complete=True)
        """
        # Set active trail
        account_store.set_active_trail(account.id, trail_id)

        # Clear session
        self.session_store.delete(session.phone)

        # Get waypoint counts for display
        waypoint_info = self._get_waypoint_info(trail_id, is_library)

        # Format confirmation per spec
        return self._format_confirmation(trail_name, waypoint_info, typical_days), True

    def _get_waypoint_info(self, trail_id: int, is_library: bool) -> dict:
        """Get waypoint counts for trail."""
        # For now, return placeholder - will integrate with actual waypoint queries
        # In a real implementation, query custom_waypoints for the trail
        return {
            "camps": 0,
            "peaks": 0,
            "pois": 0
        }

    # =========================================================================
    # Message Formatting (per spec character limits)
    # =========================================================================

    def _format_main_menu(self, account: Account, trail_count: int) -> str:
        """Format main menu message (~60 chars target)."""
        # Get first name or use "back" as fallback
        name = "back"  # Default for returning users
        return (
            f"Welcome {name}!\n"
            f"1. My Trails ({trail_count})\n"
            f"2. Trail Library\n"
            f"Reply 1 or 2"
        )

    def _format_my_trails_list(self, trails: List[CustomRoute], page: int) -> str:
        """Format user's trails list with pagination."""
        total = len(trails)
        start_idx = page * TRAILS_PER_PAGE
        end_idx = min(start_idx + TRAILS_PER_PAGE, total)
        page_trails = trails[start_idx:end_idx]

        lines = ["Your trails:"]
        for i, trail in enumerate(page_trails):
            display_num = start_idx + i + 1
            name = self._truncate_name(trail.name, 20)
            lines.append(f"{display_num}. {name}")

        # Add "More" if there are more pages
        if end_idx < total:
            lines.append("0. More ->")

        # Add instructions
        if end_idx < total:
            lines.append(f"Reply 1-{end_idx} or 0")
        else:
            lines.append(f"Reply 1-{total} to select")

        return "\n".join(lines)

    def _format_library_list(self, trails: List[RouteLibrary], page: int, is_new_user: bool = False) -> str:
        """Format library trails list with pagination."""
        total = len(trails)
        start_idx = page * TRAILS_PER_PAGE
        end_idx = min(start_idx + TRAILS_PER_PAGE, total)
        page_trails = trails[start_idx:end_idx]

        if is_new_user and page == 0:
            lines = ["Welcome to Thunderbird!", "Trail Library:"]
        elif page == 0:
            lines = ["Trail Library:"]
        else:
            lines = ["More trails:"]

        for i, trail in enumerate(page_trails):
            display_num = start_idx + i + 1
            name = self._truncate_name(trail.name, 20)
            country = f" ({trail.country})" if trail.country else ""
            lines.append(f"{display_num}. {name}{country}")

        # Add "More" if there are more pages
        if end_idx < total:
            lines.append("0. More ->")

        # Add instructions
        page_start = start_idx + 1
        page_end = end_idx
        if end_idx < total:
            lines.append(f"Reply {page_start}-{page_end} or 0")
        else:
            lines.append(f"Reply {page_start}-{page_end}")

        return "\n".join(lines)

    def _format_confirmation(self, trail_name: str, waypoint_info: dict, typical_days: Optional[str] = None) -> str:
        """Format selection confirmation message (~150 chars target)."""
        lines = [f"Active: {trail_name}"]

        # Add stats if available
        stats_parts = []
        if waypoint_info.get("camps"):
            stats_parts.append(f"{waypoint_info['camps']} camps")
        if waypoint_info.get("peaks"):
            stats_parts.append(f"{waypoint_info['peaks']} peaks")
        if typical_days:
            stats_parts.append(typical_days)

        if stats_parts:
            lines.append(", ".join(stats_parts))

        lines.append("")
        lines.append("Commands:")
        lines.append("CAST12 <code> - 12hr forecast")
        lines.append("CAST7 CAMPS - 7-day overview")
        lines.append("ROUTE - list waypoint codes")

        return "\n".join(lines)

    def _truncate_name(self, name: str, max_len: int) -> str:
        """Truncate name with ellipsis if too long."""
        if len(name) <= max_len:
            return name
        return name[:max_len - 3] + "..."


# Singleton instance
_trail_selection_service: Optional[TrailSelectionService] = None


def get_trail_selection_service() -> TrailSelectionService:
    """Get or create singleton TrailSelectionService."""
    global _trail_selection_service
    if _trail_selection_service is None:
        _trail_selection_service = TrailSelectionService()
    return _trail_selection_service
```
  </action>
  <verify>
Run Python import and basic test:
```python
from app.services.trail_selection import TrailSelectionService, get_trail_selection_service

service = get_trail_selection_service()
assert service is not None

# Verify methods exist
assert hasattr(service, 'start_selection')
assert hasattr(service, 'process_input')
print("TrailSelectionService OK")
```
  </verify>
  <done>
TrailSelectionService exists with:
- start_selection() that detects user trails vs no trails
- process_input() that routes to correct state handler
- State handlers for MAIN_MENU, MY_TRAILS, LIBRARY
- Pagination with "0 for more"
- Trail selection that sets active_trail_id
- Message formatting per spec character limits
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error handling and edge cases</name>
  <files>backend/app/services/trail_selection.py</files>
  <action>
Enhance the TrailSelectionService with additional error handling:

1. Add session expired message handler:
   ```python
   def get_expired_message(self) -> str:
       """Return message for expired session."""
       return "Session expired. Send START to begin again."
   ```

2. Add empty library handling in `_format_library_list`:
   ```python
   if not trails:
       return "No trails available. Create one at thunderbird.bot"
   ```

3. Add "no active trail" helper method for CAST commands:
   ```python
   def get_no_active_trail_message(self) -> str:
       """Return message when user has no active trail set."""
       return "No active trail. Send START to select one."
   ```

4. Add method to check if phone has active session:
   ```python
   def has_active_session(self, phone: str) -> bool:
       """Check if phone has an active (non-expired) selection session."""
       return self.session_store.get(phone) is not None
   ```

5. Add logging throughout:
   - Log when session starts
   - Log state transitions
   - Log trail selection
   - Log session expiry
  </action>
  <verify>
Run Python test for edge cases:
```python
from app.services.trail_selection import get_trail_selection_service

service = get_trail_selection_service()

# Test no active trail message
msg = service.get_no_active_trail_message()
assert "No active trail" in msg

# Test session check
assert service.has_active_session("+61999999999") == False

print("Edge cases OK")
```
  </verify>
  <done>
Service handles:
- Session expiry with clear message
- Empty library edge case
- No active trail error message
- Session existence checking
- Comprehensive logging
  </done>
</task>

</tasks>

<verification>
Run comprehensive test:
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "
from app.services.trail_selection import get_trail_selection_service
from app.models.trail_selection import SelectionState

service = get_trail_selection_service()

# Test message formatting
from app.models.custom_route import CustomRoute, RouteLibrary

# Mock trails for formatting test
mock_user_trails = [
    type('MockRoute', (), {'id': 1, 'name': 'My Overland Track'})(),
    type('MockRoute', (), {'id': 2, 'name': 'My Milford Track'})(),
]

# Test truncation
assert service._truncate_name('Very Long Trail Name Here', 15) == 'Very Long Tr...'
assert service._truncate_name('Short', 15) == 'Short'

# Test confirmation format
conf = service._format_confirmation('Overland Track', {'camps': 10, 'peaks': 5}, '5-7 days')
assert 'Active: Overland Track' in conf
assert 'CAST12' in conf

print('All service tests passed')
"
```
</verification>

<success_criteria>
- TrailSelectionService handles complete flow from START to selection
- Main menu shows for users with trails, library direct for new users
- Pagination shows 5 trails per page with "0. More ->" option
- Trail selection sets active_trail_id via account_store
- Confirmation message includes commands guide
- Message formatting respects character limits (truncation)
- Edge cases handled (expired session, empty library, invalid input)
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-trail-sms-selection/07-02-SUMMARY.md`
</output>
