---
phase: 07-multi-trail-sms-selection
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - backend/app/routers/webhook.py
  - backend/tests/test_trail_selection.py
autonomous: true

must_haves:
  truths:
    - "Registered user sending START enters trail selection flow"
    - "Unregistered user sending START enters onboarding flow"
    - "Numeric input during active session processes correctly"
    - "CAST command without active trail returns error message"
    - "CAST command with active trail works normally"
    - "Session state persists between SMS messages"
  artifacts:
    - path: "backend/app/routers/webhook.py"
      provides: "Updated webhook routing for trail selection"
      contains: "trail_selection"
    - path: "backend/tests/test_trail_selection.py"
      provides: "Test suite for trail selection"
      min_lines: 100
  key_links:
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/trail_selection.py"
      via: "imports and calls service"
      pattern: "get_trail_selection_service"
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/models/account.py"
      via: "checks for registered user"
      pattern: "account_store.get_by_phone"
---

<objective>
Integrate trail selection into the SMS webhook and verify the complete flow.

Purpose: Wire up the trail selection service to the inbound SMS handler so registered users can switch trails via SMS. Maintain existing onboarding flow for new users.

Output: Updated webhook.py that routes appropriately, comprehensive test suite validating all flows.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/specs/START-command-flow.md

# From previous plans
@backend/app/services/trail_selection.py
@backend/app/models/trail_selection.py
@backend/app/models/account.py

# Existing webhook
@backend/app/routers/webhook.py
@backend/app/services/onboarding.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update webhook.py for trail selection routing</name>
  <files>backend/app/routers/webhook.py</files>
  <action>
Update the SMS inbound handler in `webhook.py` to route START and numeric inputs appropriately:

1. Add import at top:
   ```python
   from app.services.trail_selection import get_trail_selection_service
   ```

2. Modify the START command handling section (around lines 155-176). The key logic:
   - If user sends START:
     - If NOT registered (no account): Continue to onboarding flow (existing behavior)
     - If registered (has account): Enter trail selection flow

3. Add check for active trail selection session BEFORE onboarding check. Numeric inputs (1, 2, 0, etc.) during an active trail selection session should process there, not fall through to onboarding or unknown command.

Here's the updated logic flow for the handler (after beta gate check around line 118):

```python
# After beta gate (account check), before onboarding check:

# Check if user is in trail selection flow FIRST
trail_selection_service = get_trail_selection_service()
if trail_selection_service.has_active_session(from_phone):
    # Process input through trail selection
    response_text, is_complete = trail_selection_service.process_input(
        from_phone, body, account
    )
    log_twiml_response(from_phone, response_text, "TRAIL_SELECTION", "trail_selection")
    twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Message>{html.escape(response_text)}</Message>
</Response>"""
    return Response(content=twiml, media_type="application/xml")

# START command routing - now distinguishes registered vs unregistered
is_start_command = text_upper in ["START", "REGISTER"]

if is_start_command:
    # Registered user -> trail selection
    # Note: account is already fetched above at line 118
    if account:
        response_text = trail_selection_service.start_selection(from_phone, account)
        log_twiml_response(from_phone, response_text, "START", "trail_selection")
        twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Message>{html.escape(response_text)}</Message>
</Response>"""
        return Response(content=twiml, media_type="application/xml")
    # else: fall through to onboarding for unregistered users
```

4. The existing onboarding check remains for unregistered users:
```python
# Only handle onboarding if:
# 1. User sends START/REGISTER AND is NOT registered, OR
# 2. User has an active (non-complete) onboarding session
session = onboarding_manager.get_session(from_phone)
is_active_onboarding = session and session.state != OnboardingState.COMPLETE

if (is_start_command and not account) or is_active_onboarding:
    # Handle onboarding (existing code)
    ...
```

5. Important: Move the account lookup BEFORE the critical commands bypass (line 137) so it's available for trail selection routing.
  </action>
  <verify>
Manual verification steps:
1. Start backend: `cd backend && uvicorn main:app --reload`
2. Use curl to simulate SMS (or test via actual SMS if available):
   ```bash
   # Test START for registered user (should see trail selection menu)
   curl -X POST http://localhost:8000/webhook/sms/inbound \
     -d "From=+61400000001&Body=START&To=+61400000000"

   # Test START for unregistered user (should see onboarding welcome)
   curl -X POST http://localhost:8000/webhook/sms/inbound \
     -d "From=+61999999999&Body=START&To=+61400000000"
   ```
  </verify>
  <done>
webhook.py routes:
- START from registered user -> trail_selection_service.start_selection()
- START from unregistered user -> onboarding_manager (existing)
- Numeric input during active trail session -> trail_selection_service.process_input()
- All other commands -> existing handlers
  </done>
</task>

<task type="auto">
  <name>Task 2: Add "no active trail" check to CAST commands</name>
  <files>backend/app/routers/webhook.py</files>
  <action>
In the CAST command processing (process_command function), add a check for active trail when the command requires it.

**Note**: For Phase 7, CAST commands with explicit location codes (CAST LAKEO) should still work without an active trail. The active trail is only needed for:
- Future: CAST without location (uses active trail's first waypoint)
- CAST7 CAMPS / CAST7 PEAKS (needs to know which route)

For now, add the check to `generate_cast7_all_camps` and `generate_cast7_all_peaks` functions:

```python
async def generate_cast7_all_camps(phone: str) -> str:
    """Generate 7-day grouped forecast for all camps on user's route."""
    from app.models.database import user_store
    from app.models.account import account_store
    # ... existing imports ...

    # Check for active trail first
    account = account_store.get_by_phone(phone)
    if account:
        active_trail_id = account_store.get_active_trail_id(account.id)
        if active_trail_id:
            # Use active trail's waypoints
            # For now, this requires integration with custom_route waypoints
            # Placeholder: fall through to user.route_id for backwards compatibility
            pass

    # Existing user lookup
    user = user_store.get_user(phone)
    if not user:
        # Check if they have an account but no active trail
        if account and not active_trail_id:
            return "No active trail. Send START to select one."
        return "You're not registered. Send START to begin."

    # ... rest of existing code ...
```

Similarly update `generate_cast7_all_peaks`.

**Backward compatibility note**: The existing flow uses `user.route_id` from the User table (SMS registration). Phase 7 adds `account.active_trail_id`. For now, maintain backward compatibility:
- If user has active_trail_id, use that
- Else fall back to user.route_id (existing behavior)
  </action>
  <verify>
Test that CAST7 CAMPS returns appropriate error when no active trail:
```bash
# Assuming a test account exists without active_trail_id set
curl -X POST http://localhost:8000/webhook/sms/inbound \
  -d "From=+61400000001&Body=CAST7 CAMPS&To=+61400000000"
# Should return "No active trail" or existing behavior if user.route_id exists
```
  </verify>
  <done>
CAST7 CAMPS and CAST7 PEAKS check for active_trail_id.
Returns "No active trail. Send START to select one." when needed.
Maintains backward compatibility with user.route_id.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite</name>
  <files>backend/tests/test_trail_selection.py</files>
  <action>
Create `backend/tests/test_trail_selection.py` with tests covering:

```python
"""
Tests for trail selection SMS flow.

Tests the complete flow from START command through trail selection.
"""

import pytest
from datetime import datetime, timedelta
from unittest.mock import Mock, patch, MagicMock

from app.models.trail_selection import (
    SelectionState, TrailSelectionSession, TrailSelectionSessionStore
)
from app.services.trail_selection import TrailSelectionService


class TestTrailSelectionSession:
    """Test TrailSelectionSession model."""

    def test_session_creation(self):
        """Session should have correct default values."""
        session = TrailSelectionSession(
            phone="+61400000000",
            state=SelectionState.MAIN_MENU
        )
        assert session.phone == "+61400000000"
        assert session.state == SelectionState.MAIN_MENU
        assert session.page == 0
        assert session.created_at is not None
        assert session.expires_at is not None
        assert not session.is_expired()

    def test_session_expiry(self):
        """Session should expire after 30 minutes."""
        session = TrailSelectionSession(
            phone="+61400000000",
            state=SelectionState.MAIN_MENU
        )
        # Manually set expired time
        session.expires_at = datetime.utcnow() - timedelta(minutes=1)
        assert session.is_expired()

    def test_session_refresh(self):
        """Refresh should extend expiry."""
        session = TrailSelectionSession(
            phone="+61400000000",
            state=SelectionState.MAIN_MENU
        )
        old_expiry = session.expires_at
        session.refresh_expiry()
        assert session.expires_at > old_expiry


class TestTrailSelectionSessionStore:
    """Test session store operations."""

    def test_create_and_get(self):
        """Should create and retrieve session."""
        store = TrailSelectionSessionStore()
        session = store.create("+61400000000", SelectionState.LIBRARY)
        retrieved = store.get("+61400000000")
        assert retrieved is not None
        assert retrieved.state == SelectionState.LIBRARY

    def test_get_expired_returns_none(self):
        """Expired session should return None and be deleted."""
        store = TrailSelectionSessionStore()
        session = store.create("+61400000000", SelectionState.MAIN_MENU)
        session.expires_at = datetime.utcnow() - timedelta(minutes=1)
        retrieved = store.get("+61400000000")
        assert retrieved is None

    def test_update_session(self):
        """Should update session fields."""
        store = TrailSelectionSessionStore()
        store.create("+61400000000", SelectionState.MAIN_MENU)
        store.update("+61400000000", state=SelectionState.MY_TRAILS, page=1)
        session = store.get("+61400000000")
        assert session.state == SelectionState.MY_TRAILS
        assert session.page == 1

    def test_delete_session(self):
        """Should delete session."""
        store = TrailSelectionSessionStore()
        store.create("+61400000000", SelectionState.MAIN_MENU)
        store.delete("+61400000000")
        assert store.get("+61400000000") is None


class TestTrailSelectionService:
    """Test trail selection service."""

    @pytest.fixture
    def service(self):
        """Create fresh service for each test."""
        return TrailSelectionService()

    @pytest.fixture
    def mock_account(self):
        """Create mock account."""
        account = Mock()
        account.id = 1
        account.email = "test@test.com"
        account.phone = "+61400000000"
        return account

    def test_start_with_no_trails_shows_library(self, service, mock_account):
        """User with no trails should see library directly."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            with patch('app.services.trail_selection.route_library_store') as mock_library_store:
                mock_route_store.get_by_account_id.return_value = []
                mock_library_store.list_active.return_value = [
                    Mock(id=1, name="Overland Track", country="AU"),
                    Mock(id=2, name="Milford Track", country="NZ"),
                ]

                response = service.start_selection("+61400000000", mock_account)

                assert "Welcome to Thunderbird" in response
                assert "Trail Library" in response
                assert "Overland Track" in response

    def test_start_with_trails_shows_menu(self, service, mock_account):
        """User with trails should see main menu."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            mock_route_store.get_by_account_id.return_value = [
                Mock(id=1, name="My Trail"),
            ]

            response = service.start_selection("+61400000000", mock_account)

            assert "My Trails" in response
            assert "Trail Library" in response
            assert "Reply 1 or 2" in response

    def test_main_menu_option_1_shows_my_trails(self, service, mock_account):
        """Selecting 1 from main menu should show user's trails."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            mock_route_store.get_by_account_id.return_value = [
                Mock(id=1, name="My Overland Track"),
                Mock(id=2, name="My Milford Track"),
            ]

            # Start session
            service.start_selection("+61400000000", mock_account)

            # Select option 1
            response, complete = service.process_input("+61400000000", "1", mock_account)

            assert "Your trails" in response
            assert "My Overland Track" in response
            assert not complete

    def test_main_menu_option_2_shows_library(self, service, mock_account):
        """Selecting 2 from main menu should show library."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            with patch('app.services.trail_selection.route_library_store') as mock_library_store:
                mock_route_store.get_by_account_id.return_value = [Mock(id=1, name="Trail")]
                mock_library_store.list_active.return_value = [
                    Mock(id=1, name="Overland Track", country="AU"),
                ]

                # Start session
                service.start_selection("+61400000000", mock_account)

                # Select option 2
                response, complete = service.process_input("+61400000000", "2", mock_account)

                assert "Trail Library" in response or "Overland Track" in response
                assert not complete

    def test_selecting_trail_sets_active(self, service, mock_account):
        """Selecting a trail number should set active_trail_id."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            with patch('app.services.trail_selection.account_store') as mock_account_store:
                mock_route_store.get_by_account_id.return_value = [
                    Mock(id=42, name="My Overland Track"),
                ]

                # Start session and go to my trails
                service.start_selection("+61400000000", mock_account)
                service.process_input("+61400000000", "1", mock_account)

                # Select trail 1
                response, complete = service.process_input("+61400000000", "1", mock_account)

                # Verify active trail was set
                mock_account_store.set_active_trail.assert_called_once_with(1, 42)
                assert "Active:" in response
                assert complete

    def test_pagination_with_zero(self, service, mock_account):
        """Pressing 0 should show next page."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            # Create 7 trails (more than TRAILS_PER_PAGE=5)
            mock_route_store.get_by_account_id.return_value = [
                Mock(id=i, name=f"Trail {i}") for i in range(7)
            ]

            # Start and go to my trails
            service.start_selection("+61400000000", mock_account)
            service.process_input("+61400000000", "1", mock_account)

            # First page should show 1-5
            # Press 0 for more
            response, complete = service.process_input("+61400000000", "0", mock_account)

            # Should show remaining trails (6-7)
            assert "Trail 6" in response or "Trail 5" in response  # Page 2

    def test_invalid_input_shows_error(self, service, mock_account):
        """Invalid input should show error message."""
        with patch('app.services.trail_selection.custom_route_store') as mock_route_store:
            mock_route_store.get_by_account_id.return_value = [Mock(id=1, name="Trail")]

            # Start session
            service.start_selection("+61400000000", mock_account)

            # Invalid input
            response, complete = service.process_input("+61400000000", "invalid", mock_account)

            assert "Reply 1 or 2" in response
            assert not complete

    def test_expired_session_returns_error(self, service, mock_account):
        """Expired session should return error message."""
        # Don't create a session
        response, complete = service.process_input("+61400000000", "1", mock_account)

        assert "Session expired" in response or "START" in response

    def test_truncate_long_names(self, service):
        """Long trail names should be truncated."""
        result = service._truncate_name("This Is A Very Long Trail Name That Exceeds Limit", 20)
        assert len(result) <= 20
        assert result.endswith("...")

    def test_confirmation_includes_commands(self, service):
        """Confirmation message should include command hints."""
        response = service._format_confirmation("Test Trail", {"camps": 5, "peaks": 3}, "3-5 days")

        assert "Active: Test Trail" in response
        assert "CAST12" in response
        assert "CAST7" in response
        assert "ROUTE" in response


class TestWebhookIntegration:
    """Test webhook routing for trail selection."""

    @pytest.mark.asyncio
    async def test_start_registered_user_enters_trail_selection(self):
        """Registered user sending START should enter trail selection."""
        # This would be an integration test requiring the full app context
        # Marked as placeholder for manual testing
        pass

    @pytest.mark.asyncio
    async def test_start_unregistered_user_enters_onboarding(self):
        """Unregistered user sending START should enter onboarding."""
        pass

    @pytest.mark.asyncio
    async def test_numeric_input_during_session_processes_correctly(self):
        """Numeric input during active session should route to trail selection."""
        pass
```
  </action>
  <verify>
Run the test suite:
```bash
cd /Users/andrewhall/thunderbird-web/backend
pytest tests/test_trail_selection.py -v
```
  </verify>
  <done>
Test suite covers:
- Session model (creation, expiry, refresh)
- Session store (CRUD operations)
- Service logic (start_selection, process_input)
- State transitions (MAIN_MENU -> MY_TRAILS, MAIN_MENU -> LIBRARY)
- Trail selection (sets active_trail_id)
- Pagination
- Error handling (invalid input, expired session)
- Message formatting
All tests pass.
  </done>
</task>

</tasks>

<verification>
Run complete verification:
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Run tests
pytest tests/test_trail_selection.py -v

# Run type checking (if mypy configured)
# mypy app/services/trail_selection.py

# Manual flow test (requires running server)
# 1. Register a test account if needed
# 2. Send START via SMS or curl
# 3. Verify trail selection menu appears
# 4. Select a trail
# 5. Verify CAST7 CAMPS works with selected trail
```
</verification>

<success_criteria>
- Registered user sending START sees trail selection (My Trails or Library)
- Unregistered user sending START sees onboarding welcome
- Numeric input during active trail selection session processes correctly
- Selecting a trail sets active_trail_id and shows confirmation
- CAST7 CAMPS/PEAKS check for active trail (or fall back to user.route_id)
- Session persists across multiple SMS messages
- Session expires after 30 minutes
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-trail-sms-selection/07-03-SUMMARY.md`
</output>
