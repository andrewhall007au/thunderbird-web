---
phase: 07-multi-trail-sms-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/alembic/versions/xxx_add_active_trail_id.py
  - backend/app/models/account.py
  - backend/app/models/trail_selection.py
autonomous: true

must_haves:
  truths:
    - "accounts table has active_trail_id column"
    - "Account model can get/set active trail"
    - "Trail selection sessions can be stored and retrieved by phone"
    - "Sessions expire after 30 minutes"
  artifacts:
    - path: "backend/alembic/versions/*_add_active_trail_id.py"
      provides: "Database migration for active_trail_id"
      contains: "active_trail_id"
    - path: "backend/app/models/account.py"
      provides: "Account model with active_trail_id"
      exports: ["Account", "AccountStore"]
    - path: "backend/app/models/trail_selection.py"
      provides: "TrailSelectionSession model and store"
      exports: ["TrailSelectionSession", "SelectionState", "TrailSelectionSessionStore"]
  key_links:
    - from: "backend/app/models/account.py"
      to: "backend/app/models/custom_route.py"
      via: "active_trail_id references custom_routes.id"
      pattern: "active_trail_id.*INTEGER"
---

<objective>
Add database schema and models for multi-trail SMS selection.

Purpose: Foundation for the trail selection state machine - accounts need to track their active trail, and SMS sessions need persistent state for the multi-step selection flow.

Output: Migration adding active_trail_id to accounts, updated Account model, new TrailSelectionSession model with in-memory store.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/specs/START-command-flow.md

# Key existing files
@backend/app/models/account.py
@backend/app/models/custom_route.py
@backend/alembic/env.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Alembic migration for active_trail_id</name>
  <files>backend/alembic/versions/{timestamp}_add_active_trail_id.py</files>
  <action>
Create a new Alembic migration that adds `active_trail_id` column to the `accounts` table:

```sql
ALTER TABLE accounts ADD COLUMN active_trail_id INTEGER REFERENCES custom_routes(id);
```

Follow existing migration patterns in the codebase:
- Use `op.add_column()` with `sa.Column('active_trail_id', sa.Integer(), nullable=True)`
- SQLite does not support foreign key constraints in ALTER TABLE, so add a comment noting the logical FK relationship
- Add index on active_trail_id for efficient lookups: `op.create_index('ix_accounts_active_trail_id', 'accounts', ['active_trail_id'])`
- Downgrade should drop the index first, then the column

Generate migration with: `cd backend && alembic revision -m "add_active_trail_id"`
  </action>
  <verify>
Run `cd /Users/andrewhall/thunderbird-web/backend && alembic upgrade head` - migration applies without error.
Run `sqlite3 thunderbird.db ".schema accounts"` - shows active_trail_id column.
  </verify>
  <done>
Migration file exists, applies cleanly, accounts table has active_trail_id INTEGER column.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Account model with active_trail_id</name>
  <files>backend/app/models/account.py</files>
  <action>
Update the Account dataclass and AccountStore to support active_trail_id:

1. Add to Account dataclass:
   ```python
   active_trail_id: Optional[int] = None
   ```

2. Update all `_row_to_account` style queries to include active_trail_id:
   - In `get_by_email()`, `get_by_id()`, `get_by_phone()`: add active_trail_id to the Account constructor
   - Handle missing column gracefully: `row["active_trail_id"] if "active_trail_id" in row.keys() else None`

3. Add new methods to AccountStore:
   ```python
   def set_active_trail(self, account_id: int, trail_id: Optional[int]) -> bool:
       """Set the active trail for an account. Pass None to clear."""
       now = datetime.utcnow().isoformat()
       with self._get_connection() as conn:
           cursor = conn.execute(
               "UPDATE accounts SET active_trail_id = ?, updated_at = ? WHERE id = ?",
               (trail_id, now, account_id)
           )
           conn.commit()
           return cursor.rowcount > 0

   def get_active_trail_id(self, account_id: int) -> Optional[int]:
       """Get the active trail ID for an account."""
       with self._get_connection() as conn:
           cursor = conn.execute(
               "SELECT active_trail_id FROM accounts WHERE id = ?",
               (account_id,)
           )
           row = cursor.fetchone()
           return row["active_trail_id"] if row else None
   ```
  </action>
  <verify>
Run Python REPL test:
```python
from app.models.account import account_store, Account
# Check model has field
a = Account(id=1, email="test@test.com", password_hash="x")
assert hasattr(a, 'active_trail_id')
print("Account model OK")
```
  </verify>
  <done>
Account dataclass has active_trail_id field.
AccountStore has set_active_trail() and get_active_trail_id() methods.
All existing queries handle active_trail_id column.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TrailSelectionSession model and store</name>
  <files>backend/app/models/trail_selection.py</files>
  <action>
Create a new file `backend/app/models/trail_selection.py` with:

1. SelectionState enum:
   ```python
   from enum import Enum

   class SelectionState(str, Enum):
       MAIN_MENU = "main_menu"      # Showing "1. My Trails, 2. Library"
       MY_TRAILS = "my_trails"      # Showing user's saved trails
       LIBRARY = "library"          # Showing library trails
   ```

2. TrailSelectionSession dataclass (per spec):
   ```python
   from dataclasses import dataclass
   from datetime import datetime, timedelta
   from typing import Optional, List

   @dataclass
   class TrailSelectionSession:
       phone: str
       state: SelectionState
       page: int = 0                          # Current pagination offset (0-indexed)
       trail_ids: Optional[List[int]] = None  # Cached list of trail IDs for current view
       created_at: datetime = None
       expires_at: datetime = None            # 30 min timeout

       def __post_init__(self):
           if self.created_at is None:
               self.created_at = datetime.utcnow()
           if self.expires_at is None:
               self.expires_at = self.created_at + timedelta(minutes=30)

       def is_expired(self) -> bool:
           return datetime.utcnow() > self.expires_at

       def refresh_expiry(self):
           """Extend session on each interaction."""
           self.expires_at = datetime.utcnow() + timedelta(minutes=30)
   ```

3. TrailSelectionSessionStore (in-memory, like OnboardingManager):
   ```python
   from typing import Dict

   class TrailSelectionSessionStore:
       """In-memory session store for trail selection flow."""

       def __init__(self):
           self._sessions: Dict[str, TrailSelectionSession] = {}

       def get(self, phone: str) -> Optional[TrailSelectionSession]:
           """Get session if exists and not expired."""
           session = self._sessions.get(phone)
           if session and session.is_expired():
               del self._sessions[phone]
               return None
           return session

       def create(self, phone: str, state: SelectionState) -> TrailSelectionSession:
           """Create new session, replacing any existing."""
           session = TrailSelectionSession(phone=phone, state=state)
           self._sessions[phone] = session
           return session

       def update(self, phone: str, **kwargs) -> Optional[TrailSelectionSession]:
           """Update session fields."""
           session = self.get(phone)
           if session:
               for key, value in kwargs.items():
                   if hasattr(session, key):
                       setattr(session, key, value)
               session.refresh_expiry()
           return session

       def delete(self, phone: str) -> bool:
           """Remove session."""
           if phone in self._sessions:
               del self._sessions[phone]
               return True
           return False

       def clear_expired(self):
           """Remove all expired sessions (call periodically)."""
           expired = [p for p, s in self._sessions.items() if s.is_expired()]
           for phone in expired:
               del self._sessions[phone]

   # Singleton instance
   trail_selection_store = TrailSelectionSessionStore()
   ```

4. Add module-level exports at the top:
   ```python
   __all__ = ['SelectionState', 'TrailSelectionSession', 'TrailSelectionSessionStore', 'trail_selection_store']
   ```
  </action>
  <verify>
Run Python import test:
```python
from app.models.trail_selection import (
    SelectionState, TrailSelectionSession, trail_selection_store
)
# Test session creation
session = trail_selection_store.create("+61400000000", SelectionState.MAIN_MENU)
assert session.state == SelectionState.MAIN_MENU
assert not session.is_expired()
# Test retrieval
retrieved = trail_selection_store.get("+61400000000")
assert retrieved is not None
# Test cleanup
trail_selection_store.delete("+61400000000")
assert trail_selection_store.get("+61400000000") is None
print("TrailSelectionSession OK")
```
  </verify>
  <done>
trail_selection.py exists with:
- SelectionState enum (MAIN_MENU, MY_TRAILS, LIBRARY)
- TrailSelectionSession dataclass with phone, state, page, created_at, expires_at
- TrailSelectionSessionStore with get/create/update/delete methods
- 30-minute expiry built into is_expired() method
  </done>
</task>

</tasks>

<verification>
Run the full test:
```bash
cd /Users/andrewhall/thunderbird-web/backend
# Run migration
alembic upgrade head

# Verify schema
sqlite3 thunderbird.db ".schema accounts" | grep active_trail_id

# Run Python verification
python -c "
from app.models.account import Account, account_store
from app.models.trail_selection import SelectionState, TrailSelectionSession, trail_selection_store

# Verify Account model
a = Account(id=1, email='t@t.com', password_hash='x', active_trail_id=5)
assert a.active_trail_id == 5

# Verify session store
s = trail_selection_store.create('+61400000000', SelectionState.MY_TRAILS)
assert s.state == SelectionState.MY_TRAILS
trail_selection_store.delete('+61400000000')

print('All models OK')
"
```
</verification>

<success_criteria>
- Migration applies without error
- `accounts` table has `active_trail_id INTEGER` column
- Account dataclass has `active_trail_id: Optional[int]` field
- AccountStore has `set_active_trail()` and `get_active_trail_id()` methods
- TrailSelectionSession dataclass exists with required fields
- TrailSelectionSessionStore provides in-memory session management
- 30-minute expiry works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-trail-sms-selection/07-01-SUMMARY.md`
</output>
