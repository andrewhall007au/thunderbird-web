---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/main.py
  - backend/app/routers/__init__.py
  - backend/app/routers/webhook.py
  - backend/app/routers/admin.py
  - backend/app/routers/api.py
  - backend/app/services/payments.py
  - backend/app/services/route_builder.py
  - backend/app/services/affiliates.py
  - backend/app/services/weather_intl.py
autonomous: true

must_haves:
  truths:
    - "All existing tests pass after refactor"
    - "SMS webhook continues to work"
    - "Admin interface remains functional"
    - "Scheduled jobs still run"
  artifacts:
    - path: "backend/app/routers/webhook.py"
      provides: "Extracted Twilio SMS webhook handlers"
      exports: ["router"]
    - path: "backend/app/routers/admin.py"
      provides: "Extracted admin interface routes"
      exports: ["router"]
    - path: "backend/app/routers/api.py"
      provides: "Extracted public API routes"
      exports: ["router"]
    - path: "backend/app/services/payments.py"
      provides: "Payment service stub for Phase 2"
      min_lines: 20
    - path: "backend/app/services/route_builder.py"
      provides: "Route builder service stub for Phase 3"
      min_lines: 20
    - path: "backend/app/services/affiliates.py"
      provides: "Affiliate service stub for Phase 5"
      min_lines: 20
    - path: "backend/app/services/weather_intl.py"
      provides: "International weather service stub for Phase 6"
      min_lines: 20
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/routers/*.py"
      via: "app.include_router()"
      pattern: "include_router"
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/sms.py"
      via: "import"
      pattern: "from app.services.sms import"
---

<objective>
Refactor main.py (1685 lines) into modular APIRouter structure and create service stubs

Purpose: FOUN-01 requires modular codebase. The monolithic main.py must be split into routers (webhook, admin, api) and future service stubs created (payments, route_builder, affiliates, weather_intl). This unblocks all future phases.

Output: Slim main.py (~100 lines) with routers and service stubs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/andrewhall/thunderbird-web/.planning/PROJECT.md
@/Users/andrewhall/thunderbird-web/.planning/ROADMAP.md
@/Users/andrewhall/thunderbird-web/.planning/phases/01-foundation/01-RESEARCH.md
@/Users/andrewhall/thunderbird-web/.planning/codebase/ARCHITECTURE.md
@/Users/andrewhall/thunderbird-web/.planning/codebase/STRUCTURE.md
@/Users/andrewhall/thunderbird-web/.planning/codebase/CONVENTIONS.md

# Source files to refactor
@/Users/andrewhall/thunderbird-web/backend/app/main.py
@/Users/andrewhall/thunderbird-web/backend/app/services/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run existing tests to establish baseline</name>
  <files>backend/tests/</files>
  <action>
Run the full test suite to establish a baseline before refactoring:

```bash
cd /Users/andrewhall/thunderbird-web/backend
pytest tests/ -v
```

Record the number of passing/failing tests. This is the benchmark that must be maintained after refactoring.

If tests fail due to missing dependencies, install them:
```bash
pip install -r requirements.txt
```

Document any pre-existing test failures so they are not confused with refactor regressions.
  </action>
  <verify>Test suite runs, output shows test count and status</verify>
  <done>Baseline test results documented (X passing, Y failing pre-refactor)</done>
</task>

<task type="auto">
  <name>Task 2: Extract routes into APIRouter modules</name>
  <files>
    backend/app/main.py
    backend/app/routers/__init__.py
    backend/app/routers/webhook.py
    backend/app/routers/admin.py
    backend/app/routers/api.py
  </files>
  <action>
Create the routers directory and extract route handlers from main.py.

1. Create `backend/app/routers/__init__.py`:
```python
"""FastAPI route modules."""
```

2. Create `backend/app/routers/webhook.py`:
   - Extract `/webhook/sms/inbound` handler (around line 476 in main.py)
   - Extract `/webhook/sms/status` handler if it exists
   - Include all imports needed for Twilio handling
   - Create router with prefix="/webhook" and tags=["webhook"]
   - Keep the Twilio signature validation logic
   - Pattern:
   ```python
   from fastapi import APIRouter, Request, Header
   from typing import Optional

   router = APIRouter(prefix="/webhook", tags=["webhook"])

   @router.post("/sms/inbound")
   async def handle_inbound_sms(...):
       # Extracted logic
   ```

3. Create `backend/app/routers/admin.py`:
   - Extract admin routes (around line 1368+) including login, dashboard, user management
   - Create router with prefix="/admin" and tags=["admin"]
   - Include session handling and admin authentication logic

4. Create `backend/app/routers/api.py`:
   - Extract public API routes (health, info, user endpoints)
   - Create router with prefix="/api" and tags=["api"]

5. Update `backend/app/main.py`:
   - Keep only: FastAPI app creation, lifespan, middleware, router registration
   - Import and register routers using `app.include_router()`
   - Target: ~150-200 lines (down from 1685)
   - Keep scheduled job definitions in main.py (they use app context)

IMPORTANT: Move code incrementally. After each router extraction:
- Verify imports work
- Keep main.py functional at every step
- Test webhook manually if possible
  </action>
  <verify>
Run tests after extraction:
```bash
cd /Users/andrewhall/thunderbird-web/backend
pytest tests/ -v
```
All baseline tests must still pass.
  </verify>
  <done>
- main.py reduced to ~150-200 lines
- webhook.py, admin.py, api.py created with extracted routes
- All routes accessible at same URLs as before
- Tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Create future service stubs</name>
  <files>
    backend/app/services/payments.py
    backend/app/services/route_builder.py
    backend/app/services/affiliates.py
    backend/app/services/weather_intl.py
  </files>
  <action>
Create stub service files for future phases. These are placeholder modules that establish the structure for Phases 2, 3, 5, and 6.

1. Create `backend/app/services/payments.py`:
```python
"""
Payment service for Stripe integration.

Phase 2 will implement:
- PAY-01: $29.99 purchase via Stripe Checkout
- PAY-02: Dynamic pricing
- PAY-03: Discount codes
- PAY-06: Balance tracking
- PAY-07: Top-up with stored card
"""
from typing import Optional
from dataclasses import dataclass


@dataclass
class PaymentResult:
    """Result of a payment operation."""
    success: bool
    transaction_id: Optional[str] = None
    error: Optional[str] = None


class PaymentService:
    """
    Payment service stub.

    Will handle Stripe integration, balance management,
    and top-up processing in Phase 2.
    """

    def __init__(self):
        pass

    async def create_checkout_session(self, account_id: int, amount_cents: int) -> PaymentResult:
        """Create Stripe checkout session. Stub for Phase 2."""
        raise NotImplementedError("Implemented in Phase 2")

    async def get_balance(self, account_id: int) -> int:
        """Get account balance in cents. Stub for Phase 2."""
        raise NotImplementedError("Implemented in Phase 2")


_payment_service: Optional[PaymentService] = None


def get_payment_service() -> PaymentService:
    """Get singleton payment service instance."""
    global _payment_service
    if _payment_service is None:
        _payment_service = PaymentService()
    return _payment_service
```

2. Create `backend/app/services/route_builder.py`:
```python
"""
Route builder service for custom route creation.

Phase 3 will implement:
- ROUT-01: GPX upload
- ROUT-03: Waypoint pin placement
- ROUT-05: Waypoint naming with SMS code generation
- ROUT-09: Draft route saving
"""
from typing import Optional, List
from dataclasses import dataclass


@dataclass
class CustomWaypoint:
    """A user-defined waypoint on a custom route."""
    id: Optional[int] = None
    name: str = ""
    sms_code: str = ""
    lat: float = 0.0
    lng: float = 0.0
    waypoint_type: str = "poi"  # camp, peak, poi


@dataclass
class CustomRoute:
    """A user-created custom route."""
    id: Optional[int] = None
    account_id: int = 0
    name: str = ""
    waypoints: List[CustomWaypoint] = None
    status: str = "draft"


class RouteBuilderService:
    """
    Route builder service stub.

    Will handle GPX parsing, waypoint management,
    and route persistence in Phase 3.
    """

    def __init__(self):
        pass

    async def parse_gpx(self, gpx_content: bytes) -> CustomRoute:
        """Parse GPX file content. Stub for Phase 3."""
        raise NotImplementedError("Implemented in Phase 3")

    async def save_draft(self, route: CustomRoute) -> CustomRoute:
        """Save route as draft. Stub for Phase 3."""
        raise NotImplementedError("Implemented in Phase 3")


_route_builder_service: Optional[RouteBuilderService] = None


def get_route_builder_service() -> RouteBuilderService:
    """Get singleton route builder service instance."""
    global _route_builder_service
    if _route_builder_service is None:
        _route_builder_service = RouteBuilderService()
    return _route_builder_service
```

3. Create `backend/app/services/affiliates.py`:
```python
"""
Affiliate service for partner program.

Phase 5 will implement:
- AFFL-01: Affiliate creation
- AFFL-02: Configurable terms (discount %, commission %, trailing duration)
- AFFL-03: Affiliate codes as discount codes
- AFFL-05: Trailing commission tracking
"""
from typing import Optional
from dataclasses import dataclass


@dataclass
class Affiliate:
    """An affiliate partner."""
    id: Optional[int] = None
    name: str = ""
    email: str = ""
    code: str = ""
    discount_percent: int = 0
    commission_percent: int = 0
    trailing_months: int = 12
    active: bool = True


class AffiliateService:
    """
    Affiliate service stub.

    Will handle affiliate management, commission tracking,
    and discount code integration in Phase 5.
    """

    def __init__(self):
        pass

    async def create_affiliate(self, affiliate: Affiliate) -> Affiliate:
        """Create new affiliate. Stub for Phase 5."""
        raise NotImplementedError("Implemented in Phase 5")

    async def get_by_code(self, code: str) -> Optional[Affiliate]:
        """Look up affiliate by code. Stub for Phase 5."""
        raise NotImplementedError("Implemented in Phase 5")


_affiliate_service: Optional[AffiliateService] = None


def get_affiliate_service() -> AffiliateService:
    """Get singleton affiliate service instance."""
    global _affiliate_service
    if _affiliate_service is None:
        _affiliate_service = AffiliateService()
    return _affiliate_service
```

4. Create `backend/app/services/weather_intl.py`:
```python
"""
International weather service for multi-country support.

Phase 6 will implement:
- WTHR-01 through WTHR-08: Country-specific APIs
- WTHR-09: Open-Meteo fallback
- WTHR-10: Response normalization
"""
from typing import Optional
from dataclasses import dataclass
from enum import Enum


class WeatherProvider(str, Enum):
    """Weather data providers by country."""
    NWS = "nws"  # USA
    MET_OFFICE = "met_office"  # UK
    METEO_FRANCE = "meteo_france"  # France
    OPEN_METEO = "open_meteo"  # Fallback


@dataclass
class NormalizedForecast:
    """
    Normalized forecast format across all providers.

    Allows consistent handling regardless of data source.
    """
    provider: WeatherProvider
    lat: float
    lon: float
    temp_min: float
    temp_max: float
    rain_chance: int
    wind_speed: float
    description: str


class InternationalWeatherService:
    """
    International weather service stub.

    Will provide unified weather API across 8 countries
    with automatic fallback to Open-Meteo in Phase 6.
    """

    def __init__(self):
        pass

    async def get_forecast(
        self,
        lat: float,
        lon: float,
        country_code: str
    ) -> NormalizedForecast:
        """Get normalized forecast for any supported country. Stub for Phase 6."""
        raise NotImplementedError("Implemented in Phase 6")


_weather_intl_service: Optional[InternationalWeatherService] = None


def get_weather_intl_service() -> InternationalWeatherService:
    """Get singleton international weather service instance."""
    global _weather_intl_service
    if _weather_intl_service is None:
        _weather_intl_service = InternationalWeatherService()
    return _weather_intl_service
```
  </action>
  <verify>
Verify stubs are importable:
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "from app.services.payments import get_payment_service; print('payments OK')"
python -c "from app.services.route_builder import get_route_builder_service; print('route_builder OK')"
python -c "from app.services.affiliates import get_affiliate_service; print('affiliates OK')"
python -c "from app.services.weather_intl import get_weather_intl_service; print('weather_intl OK')"
```

Run full test suite to ensure no regressions:
```bash
pytest tests/ -v
```
  </verify>
  <done>
- 4 service stub files created with docstrings, dataclasses, and singleton pattern
- Each stub references its phase requirements
- All stubs importable
- Tests still pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Line count verification:
```bash
wc -l /Users/andrewhall/thunderbird-web/backend/app/main.py
# Should be ~150-200 lines (down from 1685)
```

2. Router structure verification:
```bash
ls -la /Users/andrewhall/thunderbird-web/backend/app/routers/
# Should show: __init__.py, webhook.py, admin.py, api.py
```

3. Service stubs verification:
```bash
ls -la /Users/andrewhall/thunderbird-web/backend/app/services/
# Should include: payments.py, route_builder.py, affiliates.py, weather_intl.py
```

4. Full test suite:
```bash
cd /Users/andrewhall/thunderbird-web/backend
pytest tests/ -v
# Same pass/fail as baseline
```
</verification>

<success_criteria>
- [ ] main.py reduced from 1685 lines to ~150-200 lines
- [ ] 3 router modules created (webhook.py, admin.py, api.py)
- [ ] 4 service stubs created (payments.py, route_builder.py, affiliates.py, weather_intl.py)
- [ ] All existing tests pass (same as baseline)
- [ ] All route URLs unchanged and functional
- [ ] FOUN-01 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
