---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - backend/app/routers/auth.py
  - backend/app/models/account.py
  - backend/tests/test_auth.py
autonomous: true

must_haves:
  truths:
    - "Authenticated user can link phone number to account"
    - "Phone number must be in valid format"
    - "Linked phone enables future SMS User connection"
  artifacts:
    - path: "backend/app/routers/auth.py"
      provides: "Phone linking endpoint"
      contains: "/phone"
    - path: "backend/tests/test_auth.py"
      provides: "Auth system tests"
      min_lines: 50
  key_links:
    - from: "backend/app/routers/auth.py"
      to: "backend/app/models/account.py"
      via: "account_store.link_phone()"
      pattern: "link_phone"
---

<objective>
Add phone number linking to accounts and create auth tests

Purpose: FOUN-05 requires users to link phone numbers to their accounts. This connects web accounts to the SMS system (existing User model). Also adds tests for the entire auth system created in Plan 03.

Output: Phone linking endpoint and comprehensive auth tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/andrewhall/thunderbird-web/.planning/PROJECT.md
@/Users/andrewhall/thunderbird-web/.planning/ROADMAP.md
@/Users/andrewhall/thunderbird-web/.planning/phases/01-foundation/01-RESEARCH.md

# Previous plan summaries
@/Users/andrewhall/thunderbird-web/.planning/phases/01-foundation/01-02-SUMMARY.md
@/Users/andrewhall/thunderbird-web/.planning/phases/01-foundation/01-03-SUMMARY.md

# Code to extend
@/Users/andrewhall/thunderbird-web/backend/app/routers/auth.py
@/Users/andrewhall/thunderbird-web/backend/app/models/account.py
@/Users/andrewhall/thunderbird-web/backend/app/services/sms.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add phone linking endpoint</name>
  <files>
    backend/app/routers/auth.py
  </files>
  <action>
Add an endpoint to link a phone number to an authenticated account.

Update `backend/app/routers/auth.py`:

1. Add import for phone validation (reuse existing PhoneUtils):
```python
from app.services.sms import PhoneUtils
```

2. Add request model:
```python
class LinkPhoneRequest(BaseModel):
    """Request to link phone number to account."""
    phone: str = Field(..., description="Phone number (e.g., +61412345678 or 0412345678)")
```

3. Add phone linking endpoint:
```python
@router.post("/phone", response_model=AccountResponse)
async def link_phone(
    request: LinkPhoneRequest,
    account: Account = Depends(get_current_account)
):
    """
    Link a phone number to the authenticated account.

    The phone number is normalized to international format (+61...).
    This enables connecting the web Account to SMS User data.

    Args:
        request: Phone number to link
        account: Current authenticated account (from JWT)

    Returns:
        Updated account info

    Raises:
        400 if phone number is invalid format
    """
    # Normalize phone number using existing PhoneUtils
    try:
        normalized_phone = PhoneUtils.normalize(request.phone)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid phone number: {str(e)}"
        )

    # Link phone to account
    success = account_store.link_phone(account.id, normalized_phone)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Account not found"
        )

    # Return updated account
    updated_account = account_store.get_by_id(account.id)

    return AccountResponse(
        id=updated_account.id,
        email=updated_account.email,
        phone=updated_account.phone,
        created_at=updated_account.created_at.isoformat() if updated_account.created_at else ""
    )
```

4. Also add an endpoint to get account by phone (useful for admin/debugging):
```python
@router.get("/phone/{phone}", response_model=AccountResponse)
async def get_account_by_phone(
    phone: str,
    account: Account = Depends(get_current_account)
):
    """
    Look up account by phone number.

    Requires authentication. Used for admin/debugging.
    """
    try:
        normalized = PhoneUtils.normalize(phone)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid phone format"
        )

    # Add method to account store for this lookup
    found = account_store.get_by_phone(normalized)
    if not found:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No account with this phone number"
        )

    return AccountResponse(
        id=found.id,
        email=found.email,
        phone=found.phone,
        created_at=found.created_at.isoformat() if found.created_at else ""
    )
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
export JWT_SECRET=$(openssl rand -hex 32)

# Verify endpoint added
python -c "from app.routers.auth import router; print([r.path for r in router.routes])"
# Should include '/phone'
```
  </verify>
  <done>
- /phone endpoint added to auth router
- Phone number normalized using PhoneUtils
- Invalid phone numbers rejected with 400
- Account updated with linked phone
  </done>
</task>

<task type="auto">
  <name>Task 2: Add get_by_phone to AccountStore</name>
  <files>
    backend/app/models/account.py
  </files>
  <action>
Add a method to look up accounts by phone number.

Update `backend/app/models/account.py` AccountStore class:

```python
def get_by_phone(self, phone: str) -> Optional[Account]:
    """
    Get account by linked phone number.

    Args:
        phone: Normalized phone number (+61...)

    Returns:
        Account if found, None otherwise
    """
    with self._get_connection() as conn:
        cursor = conn.execute(
            "SELECT * FROM accounts WHERE phone = ?",
            (phone,)
        )
        row = cursor.fetchone()

        if row:
            return Account(
                id=row["id"],
                email=row["email"],
                password_hash=row["password_hash"],
                phone=row["phone"],
                created_at=datetime.fromisoformat(row["created_at"]) if row["created_at"] else None,
                updated_at=datetime.fromisoformat(row["updated_at"]) if row["updated_at"] else None
            )
        return None
```

This enables looking up which Account owns a particular phone number, useful for connecting web sessions to SMS User data.
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "from app.models.account import account_store; print(hasattr(account_store, 'get_by_phone'))"
# Should print True
```
  </verify>
  <done>
- get_by_phone method added to AccountStore
- Can look up accounts by linked phone
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auth test suite</name>
  <files>
    backend/tests/test_auth.py
  </files>
  <action>
Create comprehensive tests for the auth system.

Create `backend/tests/test_auth.py`:

```python
"""
Authentication System Tests

Tests for:
- Account registration (FOUN-03)
- Login and JWT tokens (FOUN-04)
- Phone number linking (FOUN-05)

Run with: pytest tests/test_auth.py -v
"""
import pytest
import os
import sqlite3
from datetime import datetime, timedelta, timezone

# Set JWT_SECRET for tests
os.environ["JWT_SECRET"] = "test-secret-key-for-testing-only-32chars"

from app.services.auth import (
    hash_password,
    verify_password,
    create_access_token,
)
from app.models.account import Account, AccountStore


class TestPasswordHashing:
    """Tests for Argon2 password hashing."""

    def test_hash_password_returns_string(self):
        """Hash should return a string."""
        hashed = hash_password("mypassword")
        assert isinstance(hashed, str)
        assert len(hashed) > 0

    def test_hash_password_different_each_time(self):
        """Each hash should be unique (salted)."""
        hash1 = hash_password("mypassword")
        hash2 = hash_password("mypassword")
        assert hash1 != hash2  # Different salts

    def test_verify_password_correct(self):
        """Correct password should verify."""
        hashed = hash_password("mypassword")
        assert verify_password("mypassword", hashed) is True

    def test_verify_password_incorrect(self):
        """Incorrect password should not verify."""
        hashed = hash_password("mypassword")
        assert verify_password("wrongpassword", hashed) is False

    def test_verify_password_empty(self):
        """Empty password should not verify."""
        hashed = hash_password("mypassword")
        assert verify_password("", hashed) is False


class TestJWT:
    """Tests for JWT token creation."""

    def test_create_token_returns_string(self):
        """Token should be a non-empty string."""
        token = create_access_token({"sub": "test@example.com"})
        assert isinstance(token, str)
        assert len(token) > 0

    def test_create_token_with_custom_expiry(self):
        """Token should accept custom expiry."""
        token = create_access_token(
            {"sub": "test@example.com"},
            expires_delta=timedelta(hours=1)
        )
        assert isinstance(token, str)

    def test_token_contains_payload(self):
        """Token should decode back to payload."""
        import jwt
        token = create_access_token({"sub": "test@example.com", "custom": "data"})

        # Decode without verification for testing
        decoded = jwt.decode(token, options={"verify_signature": False})
        assert decoded["sub"] == "test@example.com"
        assert decoded["custom"] == "data"
        assert "exp" in decoded


class TestAccountStore:
    """Tests for AccountStore database operations."""

    @pytest.fixture
    def test_db(self, tmp_path):
        """Create a fresh test database."""
        db_path = tmp_path / "test.db"

        # Create accounts table
        conn = sqlite3.connect(str(db_path))
        conn.execute("""
            CREATE TABLE accounts (
                id INTEGER PRIMARY KEY,
                email TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                phone TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )
        """)
        conn.commit()
        conn.close()

        return str(db_path)

    @pytest.fixture
    def store(self, test_db):
        """Get AccountStore with test database."""
        return AccountStore(db_path=test_db)

    def test_create_account(self, store):
        """Should create account and return it."""
        account = store.create(
            email="test@example.com",
            password_hash="hashed_password"
        )

        assert account.id is not None
        assert account.email == "test@example.com"
        assert account.password_hash == "hashed_password"
        assert account.phone is None
        assert account.created_at is not None

    def test_create_account_lowercase_email(self, store):
        """Email should be stored lowercase."""
        account = store.create(
            email="Test@EXAMPLE.com",
            password_hash="hashed"
        )
        assert account.email == "test@example.com"

    def test_create_duplicate_email_fails(self, store):
        """Duplicate email should raise error."""
        store.create(email="test@example.com", password_hash="hash1")

        with pytest.raises(sqlite3.IntegrityError):
            store.create(email="test@example.com", password_hash="hash2")

    def test_get_by_email(self, store):
        """Should retrieve account by email."""
        store.create(email="test@example.com", password_hash="hashed")

        found = store.get_by_email("test@example.com")
        assert found is not None
        assert found.email == "test@example.com"

    def test_get_by_email_case_insensitive(self, store):
        """Email lookup should be case-insensitive."""
        store.create(email="test@example.com", password_hash="hashed")

        found = store.get_by_email("TEST@EXAMPLE.COM")
        assert found is not None

    def test_get_by_email_not_found(self, store):
        """Non-existent email should return None."""
        found = store.get_by_email("notfound@example.com")
        assert found is None

    def test_get_by_id(self, store):
        """Should retrieve account by ID."""
        created = store.create(email="test@example.com", password_hash="hashed")

        found = store.get_by_id(created.id)
        assert found is not None
        assert found.email == "test@example.com"

    def test_link_phone(self, store):
        """Should link phone number to account."""
        account = store.create(email="test@example.com", password_hash="hashed")
        assert account.phone is None

        success = store.link_phone(account.id, "+61412345678")
        assert success is True

        updated = store.get_by_id(account.id)
        assert updated.phone == "+61412345678"

    def test_link_phone_updates_timestamp(self, store):
        """Linking phone should update updated_at."""
        account = store.create(email="test@example.com", password_hash="hashed")
        original_updated = account.updated_at

        # Small delay to ensure timestamp differs
        import time
        time.sleep(0.01)

        store.link_phone(account.id, "+61412345678")
        updated = store.get_by_id(account.id)

        assert updated.updated_at >= original_updated

    def test_get_by_phone(self, store):
        """Should retrieve account by phone number."""
        account = store.create(email="test@example.com", password_hash="hashed")
        store.link_phone(account.id, "+61412345678")

        found = store.get_by_phone("+61412345678")
        assert found is not None
        assert found.email == "test@example.com"

    def test_get_by_phone_not_found(self, store):
        """Non-existent phone should return None."""
        found = store.get_by_phone("+61400000000")
        assert found is None


class TestEndToEndAuth:
    """Integration tests for complete auth flows."""

    @pytest.fixture
    def test_db(self, tmp_path):
        """Create a fresh test database."""
        db_path = tmp_path / "test.db"

        conn = sqlite3.connect(str(db_path))
        conn.execute("""
            CREATE TABLE accounts (
                id INTEGER PRIMARY KEY,
                email TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                phone TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )
        """)
        conn.commit()
        conn.close()

        return str(db_path)

    def test_register_and_login_flow(self, test_db):
        """Complete registration and login flow."""
        store = AccountStore(db_path=test_db)

        # Register
        password = "securepassword123"
        hashed = hash_password(password)
        account = store.create(email="user@example.com", password_hash=hashed)

        assert account.id is not None

        # Login (verify credentials)
        found = store.get_by_email("user@example.com")
        assert found is not None
        assert verify_password(password, found.password_hash)

        # Create token
        token = create_access_token({"sub": found.email})
        assert len(token) > 0

    def test_link_phone_flow(self, test_db):
        """Complete phone linking flow."""
        store = AccountStore(db_path=test_db)

        # Create account
        account = store.create(
            email="user@example.com",
            password_hash=hash_password("password")
        )
        assert account.phone is None

        # Link phone
        store.link_phone(account.id, "+61412345678")

        # Verify
        updated = store.get_by_id(account.id)
        assert updated.phone == "+61412345678"

        # Can now lookup by phone
        by_phone = store.get_by_phone("+61412345678")
        assert by_phone.email == "user@example.com"
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Run auth tests
pytest tests/test_auth.py -v

# Should show all tests passing

# Run full test suite
pytest tests/ -v

# All tests should pass
```
  </verify>
  <done>
- test_auth.py created with comprehensive tests
- Password hashing tests (5 tests)
- JWT token tests (3 tests)
- AccountStore tests (11 tests)
- End-to-end auth flow tests (2 tests)
- All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Phone linking test:
```bash
cd /Users/andrewhall/thunderbird-web/backend
export JWT_SECRET=$(openssl rand -hex 32)

# Start server
uvicorn app.main:app --port 8000 &
sleep 3

# Register
curl -s -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "phone@test.com", "password": "testpass123"}'

# Login
TOKEN=$(curl -s -X POST http://localhost:8000/auth/token \
  -d "username=phone@test.com&password=testpass123" | python -c "import sys,json; print(json.load(sys.stdin)['access_token'])")

# Link phone
curl -s -X POST http://localhost:8000/auth/phone \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"phone": "0412345678"}'
# Should return account with phone: "+61412345678"

# Verify phone linked
curl -s http://localhost:8000/auth/me \
  -H "Authorization: Bearer $TOKEN"
# Should show phone in response

pkill -f "uvicorn app.main:app"
```

2. Test suite verification:
```bash
pytest tests/test_auth.py -v
# All tests pass

pytest tests/ -v
# Full suite passes
```
</verification>

<success_criteria>
- [ ] /auth/phone endpoint added for phone linking
- [ ] Phone numbers normalized using existing PhoneUtils
- [ ] Invalid phone formats rejected with 400
- [ ] get_by_phone method added to AccountStore
- [ ] test_auth.py created with 20+ tests
- [ ] All auth tests pass
- [ ] All existing tests still pass
- [ ] FOUN-05 requirement satisfied (phone linking)
- [ ] Phase 1 complete (all 5 requirements)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
