---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - backend/alembic/versions/002_accounts_table.py
  - backend/app/models/account.py
  - backend/app/services/auth.py
  - backend/app/routers/auth.py
  - backend/app/main.py
  - backend/config/settings.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "User can register with email and password"
    - "User can log in with email and password"
    - "Session persists across browser refresh"
    - "Invalid credentials return 401"
  artifacts:
    - path: "backend/app/models/account.py"
      provides: "Account model and AccountStore"
      exports: ["Account", "AccountStore", "account_store"]
    - path: "backend/app/services/auth.py"
      provides: "JWT token and password handling"
      exports: ["create_access_token", "verify_password", "hash_password", "get_current_account"]
    - path: "backend/app/routers/auth.py"
      provides: "Auth endpoints"
      exports: ["router"]
    - path: "backend/alembic/versions/002_accounts_table.py"
      provides: "Migration for accounts table"
      contains: "create_table"
  key_links:
    - from: "backend/app/routers/auth.py"
      to: "backend/app/services/auth.py"
      via: "import"
      pattern: "from app.services.auth import"
    - from: "backend/app/routers/auth.py"
      to: "backend/app/models/account.py"
      via: "import"
      pattern: "from app.models.account import"
    - from: "backend/app/main.py"
      to: "backend/app/routers/auth.py"
      via: "include_router"
      pattern: "include_router.*auth"
---

<objective>
Implement account registration, login, and JWT session persistence

Purpose: FOUN-03 (account creation) and FOUN-04 (session persistence) require a complete auth system. This creates the Account model (distinct from existing User model), JWT-based authentication, and registration/login endpoints.

Output: Working auth system where users can register, login, and maintain sessions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/andrewhall/thunderbird-web/.planning/PROJECT.md
@/Users/andrewhall/thunderbird-web/.planning/ROADMAP.md
@/Users/andrewhall/thunderbird-web/.planning/phases/01-foundation/01-RESEARCH.md

# Previous plan summary (Alembic setup)
@/Users/andrewhall/thunderbird-web/.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing code to integrate with
@/Users/andrewhall/thunderbird-web/backend/app/main.py
@/Users/andrewhall/thunderbird-web/backend/app/models/database.py
@/Users/andrewhall/thunderbird-web/backend/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and update settings</name>
  <files>
    backend/requirements.txt
    backend/config/settings.py
  </files>
  <action>
Add required packages and JWT configuration settings.

1. Update `backend/requirements.txt` - add these lines:
```
pyjwt>=2.8.0
pwdlib[argon2]>=0.2.0
email-validator>=2.0.0
```

2. Install the new dependencies:
```bash
cd /Users/andrewhall/thunderbird-web/backend
pip install pyjwt "pwdlib[argon2]" email-validator
```

3. Update `backend/config/settings.py` - add JWT settings to Settings class:

```python
# JWT Authentication
JWT_SECRET: str = ""  # REQUIRED - generate with: openssl rand -hex 32
JWT_ALGORITHM: str = "HS256"
JWT_EXPIRY_MINUTES: int = 30
```

IMPORTANT: JWT_SECRET has no default - it MUST be set in environment. This prevents accidentally running with a weak secret.

4. Add a startup check in settings or main.py that fails if JWT_SECRET is empty in non-debug mode:
```python
@property
def jwt_configured(self) -> bool:
    """Check if JWT is properly configured."""
    return bool(self.JWT_SECRET)
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Verify packages installed
python -c "import jwt; print(f'PyJWT {jwt.__version__}')"
python -c "from pwdlib import PasswordHash; print('pwdlib OK')"
python -c "from email_validator import validate_email; print('email-validator OK')"

# Verify settings load (will warn about JWT_SECRET)
python -c "from config.settings import settings; print('Settings OK')"
```
  </verify>
  <done>
- PyJWT, pwdlib, email-validator installed
- JWT settings added to Settings class
- Startup will fail if JWT_SECRET not set (production safety)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create accounts table migration and model</name>
  <files>
    backend/alembic/versions/002_accounts_table.py
    backend/app/models/account.py
  </files>
  <action>
Create the accounts table migration and Account model/store.

1. Create Alembic migration:
```bash
cd /Users/andrewhall/thunderbird-web/backend
alembic revision -m "accounts_table"
```

2. Edit the generated migration file:

```python
"""accounts_table

Revision ID: 002
Revises: 001
Create Date: 2026-01-19

Creates accounts table for web authentication.
Note: Accounts are distinct from Users (SMS hikers).
"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


revision: str = '002'
down_revision: Union[str, None] = '001'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Create accounts table."""
    op.create_table(
        'accounts',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('email', sa.String(255), unique=True, nullable=False),
        sa.Column('password_hash', sa.String(255), nullable=False),
        sa.Column('phone', sa.String(20), nullable=True),  # Linked in FOUN-05
        sa.Column('created_at', sa.String(30), nullable=False),
        sa.Column('updated_at', sa.String(30), nullable=False),
    )

    # Create index on email for fast lookups
    op.create_index('ix_accounts_email', 'accounts', ['email'], unique=True)


def downgrade() -> None:
    """Drop accounts table."""
    op.drop_index('ix_accounts_email', table_name='accounts')
    op.drop_table('accounts')
```

3. Run the migration:
```bash
cd /Users/andrewhall/thunderbird-web/backend
alembic upgrade head
```

4. Create `backend/app/models/account.py`:

```python
"""
Account model for web authentication.

IMPORTANT: Account is for web login (email/password).
This is DISTINCT from User which is for SMS hikers.
They will be linked via phone number in FOUN-05.
"""
import os
import sqlite3
from datetime import datetime
from dataclasses import dataclass
from typing import Optional
from contextlib import contextmanager


DB_PATH = os.environ.get("THUNDERBIRD_DB_PATH", "thunderbird.db")


@dataclass
class Account:
    """
    Web account for authentication.

    Attributes:
        id: Primary key
        email: Unique email address
        password_hash: Argon2 hashed password
        phone: Optional linked phone number (for connecting to SMS User)
        created_at: Account creation timestamp
        updated_at: Last modification timestamp
    """
    id: int
    email: str
    password_hash: str
    phone: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class AccountStore:
    """
    SQLite-backed account storage.

    Follows the same patterns as SQLiteUserStore from database.py.
    """

    def __init__(self, db_path: str = None):
        self.db_path = db_path or DB_PATH

    @contextmanager
    def _get_connection(self):
        """Get database connection with row factory."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def create(self, email: str, password_hash: str) -> Account:
        """
        Create a new account.

        Args:
            email: Account email (must be unique)
            password_hash: Pre-hashed password (use auth.hash_password)

        Returns:
            Created Account object

        Raises:
            sqlite3.IntegrityError: If email already exists
        """
        now = datetime.utcnow().isoformat()

        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO accounts (email, password_hash, created_at, updated_at)
                   VALUES (?, ?, ?, ?)""",
                (email.lower(), password_hash, now, now)
            )
            conn.commit()

            return Account(
                id=cursor.lastrowid,
                email=email.lower(),
                password_hash=password_hash,
                phone=None,
                created_at=datetime.fromisoformat(now),
                updated_at=datetime.fromisoformat(now)
            )

    def get_by_email(self, email: str) -> Optional[Account]:
        """
        Get account by email address.

        Args:
            email: Email to look up (case-insensitive)

        Returns:
            Account if found, None otherwise
        """
        with self._get_connection() as conn:
            cursor = conn.execute(
                "SELECT * FROM accounts WHERE email = ?",
                (email.lower(),)
            )
            row = cursor.fetchone()

            if row:
                return Account(
                    id=row["id"],
                    email=row["email"],
                    password_hash=row["password_hash"],
                    phone=row["phone"],
                    created_at=datetime.fromisoformat(row["created_at"]) if row["created_at"] else None,
                    updated_at=datetime.fromisoformat(row["updated_at"]) if row["updated_at"] else None
                )
            return None

    def get_by_id(self, account_id: int) -> Optional[Account]:
        """Get account by ID."""
        with self._get_connection() as conn:
            cursor = conn.execute(
                "SELECT * FROM accounts WHERE id = ?",
                (account_id,)
            )
            row = cursor.fetchone()

            if row:
                return Account(
                    id=row["id"],
                    email=row["email"],
                    password_hash=row["password_hash"],
                    phone=row["phone"],
                    created_at=datetime.fromisoformat(row["created_at"]) if row["created_at"] else None,
                    updated_at=datetime.fromisoformat(row["updated_at"]) if row["updated_at"] else None
                )
            return None

    def link_phone(self, account_id: int, phone: str) -> bool:
        """
        Link a phone number to an account.

        Used to connect web Account to SMS User.

        Args:
            account_id: Account to update
            phone: Phone number to link (normalized format)

        Returns:
            True if updated, False if account not found
        """
        now = datetime.utcnow().isoformat()

        with self._get_connection() as conn:
            cursor = conn.execute(
                "UPDATE accounts SET phone = ?, updated_at = ? WHERE id = ?",
                (phone, now, account_id)
            )
            conn.commit()
            return cursor.rowcount > 0


# Singleton instance
account_store = AccountStore()
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Verify migration ran
alembic current
# Should show revision 002

# Verify table exists
sqlite3 thunderbird.db ".schema accounts"
# Should show accounts table

# Verify model imports
python -c "from app.models.account import Account, AccountStore, account_store; print('Account model OK')"
```
  </verify>
  <done>
- Alembic migration 002 created for accounts table
- Migration runs successfully
- Account dataclass and AccountStore created
- Singleton account_store available
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auth service and router</name>
  <files>
    backend/app/services/auth.py
    backend/app/routers/auth.py
    backend/app/main.py
  </files>
  <action>
Create the authentication service (JWT + password handling) and auth router (register + login endpoints).

1. Create `backend/app/services/auth.py`:

```python
"""
Authentication service for JWT tokens and password handling.

Uses PyJWT for tokens and pwdlib with Argon2 for password hashing.
Following FastAPI official security patterns.
"""
from datetime import datetime, timedelta, timezone
from typing import Optional
import jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from pwdlib import PasswordHash

from config.settings import settings
from app.models.account import Account, account_store


# OAuth2 scheme for token extraction from Authorization header
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")

# Argon2 password hasher (recommended replacement for bcrypt)
password_hash = PasswordHash.recommended()


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against a hashed password.

    Args:
        plain_password: The password to verify
        hashed_password: The stored Argon2 hash

    Returns:
        True if password matches, False otherwise
    """
    return password_hash.verify(plain_password, hashed_password)


def hash_password(password: str) -> str:
    """
    Hash a password using Argon2.

    Args:
        password: Plain text password

    Returns:
        Argon2 hash string
    """
    return password_hash.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a JWT access token.

    Args:
        data: Payload data (typically {"sub": email})
        expires_delta: Optional custom expiry (defaults to JWT_EXPIRY_MINUTES)

    Returns:
        Encoded JWT token string
    """
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.JWT_EXPIRY_MINUTES)

    to_encode.update({"exp": expire})

    return jwt.encode(
        to_encode,
        settings.JWT_SECRET,
        algorithm=settings.JWT_ALGORITHM
    )


async def get_current_account(token: str = Depends(oauth2_scheme)) -> Account:
    """
    FastAPI dependency to get the current authenticated account.

    Use this on protected endpoints:
        @router.get("/protected")
        async def protected(account: Account = Depends(get_current_account)):
            return {"email": account.email}

    Raises:
        HTTPException 401 if token is invalid or expired
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET,
            algorithms=[settings.JWT_ALGORITHM]
        )
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidTokenError:
        raise credentials_exception

    account = account_store.get_by_email(email)
    if account is None:
        raise credentials_exception

    return account
```

2. Create `backend/app/routers/auth.py`:

```python
"""
Authentication router for registration and login.

Endpoints:
- POST /auth/register - Create new account
- POST /auth/token - Login and get JWT token
- GET /auth/me - Get current account info
"""
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from pydantic import BaseModel, EmailStr, Field
from datetime import timedelta

from app.services.auth import (
    hash_password,
    verify_password,
    create_access_token,
    get_current_account,
)
from app.models.account import Account, account_store
from config.settings import settings


router = APIRouter(prefix="/auth", tags=["auth"])


# Request/Response models

class RegisterRequest(BaseModel):
    """Registration request body."""
    email: EmailStr
    password: str = Field(..., min_length=8, description="Minimum 8 characters")


class AccountResponse(BaseModel):
    """Account info response (excludes password)."""
    id: int
    email: str
    phone: str | None = None
    created_at: str


class Token(BaseModel):
    """JWT token response."""
    access_token: str
    token_type: str


# Endpoints

@router.post("/register", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def register(request: RegisterRequest):
    """
    Register a new account.

    Args:
        request: Email and password

    Returns:
        Created account info

    Raises:
        400 if email already registered
    """
    # Check if email exists
    existing = account_store.get_by_email(request.email)
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # Create account
    hashed = hash_password(request.password)
    account = account_store.create(email=request.email, password_hash=hashed)

    return AccountResponse(
        id=account.id,
        email=account.email,
        phone=account.phone,
        created_at=account.created_at.isoformat() if account.created_at else ""
    )


@router.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    Login to get access token.

    Uses OAuth2 password flow - send username (email) and password
    as form data.

    Returns:
        JWT access token

    Raises:
        401 if credentials are incorrect
    """
    account = account_store.get_by_email(form_data.username)

    if not account or not verify_password(form_data.password, account.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = create_access_token(
        data={"sub": account.email},
        expires_delta=timedelta(minutes=settings.JWT_EXPIRY_MINUTES)
    )

    return Token(access_token=access_token, token_type="bearer")


@router.get("/me", response_model=AccountResponse)
async def get_me(account: Account = Depends(get_current_account)):
    """
    Get current authenticated account.

    Requires valid JWT in Authorization header.
    """
    return AccountResponse(
        id=account.id,
        email=account.email,
        phone=account.phone,
        created_at=account.created_at.isoformat() if account.created_at else ""
    )
```

3. Update `backend/app/main.py` to include auth router:

Add import at top:
```python
from app.routers import auth
```

Add router registration after other routers:
```python
app.include_router(auth.router)
```

Also add JWT_SECRET validation on startup (in lifespan or startup event):
```python
if not settings.DEBUG and not settings.JWT_SECRET:
    raise RuntimeError("JWT_SECRET must be set in production")
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Set JWT_SECRET for testing
export JWT_SECRET=$(openssl rand -hex 32)

# Verify imports work
python -c "from app.services.auth import create_access_token, hash_password; print('Auth service OK')"
python -c "from app.routers.auth import router; print('Auth router OK')"

# Start server briefly to test endpoints
# (In a separate terminal or background)
uvicorn app.main:app --host 0.0.0.0 --port 8000 &
sleep 3

# Test registration
curl -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "testpassword123"}'
# Should return account JSON with 201

# Test login
curl -X POST http://localhost:8000/auth/token \
  -d "username=test@example.com&password=testpassword123"
# Should return {"access_token": "...", "token_type": "bearer"}

# Test /me with token (grab token from above)
TOKEN="<paste token here>"
curl http://localhost:8000/auth/me \
  -H "Authorization: Bearer $TOKEN"
# Should return account info

# Clean up
pkill -f "uvicorn app.main:app"

# Run tests
pytest tests/ -v
```
  </verify>
  <done>
- auth.py service created with JWT + Argon2 password handling
- auth.py router created with /register, /token, /me endpoints
- Router integrated into main.py
- Registration creates account in database
- Login returns valid JWT
- /me endpoint validates JWT and returns account
- All existing tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. End-to-end auth flow test:
```bash
cd /Users/andrewhall/thunderbird-web/backend
export JWT_SECRET=$(openssl rand -hex 32)

# Start server
uvicorn app.main:app --port 8000 &
sleep 3

# Register
REGISTER=$(curl -s -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "flow@test.com", "password": "securepass123"}')
echo "Register: $REGISTER"

# Login
TOKEN_RESPONSE=$(curl -s -X POST http://localhost:8000/auth/token \
  -d "username=flow@test.com&password=securepass123")
echo "Token: $TOKEN_RESPONSE"

TOKEN=$(echo $TOKEN_RESPONSE | python -c "import sys,json; print(json.load(sys.stdin)['access_token'])")

# Get /me
ME=$(curl -s http://localhost:8000/auth/me \
  -H "Authorization: Bearer $TOKEN")
echo "Me: $ME"

# Cleanup
pkill -f "uvicorn app.main:app"
```

2. Session persistence test (JWT can be stored and reused):
```bash
# Same token should work across requests
curl http://localhost:8000/auth/me -H "Authorization: Bearer $TOKEN"
# Returns same account - proves session persistence
```

3. Invalid credentials test:
```bash
# Wrong password
curl -s -X POST http://localhost:8000/auth/token \
  -d "username=flow@test.com&password=wrongpassword"
# Should return 401
```
</verification>

<success_criteria>
- [ ] PyJWT, pwdlib, email-validator installed
- [ ] JWT settings added to Settings (JWT_SECRET, JWT_ALGORITHM, JWT_EXPIRY_MINUTES)
- [ ] Alembic migration 002 creates accounts table
- [ ] Account model and AccountStore implemented
- [ ] Auth service provides hash_password, verify_password, create_access_token, get_current_account
- [ ] Auth router provides /register, /token, /me endpoints
- [ ] User can register with email/password (FOUN-03)
- [ ] User can login and receive JWT
- [ ] JWT can be used across requests (FOUN-04 session persistence)
- [ ] Invalid credentials return 401
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
