---
phase: 06-international-weather
plan: 06
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03", "06-04", "06-05"]
files_modified:
  - backend/app/services/weather/router.py
  - backend/app/services/weather/__init__.py
  - backend/app/services/weather_intl.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Router selects correct provider for each country"
    - "Router falls back to Open-Meteo when primary provider fails"
    - "Failed primary providers trigger fallback transparently"
    - "Data source (provider name) is tracked in forecast"
    - "weather_intl.py InternationalWeatherService uses the router"
  artifacts:
    - path: "backend/app/services/weather/router.py"
      provides: "Country-to-provider routing with fallback"
      exports: ["WeatherRouter", "get_weather_router"]
    - path: "backend/app/services/weather_intl.py"
      provides: "Updated InternationalWeatherService wired to router"
      exports: ["InternationalWeatherService", "get_weather_intl_service"]
  key_links:
    - from: "backend/app/services/weather/router.py"
      to: "backend/app/services/weather/providers/*.py"
      via: "imports and instantiates providers"
      pattern: "NWSProvider|EnvironmentCanadaProvider|MetOfficeProvider|OpenMeteoProvider"
    - from: "backend/app/services/weather_intl.py"
      to: "backend/app/services/weather/router.py"
      via: "uses WeatherRouter"
      pattern: "WeatherRouter|get_weather_router"
---

<objective>
Create the weather router that selects providers by country and handles fallback, then wire it to the existing weather_intl.py service.

Purpose: The router is the integration point - it knows which provider to use for each country and handles failures gracefully. This completes the provider architecture and enables WTHR-11 (data source display).

Output: Working WeatherRouter that routes requests to correct providers with automatic Open-Meteo fallback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-international-weather/06-CONTEXT.md
@.planning/phases/06-international-weather/06-RESEARCH.md
@.planning/phases/06-international-weather/06-01-SUMMARY.md
@.planning/phases/06-international-weather/06-02-SUMMARY.md
@.planning/phases/06-international-weather/06-03-SUMMARY.md
@.planning/phases/06-international-weather/06-04-SUMMARY.md
@.planning/phases/06-international-weather/06-05-SUMMARY.md
@backend/app/services/weather_intl.py
@backend/app/services/weather/base.py
@backend/app/services/weather/cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create weather router with provider mapping</name>
  <files>backend/app/services/weather/router.py</files>
  <action>
Create WeatherRouter that maps countries to providers.

Provider mapping based on research:
```python
class WeatherRouter:
    def __init__(self):
        self.providers = {
            "US": NWSProvider(),
            "CA": EnvironmentCanadaProvider(),
            "GB": MetOfficeProvider(),
            "FR": OpenMeteoProvider(model=OpenMeteoModel.METEOFRANCE),
            "IT": OpenMeteoProvider(model=OpenMeteoModel.ICON_EU),
            "CH": OpenMeteoProvider(model=OpenMeteoModel.METEOSWISS),
            "NZ": OpenMeteoProvider(model=OpenMeteoModel.BEST_MATCH),
            "ZA": OpenMeteoProvider(model=OpenMeteoModel.BEST_MATCH),
        }
        self.fallback = OpenMeteoProvider(model=OpenMeteoModel.BEST_MATCH)
        self.cache = get_weather_cache()
```

Key methods:
1. `get_provider(country_code: str) -> WeatherProvider`
   - Returns the primary provider for a country
   - Falls back to self.fallback for unknown countries

2. `async get_forecast(lat, lon, country_code, days=7) -> NormalizedDailyForecast`
   - Check cache first
   - Try primary provider
   - On failure, try fallback
   - Set is_fallback=True if fallback used
   - Cache successful result

3. `async get_alerts(lat, lon, country_code) -> List[WeatherAlert]`
   - Get provider for country
   - If supports_alerts, fetch alerts
   - Return empty list on error (don't fail)
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "
from app.services.weather.router import WeatherRouter

router = WeatherRouter()

# Test provider mapping
us = router.get_provider('US')
print(f'US provider: {us.provider_name}')
assert us.provider_name == 'NWS'

uk = router.get_provider('GB')
print(f'UK provider: {uk.provider_name}')
assert uk.provider_name == 'Met Office'

fr = router.get_provider('FR')
print(f'FR provider: {fr.provider_name}')
assert 'Meteo-France' in fr.provider_name

unknown = router.get_provider('XX')
print(f'Unknown country: {unknown.provider_name}')
assert 'Open-Meteo' in unknown.provider_name

print('Provider mapping OK')
"
```
  </verify>
  <done>WeatherRouter maps countries to correct providers</done>
</task>

<task type="auto">
  <name>Task 2: Implement fallback logic with caching</name>
  <files>backend/app/services/weather/router.py</files>
  <action>
Implement the fallback and caching logic in WeatherRouter.

```python
async def get_forecast(
    self,
    lat: float,
    lon: float,
    country_code: str,
    days: int = 7
) -> NormalizedDailyForecast:
    provider = self.get_provider(country_code)

    # Check cache first
    cache_key = f"{provider.provider_name}:{lat:.4f},{lon:.4f}:{days}"
    cached = self.cache.get(provider.provider_name, lat, lon, days)
    if cached:
        logger.debug(f"Cache hit for {cache_key}")
        return cached

    # Try primary provider
    try:
        forecast = await provider.get_forecast(lat, lon, days)
        forecast.country_code = country_code
        forecast.is_fallback = False
        self.cache.set(provider.provider_name, lat, lon, days, forecast)
        return forecast
    except Exception as e:
        logger.warning(f"{provider.provider_name} failed for {country_code}: {e}")

    # Fallback to Open-Meteo
    try:
        logger.info(f"Falling back to Open-Meteo for {country_code}")
        forecast = await self.fallback.get_forecast(lat, lon, days)
        forecast.country_code = country_code
        forecast.is_fallback = True  # Mark as fallback
        self.cache.set(self.fallback.provider_name, lat, lon, days, forecast)
        return forecast
    except Exception as e:
        logger.error(f"All providers failed for {country_code}: {e}")
        raise WeatherProviderError(f"Unable to fetch weather for {country_code}")
```

Add WeatherProviderError exception class.

Important: Set is_fallback=True when fallback is used - this enables WTHR-11 (data source display).
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "
from app.services.weather.router import WeatherRouter
import asyncio

async def test():
    router = WeatherRouter()

    # Test real forecast (US - NWS should work)
    forecast = await router.get_forecast(40.7128, -74.0060, 'US', days=2)
    print(f'US forecast: {forecast.provider}, is_fallback={forecast.is_fallback}')
    assert forecast.is_fallback == False

    # Test country using Open-Meteo directly
    forecast = await router.get_forecast(-44.6714, 167.9256, 'NZ', days=2)
    print(f'NZ forecast: {forecast.provider}, is_fallback={forecast.is_fallback}')

    print('Fallback logic OK')

asyncio.run(test())
"
```
  </verify>
  <done>Router implements fallback with is_fallback tracking</done>
</task>

<task type="auto">
  <name>Task 3: Wire router to InternationalWeatherService</name>
  <files>backend/app/services/weather_intl.py</files>
  <action>
Update the existing weather_intl.py to use WeatherRouter instead of stubs.

Replace the stub implementations with real router calls:

```python
from app.services.weather.router import WeatherRouter, get_weather_router
from app.services.weather.base import NormalizedForecast, NormalizedDailyForecast, WeatherAlert

class InternationalWeatherService:
    def __init__(self):
        self.router = get_weather_router()

    async def get_forecast(
        self,
        lat: float,
        lon: float,
        country_code: str
    ) -> NormalizedForecast:
        """Get current/next period forecast."""
        daily = await self.router.get_forecast(lat, lon, country_code, days=1)
        return daily.periods[0] if daily.periods else None

    async def get_daily_forecast(
        self,
        lat: float,
        lon: float,
        country_code: str,
        days: int = 7
    ) -> NormalizedDailyForecast:
        """Get multi-day forecast."""
        return await self.router.get_forecast(lat, lon, country_code, days)

    async def fetch_with_fallback(
        self,
        lat: float,
        lon: float,
        country_code: str
    ) -> NormalizedForecast:
        """Fetch from primary, fall back to Open-Meteo."""
        return await self.get_forecast(lat, lon, country_code)

    async def get_alerts(
        self,
        lat: float,
        lon: float,
        country_code: str
    ) -> List[WeatherAlert]:
        """Get active weather alerts."""
        return await self.router.get_alerts(lat, lon, country_code)
```

Keep the existing WeatherProvider enum and get_provider_for_country method for backwards compatibility.

Add new method `get_data_source(forecast) -> str` for WTHR-11:
```python
def get_data_source(self, forecast: NormalizedDailyForecast) -> str:
    """Get display-friendly data source name."""
    source = forecast.provider
    if forecast.is_fallback:
        return f"{source} (fallback)"
    return source
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "
from app.services.weather_intl import get_weather_intl_service
import asyncio

async def test():
    service = get_weather_intl_service()

    # Test US forecast
    forecast = await service.get_daily_forecast(40.7128, -74.0060, 'US', days=2)
    source = service.get_data_source(forecast)
    print(f'US forecast: {len(forecast.periods)} periods, source={source}')

    # Test alerts (US has alert support)
    alerts = await service.get_alerts(40.7128, -74.0060, 'US')
    print(f'US alerts: {len(alerts)}')

    print('InternationalWeatherService wired OK')

asyncio.run(test())
"
```
  </verify>
  <done>InternationalWeatherService wired to router and working</done>
</task>

</tasks>

<verification>
After all tasks:
1. WeatherRouter maps all 8 countries to correct providers
2. Unknown countries fall back to Open-Meteo
3. Primary provider failures trigger automatic fallback
4. is_fallback flag tracks when fallback was used
5. Cache prevents redundant API calls
6. InternationalWeatherService methods work with real data
7. get_data_source returns provider name with fallback indicator
</verification>

<success_criteria>
- [ ] WeatherRouter maps US, CA, GB, FR, IT, CH, NZ, ZA to providers
- [ ] Unknown countries use Open-Meteo fallback
- [ ] Fallback triggers on provider failure
- [ ] is_fallback=True when fallback used
- [ ] Cache integrated (1-hour TTL)
- [ ] InternationalWeatherService uses router
- [ ] get_data_source method works (for WTHR-11)
- [ ] Alerts fetched for supporting providers
</success_criteria>

<output>
After completion, create `.planning/phases/06-international-weather/06-06-SUMMARY.md`
</output>
