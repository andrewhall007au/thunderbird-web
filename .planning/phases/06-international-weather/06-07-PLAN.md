---
phase: 06-international-weather
plan: 07
type: execute
wave: 4
depends_on: ["06-06"]
files_modified:
  - backend/tests/test_weather_providers.py
  - backend/tests/test_weather_router.py
  - .planning/REQUIREMENTS.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All 8 country providers are tested"
    - "Fallback logic is tested"
    - "Cache behavior is tested"
    - "WTHR-01 through WTHR-11 requirements verified"
  artifacts:
    - path: "backend/tests/test_weather_providers.py"
      provides: "Unit tests for each weather provider"
      min_lines: 150
    - path: "backend/tests/test_weather_router.py"
      provides: "Integration tests for weather router"
      min_lines: 100
  key_links:
    - from: "backend/tests/test_weather_providers.py"
      to: "backend/app/services/weather/providers/*.py"
      via: "imports and tests providers"
      pattern: "from app\\.services\\.weather\\.providers"
    - from: "backend/tests/test_weather_router.py"
      to: "backend/app/services/weather/router.py"
      via: "imports and tests router"
      pattern: "from app\\.services\\.weather\\.router"
---

<objective>
Create comprehensive tests for weather providers and router, then verify all WTHR requirements.

Purpose: Ensures the weather system is reliable before marking phase complete. Tests verify each provider works, fallback triggers correctly, and caching behaves as expected.

Output: Test suite for weather system and verified WTHR-01 through WTHR-11 requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-international-weather/06-CONTEXT.md
@.planning/phases/06-international-weather/06-06-SUMMARY.md
@backend/app/services/weather/router.py
@backend/app/services/weather_intl.py
@backend/tests/test_affiliates.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provider unit tests</name>
  <files>backend/tests/test_weather_providers.py</files>
  <action>
Create unit tests for each weather provider.

Test structure following existing test_affiliates.py patterns:
```python
import pytest
from unittest.mock import AsyncMock, patch, MagicMock
from app.services.weather.base import NormalizedForecast, NormalizedDailyForecast, WeatherAlert
from app.services.weather.providers.openmeteo import OpenMeteoProvider, OpenMeteoModel
from app.services.weather.providers.nws import NWSProvider
from app.services.weather.providers.envcanada import EnvironmentCanadaProvider
from app.services.weather.providers.metoffice import MetOfficeProvider

class TestOpenMeteoProvider:
    """Tests for Open-Meteo provider."""

    @pytest.mark.asyncio
    async def test_fetch_forecast_default_model(self):
        """Open-Meteo fetches forecast with default model."""
        provider = OpenMeteoProvider()
        forecast = await provider.get_forecast(40.7128, -74.0060, days=2)
        assert forecast.provider == "Open-Meteo"
        assert len(forecast.periods) > 0

    @pytest.mark.asyncio
    async def test_fetch_forecast_meteofrance_model(self):
        """Open-Meteo fetches with Meteo-France model for France."""
        provider = OpenMeteoProvider(model=OpenMeteoModel.METEOFRANCE)
        forecast = await provider.get_forecast(45.9237, 6.8694, days=2)
        assert "Meteo-France" in forecast.provider

    @pytest.mark.asyncio
    async def test_fetch_forecast_meteoswiss_model(self):
        """Open-Meteo fetches with MeteoSwiss model for Switzerland."""
        provider = OpenMeteoProvider(model=OpenMeteoModel.METEOSWISS)
        forecast = await provider.get_forecast(46.0207, 7.7491, days=2)
        assert "MeteoSwiss" in forecast.provider

    def test_no_alerts_support(self):
        """Open-Meteo does not support alerts."""
        provider = OpenMeteoProvider()
        assert provider.supports_alerts == False


class TestNWSProvider:
    """Tests for NWS provider."""

    @pytest.mark.asyncio
    async def test_fetch_forecast_us_coordinates(self):
        """NWS fetches forecast for US coordinates."""
        provider = NWSProvider()
        forecast = await provider.get_forecast(40.7128, -74.0060, days=2)
        assert forecast.provider == "NWS"
        assert len(forecast.periods) > 0

    @pytest.mark.asyncio
    async def test_grid_caching(self):
        """NWS caches grid info."""
        provider = NWSProvider()
        grid1 = await provider._get_grid_info(40.7128, -74.0060)
        grid2 = await provider._get_grid_info(40.7128, -74.0060)
        assert grid1.office == grid2.office  # Same cached result

    @pytest.mark.asyncio
    async def test_alerts_support(self):
        """NWS supports alerts."""
        provider = NWSProvider()
        assert provider.supports_alerts == True
        alerts = await provider.get_alerts(40.7128, -74.0060)
        assert isinstance(alerts, list)

    @pytest.mark.asyncio
    async def test_temperature_conversion(self):
        """NWS temperatures are converted to Celsius."""
        provider = NWSProvider()
        forecast = await provider.get_forecast(40.7128, -74.0060, days=1)
        # Celsius temps should be reasonable (not Fahrenheit)
        for period in forecast.periods:
            assert -50 < period.temp_min < 50  # Reasonable Celsius range
            assert -50 < period.temp_max < 50


class TestEnvironmentCanadaProvider:
    """Tests for Environment Canada provider."""

    @pytest.mark.asyncio
    async def test_fetch_forecast_canada_coordinates(self):
        """EC fetches forecast for Canadian coordinates."""
        provider = EnvironmentCanadaProvider()
        forecast = await provider.get_forecast(51.1784, -115.5708, days=2)
        assert forecast.provider == "Environment Canada"
        assert len(forecast.periods) > 0

    @pytest.mark.asyncio
    async def test_alerts_support(self):
        """EC supports alerts."""
        provider = EnvironmentCanadaProvider()
        assert provider.supports_alerts == True


class TestMetOfficeProvider:
    """Tests for Met Office provider."""

    def test_requires_api_key(self):
        """Met Office requires API key."""
        import os
        original = os.environ.get("METOFFICE_API_KEY")
        os.environ.pop("METOFFICE_API_KEY", None)
        try:
            provider = MetOfficeProvider()
            # Should not have API key
            assert provider.api_key is None
        finally:
            if original:
                os.environ["METOFFICE_API_KEY"] = original

    def test_no_alerts_support(self):
        """Met Office free tier does not support alerts."""
        provider = MetOfficeProvider()
        assert provider.supports_alerts == False
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
pytest tests/test_weather_providers.py -v --tb=short 2>&1 | head -50
```
  </verify>
  <done>Provider unit tests created and passing</done>
</task>

<task type="auto">
  <name>Task 2: Create router integration tests</name>
  <files>backend/tests/test_weather_router.py</files>
  <action>
Create integration tests for weather router.

```python
import pytest
from unittest.mock import AsyncMock, patch
from app.services.weather.router import WeatherRouter, WeatherProviderError
from app.services.weather.cache import WeatherCache
from app.services.weather.base import NormalizedDailyForecast, NormalizedForecast
from datetime import datetime

class TestWeatherRouter:
    """Tests for weather router."""

    def test_provider_mapping_us(self):
        """Router maps US to NWS."""
        router = WeatherRouter()
        provider = router.get_provider("US")
        assert provider.provider_name == "NWS"

    def test_provider_mapping_canada(self):
        """Router maps CA to Environment Canada."""
        router = WeatherRouter()
        provider = router.get_provider("CA")
        assert provider.provider_name == "Environment Canada"

    def test_provider_mapping_uk(self):
        """Router maps GB to Met Office."""
        router = WeatherRouter()
        provider = router.get_provider("GB")
        assert provider.provider_name == "Met Office"

    def test_provider_mapping_france(self):
        """Router maps FR to Open-Meteo Meteo-France."""
        router = WeatherRouter()
        provider = router.get_provider("FR")
        assert "Meteo-France" in provider.provider_name

    def test_provider_mapping_switzerland(self):
        """Router maps CH to Open-Meteo MeteoSwiss."""
        router = WeatherRouter()
        provider = router.get_provider("CH")
        assert "MeteoSwiss" in provider.provider_name

    def test_provider_mapping_italy(self):
        """Router maps IT to Open-Meteo ICON."""
        router = WeatherRouter()
        provider = router.get_provider("IT")
        assert "ICON" in provider.provider_name

    def test_provider_mapping_unknown(self):
        """Router uses Open-Meteo for unknown countries."""
        router = WeatherRouter()
        provider = router.get_provider("XX")
        assert "Open-Meteo" in provider.provider_name

    @pytest.mark.asyncio
    async def test_fallback_on_primary_failure(self):
        """Router falls back to Open-Meteo when primary fails."""
        router = WeatherRouter()

        # Mock primary provider to fail
        router.providers["US"].get_forecast = AsyncMock(
            side_effect=Exception("API Error")
        )

        # Should fallback to Open-Meteo
        forecast = await router.get_forecast(40.7128, -74.0060, "US", days=2)
        assert forecast.is_fallback == True
        assert "Open-Meteo" in forecast.provider

    @pytest.mark.asyncio
    async def test_is_fallback_false_when_primary_succeeds(self):
        """Router sets is_fallback=False when primary succeeds."""
        router = WeatherRouter()
        forecast = await router.get_forecast(40.7128, -74.0060, "US", days=2)
        assert forecast.is_fallback == False

    @pytest.mark.asyncio
    async def test_cache_hit(self):
        """Router uses cached forecast."""
        router = WeatherRouter()

        # Fetch once
        forecast1 = await router.get_forecast(40.7128, -74.0060, "US", days=2)

        # Fetch again - should be cached
        forecast2 = await router.get_forecast(40.7128, -74.0060, "US", days=2)

        # Should be same data (from cache)
        assert forecast1.provider == forecast2.provider

    @pytest.mark.asyncio
    async def test_alerts_for_supporting_provider(self):
        """Router fetches alerts from supporting providers."""
        router = WeatherRouter()
        alerts = await router.get_alerts(40.7128, -74.0060, "US")
        assert isinstance(alerts, list)

    @pytest.mark.asyncio
    async def test_alerts_empty_for_non_supporting_provider(self):
        """Router returns empty alerts for non-supporting providers."""
        router = WeatherRouter()
        alerts = await router.get_alerts(46.0207, 7.7491, "CH")  # Switzerland
        assert alerts == []


class TestWeatherCache:
    """Tests for weather cache."""

    def test_cache_miss(self):
        """Cache returns None for missing entries."""
        cache = WeatherCache()
        result = cache.get("test", 40.0, -74.0, 7)
        assert result is None

    def test_cache_hit(self):
        """Cache returns stored forecast."""
        cache = WeatherCache()
        mock_forecast = NormalizedDailyForecast(
            provider="test",
            lat=40.0,
            lon=-74.0,
            country_code="US",
            periods=[],
            alerts=[],
            fetched_at=datetime.now(),
            is_fallback=False
        )
        cache.set("test", 40.0, -74.0, 7, mock_forecast)
        result = cache.get("test", 40.0, -74.0, 7)
        assert result is not None
        assert result.provider == "test"

    def test_cache_invalidate(self):
        """Cache invalidate removes entry."""
        cache = WeatherCache()
        mock_forecast = NormalizedDailyForecast(
            provider="test",
            lat=40.0,
            lon=-74.0,
            country_code="US",
            periods=[],
            alerts=[],
            fetched_at=datetime.now(),
            is_fallback=False
        )
        cache.set("test", 40.0, -74.0, 7, mock_forecast)
        cache.invalidate("test", 40.0, -74.0)
        result = cache.get("test", 40.0, -74.0, 7)
        assert result is None
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
pytest tests/test_weather_router.py -v --tb=short 2>&1 | head -50
```
  </verify>
  <done>Router integration tests created and passing</done>
</task>

<task type="auto">
  <name>Task 3: Verify WTHR requirements and update REQUIREMENTS.md</name>
  <files>.planning/REQUIREMENTS.md</files>
  <action>
Verify each WTHR requirement is met and mark complete in REQUIREMENTS.md.

Verification checklist:

**WTHR-01: Weather API integration for USA (NWS)**
- NWSProvider exists in backend/app/services/weather/providers/nws.py
- Fetches from api.weather.gov
- Test: pytest -k "test_fetch_forecast_us" passes
- VERIFIED

**WTHR-02: Weather API integration for Canada**
- EnvironmentCanadaProvider exists
- Uses env-canada library
- Test: pytest -k "test_fetch_forecast_canada" passes
- VERIFIED

**WTHR-03: Weather API integration for UK (Met Office)**
- MetOfficeProvider exists
- Uses Weather DataHub API (not deprecated DataPoint)
- Test: Provider structure test passes
- VERIFIED

**WTHR-04: Weather API integration for France (Meteo-France)**
- OpenMeteoProvider with METEOFRANCE model
- Test: pytest -k "test_fetch_forecast_meteofrance" passes
- VERIFIED

**WTHR-05: Weather API integration for Italy**
- OpenMeteoProvider with ICON_EU model
- Test: Router maps IT correctly
- VERIFIED

**WTHR-06: Weather API integration for Switzerland (MeteoSwiss)**
- OpenMeteoProvider with METEOSWISS model
- Test: pytest -k "test_fetch_forecast_meteoswiss" passes
- VERIFIED

**WTHR-07: Weather API integration for New Zealand**
- OpenMeteoProvider with BEST_MATCH model
- Test: Router maps NZ correctly
- VERIFIED

**WTHR-08: Weather API integration for South Africa**
- OpenMeteoProvider with BEST_MATCH model
- Test: Router maps ZA correctly
- VERIFIED

**WTHR-09: Open-Meteo fallback for all countries**
- WeatherRouter has fallback provider
- Test: test_fallback_on_primary_failure passes
- VERIFIED

**WTHR-10: Weather response normalization layer**
- NormalizedForecast and NormalizedDailyForecast in base.py
- All providers normalize to this format
- VERIFIED

**WTHR-11: Data source displayed in forecasts**
- forecast.provider contains source name
- forecast.is_fallback indicates when fallback used
- InternationalWeatherService.get_data_source() method
- VERIFIED

Update REQUIREMENTS.md:
- Change all WTHR-01 through WTHR-11 from `[ ]` to `[x]`
- Update traceability table status to Complete
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
# Run all weather tests
pytest tests/test_weather_providers.py tests/test_weather_router.py -v --tb=short

# Verify requirements marked complete
grep -c "\[x\] \*\*WTHR" ../.planning/REQUIREMENTS.md
```
  </verify>
  <done>All WTHR requirements verified and marked complete</done>
</task>

</tasks>

<verification>
After all tasks:
1. test_weather_providers.py covers all provider classes
2. test_weather_router.py covers routing and fallback
3. All tests pass
4. REQUIREMENTS.md shows WTHR-01 through WTHR-11 as complete
5. Phase 6 deliverables complete
</verification>

<success_criteria>
- [ ] Provider tests cover Open-Meteo, NWS, EC, Met Office
- [ ] Router tests cover all 8 country mappings
- [ ] Fallback behavior tested
- [ ] Cache behavior tested
- [ ] All tests pass
- [ ] WTHR-01 through WTHR-11 marked complete in REQUIREMENTS.md
- [ ] Traceability table updated
</success_criteria>

<output>
After completion, create `.planning/phases/06-international-weather/06-07-SUMMARY.md`
</output>
