---
phase: 06-international-weather
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/weather/__init__.py
  - backend/app/services/weather/base.py
  - backend/app/services/weather/providers/__init__.py
  - backend/app/services/weather/providers/openmeteo.py
  - backend/app/services/weather/cache.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Open-Meteo provider can fetch forecasts for any coordinates"
    - "Forecasts are normalized to consistent NormalizedForecast format"
    - "Forecasts are cached for 1 hour"
    - "Cache returns cached data within TTL"
  artifacts:
    - path: "backend/app/services/weather/base.py"
      provides: "WeatherProvider ABC and NormalizedForecast dataclass"
      exports: ["WeatherProvider", "NormalizedForecast", "WeatherAlert"]
    - path: "backend/app/services/weather/providers/openmeteo.py"
      provides: "Open-Meteo provider implementation"
      exports: ["OpenMeteoProvider"]
    - path: "backend/app/services/weather/cache.py"
      provides: "1-hour caching layer for weather data"
      exports: ["WeatherCache", "get_weather_cache"]
  key_links:
    - from: "backend/app/services/weather/providers/openmeteo.py"
      to: "backend/app/services/weather/base.py"
      via: "implements WeatherProvider ABC"
      pattern: "class OpenMeteoProvider\\(WeatherProvider\\)"
    - from: "backend/app/services/weather/cache.py"
      to: "backend/app/services/weather/base.py"
      via: "caches NormalizedForecast objects"
      pattern: "NormalizedForecast"
---

<objective>
Create the weather provider foundation: base abstractions, Open-Meteo universal provider, and caching layer.

Purpose: Establishes the core architecture that all country-specific providers will build upon. Open-Meteo serves as both the universal fallback (WTHR-09) and the normalization reference implementation (WTHR-10).

Output: Working Open-Meteo provider with caching that can fetch forecasts for any global coordinates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-international-weather/06-CONTEXT.md
@.planning/phases/06-international-weather/06-RESEARCH.md
@backend/app/services/weather_intl.py
@backend/app/services/bom.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create weather provider base abstractions</name>
  <files>
    backend/app/services/weather/__init__.py
    backend/app/services/weather/base.py
    backend/app/services/weather/providers/__init__.py
  </files>
  <action>
Create the weather service package structure with base abstractions.

In `base.py`:
1. Create `NormalizedForecast` dataclass extending the existing one in weather_intl.py:
   - provider: str (provider name for display)
   - lat, lon: float
   - timestamp: datetime
   - temp_min, temp_max: float (Celsius)
   - rain_chance: int (0-100%)
   - rain_amount: float (mm)
   - wind_avg, wind_max: float (km/h)
   - wind_direction: str (N, NE, E, etc.)
   - cloud_cover: int (0-100%)
   - freezing_level: Optional[int] (meters)
   - snow_amount: float (cm, default 0)
   - description: str (text summary)
   - alerts: List[WeatherAlert] (default empty)

2. Create `WeatherAlert` dataclass:
   - event: str (e.g., "Winter Storm Warning")
   - headline: str
   - severity: str (Minor, Moderate, Severe, Extreme)
   - urgency: str (Immediate, Expected, Future)
   - expires: Optional[datetime]

3. Create `NormalizedDailyForecast` dataclass:
   - provider: str
   - lat, lon: float
   - country_code: str
   - periods: List[NormalizedForecast]
   - alerts: List[WeatherAlert]
   - fetched_at: datetime
   - is_fallback: bool (True if fallback provider used)

4. Create `WeatherProvider` ABC with:
   - async def get_forecast(lat, lon, days=7) -> NormalizedDailyForecast
   - async def get_alerts(lat, lon) -> List[WeatherAlert] (default returns empty list)
   - property provider_name -> str
   - property supports_alerts -> bool (default False)

In `__init__.py` files, export the key classes.
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "from app.services.weather.base import WeatherProvider, NormalizedForecast, NormalizedDailyForecast, WeatherAlert; print('Base imports OK')"
```
  </verify>
  <done>WeatherProvider ABC and NormalizedForecast dataclasses are importable and correctly structured</done>
</task>

<task type="auto">
  <name>Task 2: Implement Open-Meteo universal provider</name>
  <files>backend/app/services/weather/providers/openmeteo.py</files>
  <action>
Create OpenMeteoProvider implementing WeatherProvider ABC.

Key implementation details from research:
1. Base URL: https://api.open-meteo.com/v1/forecast (default)
2. Model-specific endpoints:
   - meteofrance: https://api.open-meteo.com/v1/meteofrance
   - meteoswiss: https://api.open-meteo.com/v1/meteoswiss
   - icon_eu: https://api.open-meteo.com/v1/dwd-icon
   - best_match: default endpoint

3. Constructor accepts `model` parameter to select endpoint

4. Request parameters for hiking forecasts:
   ```python
   params = {
       "latitude": lat,
       "longitude": lon,
       "hourly": ",".join([
           "temperature_2m",
           "precipitation_probability",
           "precipitation",
           "rain",
           "snowfall",
           "wind_speed_10m",
           "wind_gusts_10m",
           "wind_direction_10m",
           "cloud_cover",
           "freezing_level_height"
       ]),
       "timezone": "auto",
       "forecast_days": min(days, 16),
   }
   ```

5. Use httpx.AsyncClient with 30-second timeout
6. Normalize response to NormalizedDailyForecast:
   - Aggregate hourly data into 3-hour periods (matching existing bom.py pattern)
   - Calculate wind direction from degrees to compass (N, NE, E, etc.)
   - Convert snowfall from cm to appropriate units
   - Handle None values gracefully

7. Open-Meteo does NOT support alerts - return empty list

8. Provider name: "Open-Meteo" (or "Open-Meteo (Meteo-France)" etc. based on model)
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "
from app.services.weather.providers.openmeteo import OpenMeteoProvider
import asyncio

async def test():
    provider = OpenMeteoProvider()
    # Test with known coordinates (NYC)
    forecast = await provider.get_forecast(40.7128, -74.0060, days=3)
    assert forecast.provider == 'Open-Meteo'
    assert len(forecast.periods) > 0
    print(f'Got {len(forecast.periods)} periods for NYC')
    print(f'First period: {forecast.periods[0].temp_min}C to {forecast.periods[0].temp_max}C')

asyncio.run(test())
"
```
  </verify>
  <done>OpenMeteoProvider fetches and normalizes forecasts for any coordinates</done>
</task>

<task type="auto">
  <name>Task 3: Implement weather caching layer</name>
  <files>backend/app/services/weather/cache.py</files>
  <action>
Create WeatherCache for 1-hour TTL caching of forecast data.

Implementation:
1. In-memory cache using dict with cache keys
2. Cache key format: f"{provider}:{lat:.4f},{lon:.4f}:{days}"
3. Store tuple of (forecast, expires_at)
4. TTL: 1 hour (from CONTEXT.md decision)

Class methods:
- `get(provider, lat, lon, days) -> Optional[NormalizedDailyForecast]`
  - Returns None if not cached or expired
  - Returns cached forecast if within TTL

- `set(provider, lat, lon, days, forecast) -> None`
  - Stores forecast with expiry time

- `invalidate(provider, lat, lon) -> None`
  - Removes cached entries for location

- `clear() -> None`
  - Clears entire cache

Add singleton accessor `get_weather_cache()`.

Note: This is a simple in-memory cache. For production scale, could be replaced with Redis, but in-memory is sufficient for MVP given:
- Cache is per-process (fine for single server)
- Restarts clear cache (acceptable for weather data)
- Memory usage is bounded by active locations
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend
python -c "
from app.services.weather.cache import WeatherCache, get_weather_cache
from app.services.weather.base import NormalizedDailyForecast
from datetime import datetime

cache = get_weather_cache()

# Test cache miss
result = cache.get('test', 40.0, -74.0, 7)
assert result is None, 'Should be cache miss'

# Create mock forecast
from app.services.weather.base import NormalizedForecast
mock_forecast = NormalizedDailyForecast(
    provider='test',
    lat=40.0,
    lon=-74.0,
    country_code='US',
    periods=[],
    alerts=[],
    fetched_at=datetime.now(),
    is_fallback=False
)

# Test cache set/get
cache.set('test', 40.0, -74.0, 7, mock_forecast)
result = cache.get('test', 40.0, -74.0, 7)
assert result is not None, 'Should be cache hit'
assert result.provider == 'test'

print('Cache tests passed')
"
```
  </verify>
  <done>WeatherCache provides 1-hour TTL caching with get/set/invalidate operations</done>
</task>

</tasks>

<verification>
After all tasks:
1. Weather package structure exists at backend/app/services/weather/
2. Base abstractions (WeatherProvider, NormalizedForecast) are importable
3. OpenMeteoProvider can fetch real forecasts from Open-Meteo API
4. WeatherCache stores and retrieves forecasts with 1-hour TTL
5. All imports work without circular dependency issues
</verification>

<success_criteria>
- [ ] WeatherProvider ABC defined with get_forecast and get_alerts methods
- [ ] NormalizedForecast and NormalizedDailyForecast dataclasses match existing weather_intl.py patterns
- [ ] OpenMeteoProvider fetches and normalizes forecasts
- [ ] WeatherCache implements 1-hour TTL caching
- [ ] All new code follows existing codebase patterns (async, httpx, dataclasses)
</success_criteria>

<output>
After completion, create `.planning/phases/06-international-weather/06-01-SUMMARY.md`
</output>
