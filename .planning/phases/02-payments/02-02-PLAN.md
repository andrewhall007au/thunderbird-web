---
phase: 02-payments
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/services/payments.py
  - backend/app/services/balance.py
  - backend/app/services/pricing_dynamic.py
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing for initial purchase and top-ups"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key"
      - name: STRIPE_PUBLISHABLE_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Publishable key"
    dashboard_config:
      - task: "Create test mode API keys"
        location: "Stripe Dashboard -> Developers -> API keys"

must_haves:
  truths:
    - "Admin can configure launch price vs RRP"
    - "Discount code validation returns correct discounted amount"
    - "Balance is updated atomically with transaction record"
    - "Stripe checkout session creates with correct amount"
  artifacts:
    - path: "backend/app/services/pricing_dynamic.py"
      provides: "Dynamic pricing with launch/RRP support"
      exports: ["DynamicPricingService", "get_pricing_service"]
    - path: "backend/app/services/balance.py"
      provides: "Balance tracking service"
      exports: ["BalanceService", "get_balance_service"]
    - path: "backend/app/services/payments.py"
      provides: "Updated Stripe integration"
      exports: ["PaymentService", "get_payment_service"]
  key_links:
    - from: "backend/app/services/payments.py"
      to: "backend/app/services/pricing_dynamic.py"
      via: "price calculation before checkout"
      pattern: "pricing_service\\.get_checkout_price"
    - from: "backend/app/services/balance.py"
      to: "backend/app/models/payments.py"
      via: "balance_store operations"
      pattern: "balance_store\\."
---

<objective>
Implement dynamic pricing service, balance tracking, and Stripe checkout session creation.

Purpose: Enable the core purchase flow - PAY-01 (checkout), PAY-02 (dynamic pricing), PAY-03/PAY-04 (discount codes), PAY-06 (balance tracking). This plan builds the payment services without webhook handling (that's Plan 03).

Output: Working pricing calculation, balance service with atomic updates, and Stripe checkout session creation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-payments/02-RESEARCH.md

# Previous plan creates these
@backend/app/models/payments.py
@backend/config/sms_pricing.py

# Existing patterns
@backend/app/services/bom.py
@backend/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dynamic pricing service</name>
  <files>backend/app/services/pricing_dynamic.py</files>
  <action>
Create pricing service that handles dynamic pricing (PAY-02) and discount code validation (PAY-03, PAY-04).

1. **Add to settings.py first:**
```python
# Pricing configuration
PRICE_RRP_CENTS: int = 4999  # $49.99 RRP
PRICE_LAUNCH_CENTS: int = 2999  # $29.99 launch price
PRICE_MODE: str = "launch"  # "rrp" | "launch" | "sale"
PRICE_SALE_CENTS: int = 2499  # Optional sale price
```

2. **Create pricing_dynamic.py with:**

```python
"""
Dynamic pricing service.
Handles PAY-02 (dynamic pricing) and PAY-03/04 (discount codes).
"""

class DynamicPricingService:
    """
    Manages product pricing with launch/RRP/sale modes.
    """

    def get_base_price_cents(self) -> int:
        """Get current base price based on settings.PRICE_MODE."""
        # Returns PRICE_LAUNCH_CENTS, PRICE_RRP_CENTS, or PRICE_SALE_CENTS

    def validate_discount_code(self, code: str) -> DiscountValidation:
        """
        Validate discount code.
        Returns: DiscountValidation(valid, discount_code, error_message)
        """
        # Check code exists in discount_code_store
        # Check active=True
        # Check max_uses not exceeded

    def calculate_final_price(
        self,
        base_price_cents: int,
        discount_code: Optional[str] = None
    ) -> PriceCalculation:
        """
        Calculate final price with optional discount.

        Returns: PriceCalculation(
            base_price_cents,
            discount_cents,
            final_price_cents,
            discount_code_applied
        )

        PAY-04: Discounts stack with launch pricing.
        Example: $29.99 launch - 10% discount = $26.99
        """

    def get_checkout_price(self, discount_code: Optional[str] = None) -> PriceCalculation:
        """Convenience method: get base price and apply discount."""
        base = self.get_base_price_cents()
        return self.calculate_final_price(base, discount_code)

3. **Data classes:**
- DiscountValidation(valid: bool, discount_code: Optional[DiscountCode], error_message: Optional[str])
- PriceCalculation(base_price_cents: int, discount_cents: int, final_price_cents: int, discount_code_applied: Optional[str])

4. **Singleton pattern:**
```python
_pricing_service: Optional[DynamicPricingService] = None

def get_pricing_service() -> DynamicPricingService:
    global _pricing_service
    if _pricing_service is None:
        _pricing_service = DynamicPricingService()
    return _pricing_service
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.pricing_dynamic import get_pricing_service

svc = get_pricing_service()
# Test base price
base = svc.get_base_price_cents()
print(f'Base price: {base} cents (expect 2999)')
assert base == 2999, 'Launch price should be 2999'

# Test calculation without discount
calc = svc.get_checkout_price()
print(f'No discount: {calc.final_price_cents} cents')
assert calc.final_price_cents == 2999

# Test with invalid discount
calc2 = svc.get_checkout_price('INVALID')
print(f'Invalid code: {calc2.final_price_cents} cents (should still work, no discount)')
"
```
  </verify>
  <done>Pricing service returns 2999 for launch mode, handles missing/invalid discount codes gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Create balance tracking service</name>
  <files>backend/app/services/balance.py</files>
  <action>
Create balance service that wraps BalanceStore with business logic (PAY-06).

```python
"""
Balance tracking service.
Handles PAY-06 (balance tracking) with atomic updates and transaction logging.
"""
from decimal import Decimal
from typing import Optional, Tuple
from dataclasses import dataclass

from app.models.payments import balance_store, BalanceStore, AccountBalance, Transaction

@dataclass
class BalanceResult:
    """Result of a balance operation."""
    success: bool
    balance_cents: int
    transaction_id: Optional[int] = None
    error: Optional[str] = None

class BalanceService:
    """
    Account balance management.
    All operations are atomic - balance update and transaction log in same commit.
    """

    def __init__(self, store: BalanceStore = None):
        self.store = store or balance_store

    def get_balance(self, account_id: int) -> int:
        """Get current balance in cents. Returns 0 if no balance record."""
        balance = self.store.get_or_create(account_id)
        return balance.balance_cents

    def add_credits(
        self,
        account_id: int,
        amount_cents: int,
        description: str,
        order_id: Optional[int] = None
    ) -> BalanceResult:
        """
        Add credits to account balance.
        Creates transaction record atomically.

        Args:
            account_id: Account to credit
            amount_cents: Amount to add (positive)
            description: Audit description (e.g., "Initial purchase", "Top-up")
            order_id: Optional linked order

        Returns:
            BalanceResult with new balance
        """
        # Validate positive amount
        # Call store.add_credits which creates transaction atomically
        # Return new balance

    def deduct(
        self,
        account_id: int,
        amount_cents: int,
        description: str
    ) -> BalanceResult:
        """
        Deduct from account balance.
        Allows negative balance (for SMS cost tracking).

        Args:
            account_id: Account to debit
            amount_cents: Amount to deduct (positive number)
            description: Audit description (e.g., "SMS to +44xxx")

        Returns:
            BalanceResult with new balance (may be negative)
        """

    def check_sufficient_balance(self, account_id: int, amount_cents: int) -> bool:
        """Check if account has sufficient balance for amount."""
        return self.get_balance(account_id) >= amount_cents

    def get_balance_display(self, account_id: int) -> str:
        """Get balance formatted for display (e.g., '$12.34')."""
        cents = self.get_balance(account_id)
        return f"${cents / 100:.2f}"

    def get_transaction_history(
        self,
        account_id: int,
        limit: int = 20
    ) -> list[Transaction]:
        """Get recent transactions for account."""
        return self.store.get_transactions(account_id, limit)

# Singleton
_balance_service: Optional[BalanceService] = None

def get_balance_service() -> BalanceService:
    global _balance_service
    if _balance_service is None:
        _balance_service = BalanceService()
    return _balance_service
```

**Key requirement:** add_credits and deduct must be atomic - balance update and transaction record in same database commit. Implement this in BalanceStore if not already.
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.balance import get_balance_service
from app.models.account import account_store

# Create test account if needed
try:
    acc = account_store.create('balance_test@test.com', 'hash')
    account_id = acc.id
except:
    acc = account_store.get_by_email('balance_test@test.com')
    account_id = acc.id

svc = get_balance_service()

# Test initial balance
bal = svc.get_balance(account_id)
print(f'Initial balance: {bal} cents')

# Test add credits
result = svc.add_credits(account_id, 2999, 'Test purchase')
print(f'After add: {result.balance_cents} cents, success={result.success}')

# Test deduct
result2 = svc.deduct(account_id, 100, 'Test SMS')
print(f'After deduct: {result2.balance_cents} cents')

# Test display
print(f'Display: {svc.get_balance_display(account_id)}')
"
```
  </verify>
  <done>Balance service adds/deducts credits atomically, tracks transactions, formats for display</done>
</task>

<task type="auto">
  <name>Task 3: Update payment service with Stripe checkout</name>
  <files>backend/app/services/payments.py</files>
  <action>
Replace the stub payment service with real Stripe integration (PAY-01).

1. **Add to settings.py:**
```python
# Stripe configuration
STRIPE_SECRET_KEY: str = ""
STRIPE_PUBLISHABLE_KEY: str = ""
STRIPE_WEBHOOK_SECRET: str = ""  # Will be set in Plan 03
```

2. **Update payments.py:**

```python
"""
Payment service for Stripe integration.
Handles PAY-01 (checkout), PAY-07 (top-ups with stored card).
"""
import stripe
from typing import Optional
from dataclasses import dataclass

from config.settings import settings
from app.services.pricing_dynamic import get_pricing_service
from app.models.payments import order_store, Order

@dataclass
class PaymentResult:
    success: bool
    checkout_url: Optional[str] = None  # For redirect to Stripe
    transaction_id: Optional[str] = None
    order_id: Optional[int] = None
    error: Optional[str] = None

@dataclass
class CheckoutSession:
    session_id: str
    checkout_url: str
    amount_cents: int
    order_id: int

class PaymentService:
    """
    Stripe payment integration.

    Pattern from research:
    - Use Checkout Sessions for initial purchase (hosted payment page)
    - Use PaymentIntent with saved card for top-ups (off-session)
    - setup_future_usage: "off_session" to save card during checkout
    """

    def __init__(self):
        if settings.STRIPE_SECRET_KEY:
            stripe.api_key = settings.STRIPE_SECRET_KEY

    async def create_checkout_session(
        self,
        account_id: int,
        discount_code: Optional[str] = None,
        success_url: str = None,
        cancel_url: str = None
    ) -> PaymentResult:
        """
        Create Stripe Checkout session for initial purchase.

        PAY-01: $29.99 via Stripe Checkout
        PAY-03: User can enter discount code (allow_promotion_codes=True)

        Args:
            account_id: Account making purchase
            discount_code: Optional pre-validated discount code
            success_url: Redirect after success (with {CHECKOUT_SESSION_ID})
            cancel_url: Redirect on cancel

        Returns:
            PaymentResult with checkout_url for redirect
        """
        if not settings.STRIPE_SECRET_KEY:
            return PaymentResult(success=False, error="Stripe not configured")

        pricing = get_pricing_service()
        price_calc = pricing.get_checkout_price(discount_code)

        # Create pending order in our database
        order = order_store.create(
            account_id=account_id,
            order_type="initial_access",
            amount_cents=price_calc.final_price_cents,
            status="pending"
        )

        try:
            session = stripe.checkout.Session.create(
                customer_creation="always",
                line_items=[{
                    "price_data": {
                        "currency": "usd",
                        "product_data": {"name": "Thunderbird Access"},
                        "unit_amount": price_calc.final_price_cents,
                    },
                    "quantity": 1,
                }],
                mode="payment",
                payment_intent_data={
                    "setup_future_usage": "off_session",  # Save card for top-ups
                },
                allow_promotion_codes=True,  # PAY-03: discount code field
                metadata={
                    "account_id": str(account_id),
                    "order_id": str(order.id),
                    "purchase_type": "initial_access",
                },
                success_url=success_url or f"{settings.BASE_URL}/payment/success?session_id={{CHECKOUT_SESSION_ID}}",
                cancel_url=cancel_url or f"{settings.BASE_URL}/payment/cancel",
            )

            # Update order with Stripe session ID
            order_store.update_stripe_session(order.id, session.id)

            return PaymentResult(
                success=True,
                checkout_url=session.url,
                order_id=order.id
            )

        except stripe.error.StripeError as e:
            order_store.update_status(order.id, "failed")
            return PaymentResult(success=False, error=str(e))

    async def create_topup_checkout(
        self,
        account_id: int,
        amount_cents: int = 1000,  # Default $10
        success_url: str = None,
        cancel_url: str = None
    ) -> PaymentResult:
        """
        Create checkout session for top-up.

        PAY-07: User can top up $10 blocks
        Similar to initial checkout but order_type="top_up"
        """
        # Similar to create_checkout_session but for top-up
        pass  # Implement similar pattern

    def get_stored_payment_method(self, stripe_customer_id: str) -> Optional[str]:
        """Get default payment method ID for customer."""
        if not settings.STRIPE_SECRET_KEY:
            return None
        try:
            payment_methods = stripe.PaymentMethod.list(
                customer=stripe_customer_id,
                type="card"
            )
            if payment_methods.data:
                return payment_methods.data[0].id
            return None
        except stripe.error.StripeError:
            return None

# Singleton
_payment_service: Optional[PaymentService] = None

def get_payment_service() -> PaymentService:
    global _payment_service
    if _payment_service is None:
        _payment_service = PaymentService()
    return _payment_service
```

3. **Update order_store with update_stripe_session method** in payments model if not present.
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.payments import get_payment_service, PaymentResult

svc = get_payment_service()
print(f'Payment service instantiated')

# Without Stripe key, should return error gracefully
import asyncio
result = asyncio.run(svc.create_checkout_session(account_id=1))
print(f'Without Stripe key: success={result.success}, error={result.error}')
assert not result.success
assert 'not configured' in result.error.lower()

print('Payment service handles missing Stripe config gracefully')
"
```
  </verify>
  <done>Payment service creates checkout sessions (or returns config error), integrates with pricing and order store</done>
</task>

</tasks>

<verification>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# 1. Pricing service works
python -c "
from app.services.pricing_dynamic import get_pricing_service
svc = get_pricing_service()
assert svc.get_base_price_cents() == 2999
print('Pricing: OK')
"

# 2. Balance service works
python -c "
from app.services.balance import get_balance_service
svc = get_balance_service()
# Methods exist
assert hasattr(svc, 'add_credits')
assert hasattr(svc, 'deduct')
assert hasattr(svc, 'get_balance')
print('Balance: OK')
"

# 3. Payment service handles missing config
python -c "
from app.services.payments import get_payment_service
import asyncio
svc = get_payment_service()
result = asyncio.run(svc.create_checkout_session(1))
assert not result.success  # Should fail gracefully without Stripe key
print('Payments: OK (handles missing config)')
"

# 4. All tests pass
pytest tests/ -x -q --tb=short
```
</verification>

<success_criteria>
- Dynamic pricing returns 2999 cents (launch mode) by default
- Discount code validation works (returns error for invalid codes)
- Balance service adds/deducts atomically with transaction records
- Payment service creates Stripe checkout sessions with correct amount
- Payment service saves card for future use (setup_future_usage)
- Graceful handling when Stripe not configured (for tests)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-payments/02-02-SUMMARY.md`
</output>
