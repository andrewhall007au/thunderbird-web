---
phase: 02-payments
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - backend/app/routers/payments.py
  - backend/app/routers/webhook.py
  - backend/app/models/account.py
autonomous: true
user_setup:
  - service: stripe
    why: "Webhook endpoint for payment confirmation"
    env_vars:
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint -> Reveal signing secret"
    dashboard_config:
      - task: "Create webhook endpoint"
        location: "Stripe Dashboard -> Developers -> Webhooks"
        details: "Add endpoint https://yourapp.com/webhook/stripe, listen for checkout.session.completed"

must_haves:
  truths:
    - "Payment fulfilled ONLY via webhook, not success URL"
    - "Webhook validates Stripe signature before processing"
    - "Duplicate webhook events are handled idempotently"
    - "Balance credited only after successful payment confirmation"
    - "Stripe customer ID saved to account for future charges"
  artifacts:
    - path: "backend/app/routers/payments.py"
      provides: "Payment API endpoints"
      exports: ["router"]
    - path: "backend/app/routers/webhook.py"
      provides: "Updated webhook router with Stripe handler"
      contains: "@router.post.*stripe"
  key_links:
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/balance.py"
      via: "balance_service.add_credits on checkout.session.completed"
      pattern: "balance_service\\.add_credits"
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/models/account.py"
      via: "save stripe_customer_id to account"
      pattern: "stripe_customer_id"
---

<objective>
Create payment API router and Stripe webhook handler for payment fulfillment.

Purpose: Complete the payment flow with secure webhook handling. This implements the critical principle from research: "ONLY fulfill via checkout.session.completed webhook, never from success page redirect." Enables PAY-01 completion and prepares for PAY-05 (order confirmation email in Plan 04).

Output: Payment endpoints for checkout initiation, Stripe webhook handler with signature verification and idempotent processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-payments/02-RESEARCH.md

# Dependencies from prior plans
@backend/app/services/payments.py
@backend/app/services/balance.py
@backend/app/models/payments.py
@backend/app/models/account.py

# Existing router patterns
@backend/app/routers/webhook.py
@backend/app/routers/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment API router</name>
  <files>backend/app/routers/payments.py</files>
  <action>
Create payment router with endpoints for checkout flow.

```python
"""
Payment API endpoints.
Handles checkout initiation and payment status queries.
"""
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from typing import Optional

from app.services.payments import get_payment_service
from app.services.balance import get_balance_service
from app.routers.auth import get_current_account  # From Phase 1

router = APIRouter(prefix="/api/payments", tags=["payments"])

# Request/Response models
class CreateCheckoutRequest(BaseModel):
    discount_code: Optional[str] = None
    success_url: Optional[str] = None
    cancel_url: Optional[str] = None

class CreateCheckoutResponse(BaseModel):
    success: bool
    checkout_url: Optional[str] = None
    order_id: Optional[int] = None
    error: Optional[str] = None

class BalanceResponse(BaseModel):
    balance_cents: int
    balance_display: str  # e.g., "$12.34"

class CreateTopupRequest(BaseModel):
    amount_cents: int = 1000  # Default $10
    success_url: Optional[str] = None
    cancel_url: Optional[str] = None

# Endpoints

@router.post("/checkout", response_model=CreateCheckoutResponse)
async def create_checkout(
    request: CreateCheckoutRequest,
    account = Depends(get_current_account)
):
    """
    Create Stripe Checkout session for initial purchase.

    Returns checkout_url for redirect to Stripe hosted page.
    PAY-01, PAY-03
    """
    payment_service = get_payment_service()
    result = await payment_service.create_checkout_session(
        account_id=account.id,
        discount_code=request.discount_code,
        success_url=request.success_url,
        cancel_url=request.cancel_url
    )

    if not result.success:
        raise HTTPException(status_code=400, detail=result.error)

    return CreateCheckoutResponse(
        success=True,
        checkout_url=result.checkout_url,
        order_id=result.order_id
    )

@router.get("/balance", response_model=BalanceResponse)
async def get_balance(account = Depends(get_current_account)):
    """
    Get current account balance.
    PAY-06
    """
    balance_service = get_balance_service()
    balance_cents = balance_service.get_balance(account.id)

    return BalanceResponse(
        balance_cents=balance_cents,
        balance_display=balance_service.get_balance_display(account.id)
    )

@router.post("/topup", response_model=CreateCheckoutResponse)
async def create_topup(
    request: CreateTopupRequest,
    account = Depends(get_current_account)
):
    """
    Create checkout session for balance top-up.
    PAY-07
    """
    payment_service = get_payment_service()
    result = await payment_service.create_topup_checkout(
        account_id=account.id,
        amount_cents=request.amount_cents,
        success_url=request.success_url,
        cancel_url=request.cancel_url
    )

    if not result.success:
        raise HTTPException(status_code=400, detail=result.error)

    return CreateCheckoutResponse(
        success=True,
        checkout_url=result.checkout_url,
        order_id=result.order_id
    )

@router.get("/orders")
async def get_orders(
    account = Depends(get_current_account),
    limit: int = 20
):
    """
    Get order history for account.
    """
    from app.models.payments import order_store
    orders = order_store.get_by_account_id(account.id, limit=limit)
    return {"orders": [
        {
            "id": o.id,
            "order_type": o.order_type,
            "amount_cents": o.amount_cents,
            "status": o.status,
            "created_at": o.created_at.isoformat() if o.created_at else None,
        }
        for o in orders
    ]}
```

2. **Register router in main.py:**
```python
from app.routers.payments import router as payments_router
app.include_router(payments_router)
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.routers.payments import router
print(f'Payment router prefix: {router.prefix}')
routes = [r.path for r in router.routes]
print(f'Routes: {routes}')
assert '/checkout' in routes or 'checkout' in str(routes)
assert '/balance' in routes or 'balance' in str(routes)
print('Payment router configured correctly')
"
```
  </verify>
  <done>Payment router has /checkout, /balance, /topup, /orders endpoints requiring authentication</done>
</task>

<task type="auto">
  <name>Task 2: Add Stripe webhook handler to webhook router</name>
  <files>backend/app/routers/webhook.py</files>
  <action>
Add Stripe webhook endpoint to existing webhook router. This is CRITICAL for payment fulfillment.

1. **Add stripe_webhook endpoint to webhook.py:**

```python
import stripe
from fastapi import Request, HTTPException
import logging

from config.settings import settings
from app.services.balance import get_balance_service
from app.models.payments import order_store
from app.models.account import account_store

logger = logging.getLogger(__name__)

# Track processed events for idempotency
_processed_events: set = set()  # In production, use Redis/DB

@router.post("/stripe")
async def stripe_webhook(request: Request):
    """
    Handle Stripe webhook events.

    CRITICAL: This is the ONLY place orders are fulfilled.
    Never fulfill from success page redirect.

    Events handled:
    - checkout.session.completed: Initial purchase or top-up completed
    - payment_intent.succeeded: Off-session payment (SMS top-up)
    """
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    # Verify signature (skip in dev if no secret)
    if settings.STRIPE_WEBHOOK_SECRET:
        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, settings.STRIPE_WEBHOOK_SECRET
            )
        except ValueError:
            logger.error("Invalid Stripe webhook payload")
            raise HTTPException(status_code=400, detail="Invalid payload")
        except stripe.error.SignatureVerificationError:
            logger.error("Invalid Stripe webhook signature")
            raise HTTPException(status_code=400, detail="Invalid signature")
    else:
        # Dev mode - parse without verification
        import json
        event = stripe.Event.construct_from(
            json.loads(payload), stripe.api_key
        )

    # Idempotency check
    event_id = event.id
    if event_id in _processed_events:
        logger.info(f"Skipping duplicate event: {event_id}")
        return {"status": "already_processed"}

    # Handle event types
    if event.type == "checkout.session.completed":
        session = event.data.object
        await handle_checkout_completed(session)
    elif event.type == "payment_intent.succeeded":
        payment_intent = event.data.object
        await handle_payment_succeeded(payment_intent)
    else:
        logger.info(f"Unhandled event type: {event.type}")

    # Mark as processed
    _processed_events.add(event_id)
    # In production: store in Redis with TTL or database

    return {"status": "success"}


async def handle_checkout_completed(session):
    """
    Handle successful checkout session.

    1. Update order status to completed
    2. Save Stripe customer ID to account (for future charges)
    3. Add credits to balance
    4. Trigger confirmation email (Plan 04)
    """
    account_id = int(session.metadata.get("account_id"))
    order_id = int(session.metadata.get("order_id"))
    purchase_type = session.metadata.get("purchase_type")
    stripe_customer_id = session.customer

    logger.info(f"Checkout completed: order={order_id}, account={account_id}")

    # 1. Update order status
    order = order_store.get_by_id(order_id)
    if not order:
        logger.error(f"Order not found: {order_id}")
        return

    if order.status == "completed":
        logger.info(f"Order already completed: {order_id}")
        return

    order_store.update_status(order_id, "completed")

    # 2. Save Stripe customer ID for future charges
    if stripe_customer_id:
        account_store.update_stripe_customer_id(account_id, stripe_customer_id)

    # 3. Add credits to balance
    balance_service = get_balance_service()
    description = "Initial purchase" if purchase_type == "initial_access" else "Top-up"
    balance_service.add_credits(
        account_id=account_id,
        amount_cents=order.amount_cents,
        description=description,
        order_id=order_id
    )

    logger.info(f"Credits added: {order.amount_cents} cents to account {account_id}")

    # 4. Trigger confirmation email (implemented in Plan 04)
    # await send_order_confirmation(account_id, order_id)


async def handle_payment_succeeded(payment_intent):
    """
    Handle successful off-session payment (SMS BUY command).
    Similar to checkout but uses payment_intent metadata.
    """
    metadata = payment_intent.metadata
    if not metadata.get("account_id"):
        return  # Not our payment

    account_id = int(metadata.get("account_id"))
    order_id = metadata.get("order_id")

    if order_id:
        order_id = int(order_id)
        order_store.update_status(order_id, "completed")

        balance_service = get_balance_service()
        balance_service.add_credits(
            account_id=account_id,
            amount_cents=payment_intent.amount,
            description="SMS top-up",
            order_id=order_id
        )
        logger.info(f"SMS top-up completed: {payment_intent.amount} cents")
```

2. **Add update_stripe_customer_id to AccountStore** (in account.py):

```python
def update_stripe_customer_id(self, account_id: int, stripe_customer_id: str) -> bool:
    """Save Stripe customer ID for stored card payments."""
    now = datetime.utcnow().isoformat()
    with self._get_connection() as conn:
        cursor = conn.execute(
            "UPDATE accounts SET stripe_customer_id = ?, updated_at = ? WHERE id = ?",
            (stripe_customer_id, now, account_id)
        )
        conn.commit()
        return cursor.rowcount > 0
```

3. **Add get_stripe_customer_id to Account dataclass** if not present.
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.routers.webhook import router
routes = [r.path for r in router.routes]
print(f'Webhook routes: {routes}')
assert '/stripe' in routes or 'stripe' in str(routes), 'Stripe webhook not found'

# Check handler imports
from app.routers.webhook import handle_checkout_completed, handle_payment_succeeded
print('Webhook handlers exist')

# Check account update method
from app.models.account import AccountStore
store = AccountStore()
assert hasattr(store, 'update_stripe_customer_id'), 'Missing update_stripe_customer_id'
print('AccountStore has update_stripe_customer_id')
"
```
  </verify>
  <done>Stripe webhook validates signature, handles checkout.session.completed and payment_intent.succeeded, updates balance atomically</done>
</task>

<task type="auto">
  <name>Task 3: Register payment router and add tests</name>
  <files>backend/app/main.py, backend/tests/test_payments.py</files>
  <action>
1. **Register payment router in main.py** (add to existing router includes):

```python
from app.routers.payments import router as payments_router
app.include_router(payments_router)
```

2. **Create test_payments.py:**

```python
"""
Tests for payment endpoints and webhook handling.
"""
import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, MagicMock

# Import app for testing
from app.main import app

client = TestClient(app)

class TestPaymentEndpoints:
    """Test payment API endpoints."""

    def test_checkout_requires_auth(self):
        """Checkout endpoint requires authentication."""
        response = client.post("/api/payments/checkout", json={})
        assert response.status_code == 401

    def test_balance_requires_auth(self):
        """Balance endpoint requires authentication."""
        response = client.get("/api/payments/balance")
        assert response.status_code == 401

    def test_topup_requires_auth(self):
        """Topup endpoint requires authentication."""
        response = client.post("/api/payments/topup", json={})
        assert response.status_code == 401


class TestStripeWebhook:
    """Test Stripe webhook handling."""

    def test_webhook_rejects_invalid_signature(self):
        """Webhook rejects requests with invalid signature."""
        # Only if STRIPE_WEBHOOK_SECRET is set
        # In test mode without secret, should accept
        pass

    def test_webhook_idempotency(self):
        """Duplicate events are handled idempotently."""
        # Test that same event ID processed only once
        pass


class TestPricingService:
    """Test dynamic pricing."""

    def test_launch_price(self):
        """Launch mode returns $29.99."""
        from app.services.pricing_dynamic import get_pricing_service
        svc = get_pricing_service()
        assert svc.get_base_price_cents() == 2999

    def test_discount_calculation(self):
        """Discount codes reduce price correctly."""
        from app.services.pricing_dynamic import get_pricing_service
        svc = get_pricing_service()
        # Test with 10% discount would give 2699
        calc = svc.calculate_final_price(2999, None)  # No discount
        assert calc.final_price_cents == 2999


class TestBalanceService:
    """Test balance tracking."""

    def test_add_credits(self, test_account):
        """Adding credits increases balance."""
        from app.services.balance import get_balance_service
        svc = get_balance_service()

        initial = svc.get_balance(test_account.id)
        svc.add_credits(test_account.id, 1000, "Test")
        final = svc.get_balance(test_account.id)

        assert final == initial + 1000

    def test_deduct_balance(self, test_account):
        """Deducting reduces balance."""
        from app.services.balance import get_balance_service
        svc = get_balance_service()

        svc.add_credits(test_account.id, 1000, "Test")
        initial = svc.get_balance(test_account.id)
        svc.deduct(test_account.id, 100, "SMS")
        final = svc.get_balance(test_account.id)

        assert final == initial - 100


@pytest.fixture
def test_account():
    """Create test account for balance tests."""
    from app.models.account import account_store
    import uuid
    email = f"test_{uuid.uuid4().hex[:8]}@test.com"
    return account_store.create(email, "hash")
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Check router is registered
python -c "
from app.main import app
routes = [r.path for r in app.routes]
payment_routes = [r for r in routes if 'payment' in r]
print(f'Payment routes in app: {payment_routes}')
assert any('payment' in r for r in routes), 'Payment router not registered'
"

# Run payment tests
pytest tests/test_payments.py -v --tb=short 2>/dev/null || echo "Tests file created, run full test suite"

# Run all tests
pytest tests/ -x -q --tb=short
```
  </verify>
  <done>Payment router registered in main app, payment tests pass, all existing tests pass</done>
</task>

</tasks>

<verification>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# 1. Payment router accessible
python -c "
from app.main import app
routes = [r.path for r in app.routes]
assert '/api/payments/checkout' in routes
assert '/api/payments/balance' in routes
print('Payment routes registered')
"

# 2. Webhook handler exists
python -c "
from app.routers.webhook import handle_checkout_completed
print('Webhook handler exists')
"

# 3. Account can store Stripe customer ID
python -c "
from app.models.account import AccountStore
store = AccountStore()
assert hasattr(store, 'update_stripe_customer_id')
print('Stripe customer ID storage ready')
"

# 4. All tests pass
pytest tests/ -x -q --tb=short
```
</verification>

<success_criteria>
- POST /api/payments/checkout creates Stripe session and returns checkout_url
- GET /api/payments/balance returns account balance (requires auth)
- POST /webhook/stripe validates signature and processes checkout.session.completed
- Webhook is idempotent (duplicate events ignored)
- Balance credited only via webhook, not success URL
- Stripe customer ID saved to account for future stored card payments
- All payment tests pass
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-payments/02-03-SUMMARY.md`
</output>
