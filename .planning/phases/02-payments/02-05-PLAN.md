---
phase: 02-payments
plan: 05
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - backend/app/services/payments.py
  - backend/app/services/commands.py
  - backend/app/routers/webhook.py
  - backend/app/services/balance.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can top up with stored card via web (one click)"
    - "User can text BUY $10 to add credits"
    - "User receives low balance warning SMS at $2"
    - "SMS top-up charges stored card off-session"
  artifacts:
    - path: "backend/app/services/commands.py"
      provides: "BUY command handler"
      contains: "CommandType.BUY"
    - path: "backend/app/services/payments.py"
      provides: "charge_stored_card method"
      contains: "def charge_stored_card"
    - path: "backend/app/services/balance.py"
      provides: "check_and_warn_low_balance method"
      contains: "LOW_BALANCE_THRESHOLD"
  key_links:
    - from: "backend/app/services/commands.py"
      to: "backend/app/services/payments.py"
      via: "BUY command calls charge_stored_card"
      pattern: "payment_service\\.charge_stored_card"
    - from: "backend/app/services/balance.py"
      to: "backend/app/services/sms.py"
      via: "low balance warning sends SMS"
      pattern: "sms_service\\.send_message"
---

<objective>
Implement stored card top-ups and SMS BUY command with low balance warnings.

Purpose: Complete PAY-07 (web top-up with stored card), PAY-08 (SMS BUY command), and PAY-09 (low balance warning at $2). These features enable users to easily maintain their balance.

Output: One-click web top-up, BUY $10 SMS command, automatic low balance SMS warning.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-payments/02-RESEARCH.md

# Dependencies
@backend/app/services/payments.py
@backend/app/services/balance.py
@backend/app/services/commands.py
@backend/app/services/sms.py
@backend/app/models/account.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement stored card charging for top-ups</name>
  <files>backend/app/services/payments.py</files>
  <action>
Add off-session payment capability using stored cards (PAY-07, PAY-08).

Add to PaymentService class:

```python
async def charge_stored_card(
    self,
    account_id: int,
    amount_cents: int = 1000,  # Default $10
    description: str = "Top-up"
) -> PaymentResult:
    """
    Charge stored card for top-up (off-session payment).

    PAY-07: Web top-up with stored card
    PAY-08: SMS "BUY $10" command

    Uses PaymentIntent API with saved payment method.
    Card was saved during initial checkout (setup_future_usage).

    Args:
        account_id: Account to charge
        amount_cents: Amount to charge (default $10 = 1000 cents)
        description: Transaction description

    Returns:
        PaymentResult with success/error
    """
    if not settings.STRIPE_SECRET_KEY:
        return PaymentResult(success=False, error="Stripe not configured")

    # Get account with Stripe customer ID
    from app.models.account import account_store
    account = account_store.get_by_id(account_id)

    if not account or not account.stripe_customer_id:
        return PaymentResult(
            success=False,
            error="No payment method on file. Visit thunderbird.app/account to add a card."
        )

    # Get stored payment method
    payment_method_id = self.get_stored_payment_method(account.stripe_customer_id)
    if not payment_method_id:
        return PaymentResult(
            success=False,
            error="No card on file. Add one at thunderbird.app/account"
        )

    # Create pending order
    order = order_store.create(
        account_id=account_id,
        order_type="top_up",
        amount_cents=amount_cents,
        status="pending"
    )

    try:
        # Create and confirm payment intent in one call
        payment_intent = stripe.PaymentIntent.create(
            amount=amount_cents,
            currency="usd",
            customer=account.stripe_customer_id,
            payment_method=payment_method_id,
            off_session=True,
            confirm=True,  # Charge immediately
            metadata={
                "account_id": str(account_id),
                "order_id": str(order.id),
                "purchase_type": "top_up",
            }
        )

        # Update order with payment intent ID
        order_store.update_payment_intent(order.id, payment_intent.id)

        # Check if payment succeeded immediately
        if payment_intent.status == "succeeded":
            # Fulfillment happens via webhook, but we can return success
            return PaymentResult(
                success=True,
                transaction_id=payment_intent.id,
                order_id=order.id
            )
        elif payment_intent.status == "requires_action":
            # Card requires 3DS - can't complete off-session
            order_store.update_status(order.id, "failed")
            return PaymentResult(
                success=False,
                error="Card requires authentication. Please top up at thunderbird.app/account"
            )
        else:
            order_store.update_status(order.id, "failed")
            return PaymentResult(
                success=False,
                error=f"Payment status: {payment_intent.status}"
            )

    except stripe.error.CardError as e:
        # Card declined
        order_store.update_status(order.id, "failed")
        return PaymentResult(
            success=False,
            error=f"Card declined: {e.user_message}"
        )
    except stripe.error.StripeError as e:
        order_store.update_status(order.id, "failed")
        return PaymentResult(success=False, error=str(e))


async def quick_topup_web(self, account_id: int) -> PaymentResult:
    """
    One-click web top-up for $10.
    PAY-07: User can top up $10 blocks via web with stored card.
    """
    return await self.charge_stored_card(account_id, 1000, "Web top-up")
```

Also add update_payment_intent to OrderStore in payments model:

```python
def update_payment_intent(self, order_id: int, payment_intent_id: str):
    """Update order with Stripe payment intent ID."""
    now = datetime.utcnow().isoformat()
    with self._get_connection() as conn:
        conn.execute(
            "UPDATE orders SET stripe_payment_intent_id = ?, updated_at = ? WHERE id = ?",
            (payment_intent_id, now, order_id)
        )
        conn.commit()
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.payments import get_payment_service
import asyncio

svc = get_payment_service()

# Should handle missing Stripe config gracefully
result = asyncio.run(svc.charge_stored_card(account_id=1, amount_cents=1000))
print(f'Without Stripe: success={result.success}, error={result.error}')
assert not result.success

# Quick topup method exists
assert hasattr(svc, 'quick_topup_web')
print('Stored card charging methods exist')
"
```
  </verify>
  <done>charge_stored_card and quick_topup_web methods handle off-session payments, return helpful errors when card missing</done>
</task>

<task type="auto">
  <name>Task 2: Add BUY command to SMS command parser</name>
  <files>backend/app/services/commands.py</files>
  <action>
Add BUY command handler for SMS top-ups (PAY-08).

1. **Add CommandType.BUY to enum:**

```python
class CommandType(str, Enum):
    # ... existing commands ...
    BUY = "BUY"  # PAY-08: SMS top-up
```

2. **Add BUY parsing to CommandParser.parse():**

```python
# In the parse method, add handling for BUY command
# Match: "BUY $10", "BUY 10", "BUY"

if text_upper.startswith("BUY"):
    # Parse amount (default $10)
    amount_match = re.search(r'\$?(\d+)', text_upper)
    amount = int(amount_match.group(1)) if amount_match else 10

    # Only support $10 increments for now
    if amount != 10:
        return ParsedCommand(
            command_type=CommandType.BUY,
            raw_input=raw_text,
            args={"amount": amount},
            is_valid=False,
            error_message="Top-up amount must be $10. Text BUY $10 to add credits."
        )

    return ParsedCommand(
        command_type=CommandType.BUY,
        raw_input=raw_text,
        args={"amount": 10, "amount_cents": 1000},
        is_valid=True
    )
```

3. **Add BUY handler in main.py or webhook.py command processing:**

```python
async def handle_buy_command(phone: str, parsed: ParsedCommand) -> str:
    """
    Handle BUY $10 SMS command.

    PAY-08: User can top up via SMS command.

    1. Find account by phone
    2. Check for stored card
    3. Charge stored card
    4. Return success/failure message
    """
    from app.models.account import account_store
    from app.services.payments import get_payment_service

    # Find account
    account = account_store.get_by_phone(phone)
    if not account:
        return "No account found. Register at thunderbird.app to use SMS top-up."

    if not account.stripe_customer_id:
        return "No payment method on file. Add a card at thunderbird.app/account"

    # Charge stored card
    payment_service = get_payment_service()
    result = await payment_service.charge_stored_card(
        account_id=account.id,
        amount_cents=parsed.args.get("amount_cents", 1000),
        description="SMS top-up"
    )

    if result.success:
        # Balance will be updated via webhook
        # But give immediate feedback
        from app.services.balance import get_balance_service
        balance_service = get_balance_service()
        balance = balance_service.get_balance(account.id)
        return f"Top-up processing! $10 will be added shortly. Current balance: ${balance/100:.2f}"
    else:
        return f"Top-up failed: {result.error}"
```

4. **Wire up in command processing (webhook.py inbound handler):**

```python
elif parsed.command_type == CommandType.BUY:
    response_text = await handle_buy_command(phone, parsed)
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.commands import CommandParser, CommandType

parser = CommandParser()

# Test BUY parsing
result = parser.parse('BUY \$10')
print(f'BUY \$10: type={result.command_type}, valid={result.is_valid}, args={result.args}')
assert result.command_type == CommandType.BUY
assert result.is_valid
assert result.args.get('amount_cents') == 1000

# Test invalid amount
result2 = parser.parse('BUY \$20')
print(f'BUY \$20: valid={result2.is_valid}, error={result2.error_message}')
assert not result2.is_valid

# Test default amount
result3 = parser.parse('BUY')
print(f'BUY (no amount): valid={result3.is_valid}, amount={result3.args.get(\"amount\")}')

print('BUY command parsing works')
"
```
  </verify>
  <done>BUY command parses correctly, validates $10 amount, returns helpful error for other amounts</done>
</task>

<task type="auto">
  <name>Task 3: Implement low balance warning</name>
  <files>backend/app/services/balance.py</files>
  <action>
Add low balance check and warning (PAY-09).

1. **Add constants and warning method to balance.py:**

```python
from datetime import datetime, timedelta
from typing import Optional
import logging

from app.services.sms import get_sms_service
from config.sms_pricing import get_segments_per_topup, get_country_from_phone

logger = logging.getLogger(__name__)

LOW_BALANCE_THRESHOLD_CENTS = 200  # $2.00
WARNING_COOLDOWN_HOURS = 24  # Don't warn more than once per day

# Track last warning time per account (in production, store in DB)
_last_warnings: dict[int, datetime] = {}


class BalanceService:
    # ... existing methods ...

    async def check_and_warn_low_balance(
        self,
        account_id: int,
        phone: str,
        country_code: str = "US"
    ) -> bool:
        """
        Check if balance is low and send warning SMS if needed.

        PAY-09: User receives low balance warning SMS at $2 remaining.

        Args:
            account_id: Account to check
            phone: Phone number for SMS warning
            country_code: Country for segment estimate

        Returns:
            True if warning was sent
        """
        balance_cents = self.get_balance(account_id)

        if balance_cents > LOW_BALANCE_THRESHOLD_CENTS:
            return False  # Balance OK

        # Check cooldown
        last_warning = _last_warnings.get(account_id)
        if last_warning:
            time_since = datetime.utcnow() - last_warning
            if time_since < timedelta(hours=WARNING_COOLDOWN_HOURS):
                logger.debug(f"Skipping low balance warning (cooldown): {account_id}")
                return False

        # Calculate remaining segments
        segments_per_10 = get_segments_per_topup(country_code)
        segments_remaining = int((balance_cents / 1000) * segments_per_10)

        # Send warning SMS
        sms_service = get_sms_service()
        message = (
            f"Low balance: ${balance_cents/100:.2f} (~{segments_remaining} texts). "
            f"Top up: BUY $10 or thunderbird.app/topup"
        )

        try:
            await sms_service.send_message(phone, message)
            _last_warnings[account_id] = datetime.utcnow()
            logger.info(f"Low balance warning sent: {account_id}")
            return True
        except Exception as e:
            logger.error(f"Failed to send low balance warning: {e}")
            return False

    def is_low_balance(self, account_id: int) -> bool:
        """Check if account has low balance (< $2)."""
        return self.get_balance(account_id) <= LOW_BALANCE_THRESHOLD_CENTS
```

2. **Call check_and_warn_low_balance after SMS deduction:**

In the code that deducts balance for SMS sending (likely in sms.py or the main SMS handler), add a call to check and warn:

```python
# After deducting for sent SMS:
balance_result = balance_service.deduct(account_id, sms_cost_cents, f"SMS to {phone}")

# Check if balance is now low
if balance_result.success:
    await balance_service.check_and_warn_low_balance(
        account_id=account_id,
        phone=user_phone,
        country_code=country_code
    )
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.balance import get_balance_service, LOW_BALANCE_THRESHOLD_CENTS

svc = get_balance_service()

# Verify threshold
print(f'Low balance threshold: {LOW_BALANCE_THRESHOLD_CENTS} cents (\${LOW_BALANCE_THRESHOLD_CENTS/100:.2f})')
assert LOW_BALANCE_THRESHOLD_CENTS == 200, 'Threshold should be \$2.00'

# Verify method exists
assert hasattr(svc, 'check_and_warn_low_balance')
assert hasattr(svc, 'is_low_balance')

print('Low balance warning system configured')
"
```
  </verify>
  <done>Low balance check triggers at $2, sends SMS warning with top-up instructions, respects 24h cooldown</done>
</task>

</tasks>

<verification>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# 1. Stored card charging
python -c "
from app.services.payments import get_payment_service
svc = get_payment_service()
assert hasattr(svc, 'charge_stored_card')
assert hasattr(svc, 'quick_topup_web')
print('Stored card methods exist')
"

# 2. BUY command parsing
python -c "
from app.services.commands import CommandParser, CommandType
parser = CommandParser()
result = parser.parse('BUY \$10')
assert result.command_type == CommandType.BUY
assert result.is_valid
print('BUY command parses correctly')
"

# 3. Low balance warning
python -c "
from app.services.balance import get_balance_service, LOW_BALANCE_THRESHOLD_CENTS
svc = get_balance_service()
assert LOW_BALANCE_THRESHOLD_CENTS == 200
assert hasattr(svc, 'check_and_warn_low_balance')
print('Low balance warning configured')
"

# 4. All tests pass
pytest tests/ -x -q --tb=short
```
</verification>

<success_criteria>
- charge_stored_card uses PaymentIntent API with saved card
- BUY command validates $10 amount, returns helpful error otherwise
- BUY command finds account by phone, charges stored card
- Low balance warning triggers at $2 (200 cents)
- Warning SMS includes balance, estimated texts, and top-up instructions
- Warning has 24h cooldown to prevent spam
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-payments/02-05-SUMMARY.md`
</output>
