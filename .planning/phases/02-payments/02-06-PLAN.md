---
phase: 02-payments
plan: 06
type: execute
wave: 4
depends_on: ["02-01", "02-05"]
files_modified:
  - backend/app/services/cost_verification.py
  - backend/scripts/verify_sms_costs.py
  - backend/tests/test_sms_pricing.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "System can fetch current Twilio rates via API"
    - "Verification compares stored rates to Twilio actuals"
    - "Alert raised if margin drops below 80%"
    - "Verification can run as scheduled job or manual script"
  artifacts:
    - path: "backend/app/services/cost_verification.py"
      provides: "SMS cost verification service"
      exports: ["CostVerificationService", "verify_all_countries"]
    - path: "backend/scripts/verify_sms_costs.py"
      provides: "Manual verification script"
      contains: "if __name__"
    - path: "backend/tests/test_sms_pricing.py"
      provides: "SMS pricing tests"
      contains: "test_margin_calculation"
  key_links:
    - from: "backend/app/services/cost_verification.py"
      to: "backend/config/sms_pricing.py"
      via: "compares SMS_COSTS_BY_COUNTRY to Twilio API"
      pattern: "SMS_COSTS_BY_COUNTRY"
---

<objective>
Implement SMS cost verification against Twilio pricing API.

Purpose: Complete PAY-12 - SMS cost verification function that reconciles stored rates against Twilio actuals. This protects margins by alerting when Twilio rates change.

Output: Cost verification service that can be run manually or scheduled, alerts when stored rates diverge from Twilio or when margin drops below 80%.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-payments/02-RESEARCH.md

# SMS pricing config to verify
@backend/config/sms_pricing.py

# Existing Twilio integration
@backend/app/services/sms.py
@backend/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cost verification service</name>
  <files>backend/app/services/cost_verification.py</files>
  <action>
Create service to verify SMS costs against Twilio Pricing API (PAY-12).

```python
"""
SMS cost verification service.
Compares stored rates to Twilio Pricing API to maintain 80% margin.

PAY-12: SMS cost verification function reconciles against Twilio actuals.
"""
import logging
from dataclasses import dataclass
from typing import Optional, List
from decimal import Decimal
import httpx

from config.settings import settings
from config.sms_pricing import SMS_COSTS_BY_COUNTRY, MARGIN_PERCENT, CountrySMSCost

logger = logging.getLogger(__name__)

TWILIO_PRICING_API = "https://pricing.twilio.com/v2/Voice/Countries"
# Note: Twilio Pricing API for SMS is at /v1/Messaging/Countries/{iso}
TWILIO_SMS_PRICING_API = "https://pricing.twilio.com/v1/Messaging/Countries"

TARGET_MARGIN = Decimal("0.80")  # 80%
MARGIN_ALERT_THRESHOLD = Decimal("0.75")  # Alert if margin drops below 75%
RATE_DRIFT_THRESHOLD = Decimal("0.10")  # Alert if rate differs by >10%


@dataclass
class RateComparison:
    """Result of comparing stored rate to Twilio rate."""
    country_code: str
    country_name: str
    stored_twilio_rate_cents: int
    actual_twilio_rate_cents: Optional[int]
    stored_customer_rate_cents: int
    calculated_margin: Decimal
    is_margin_ok: bool
    rate_drift_percent: Optional[Decimal]
    is_rate_drifted: bool
    error: Optional[str] = None


@dataclass
class VerificationReport:
    """Full verification report for all countries."""
    timestamp: str
    countries_checked: int
    countries_ok: int
    countries_with_issues: int
    margin_alerts: List[str]
    rate_drift_alerts: List[str]
    api_errors: List[str]
    details: List[RateComparison]


class CostVerificationService:
    """
    Verifies SMS costs against Twilio Pricing API.

    Twilio Pricing API requires authentication and returns current rates.
    We compare to our stored rates in SMS_COSTS_BY_COUNTRY.
    """

    def __init__(self):
        self.account_sid = settings.TWILIO_ACCOUNT_SID
        self.auth_token = settings.TWILIO_AUTH_TOKEN

    def is_configured(self) -> bool:
        """Check if Twilio credentials available."""
        return bool(self.account_sid and self.auth_token)

    async def fetch_twilio_rate(self, country_code: str) -> Optional[Decimal]:
        """
        Fetch current SMS rate from Twilio Pricing API.

        Args:
            country_code: ISO 2-letter country code (e.g., "US", "GB")

        Returns:
            Rate per segment in dollars, or None on error
        """
        if not self.is_configured():
            logger.warning("Twilio not configured for pricing API")
            return None

        url = f"{TWILIO_SMS_PRICING_API}/{country_code}"

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    url,
                    auth=(self.account_sid, self.auth_token),
                    timeout=30.0
                )

                if response.status_code == 200:
                    data = response.json()
                    # Twilio returns outbound_sms_prices array
                    # We want the price for mobile carrier (most common)
                    prices = data.get("outbound_sms_prices", [])
                    if prices:
                        # Find mobile carrier price or use first
                        for price in prices:
                            if "mobile" in price.get("carrier", "").lower():
                                return Decimal(price["current_price"])
                        # Fallback to first price
                        return Decimal(prices[0]["current_price"])
                    return None
                elif response.status_code == 404:
                    logger.warning(f"Country not found in Twilio: {country_code}")
                    return None
                else:
                    logger.error(f"Twilio API error: {response.status_code}")
                    return None

        except Exception as e:
            logger.error(f"Failed to fetch Twilio rate for {country_code}: {e}")
            return None

    def calculate_margin(
        self,
        twilio_cost_cents: int,
        customer_cost_cents: int
    ) -> Decimal:
        """
        Calculate actual margin.

        Margin = (customer_pays - twilio_cost) / customer_pays
        80% margin means customer pays 5x what Twilio charges.

        Args:
            twilio_cost_cents: What Twilio charges us
            customer_cost_cents: What customer pays

        Returns:
            Margin as decimal (0.80 = 80%)
        """
        if customer_cost_cents == 0:
            return Decimal("0")

        profit = customer_cost_cents - twilio_cost_cents
        return Decimal(profit) / Decimal(customer_cost_cents)

    async def verify_country(self, country_code: str) -> RateComparison:
        """
        Verify single country's SMS pricing.

        Args:
            country_code: ISO country code

        Returns:
            RateComparison with status
        """
        stored = SMS_COSTS_BY_COUNTRY.get(country_code)
        if not stored:
            return RateComparison(
                country_code=country_code,
                country_name="Unknown",
                stored_twilio_rate_cents=0,
                actual_twilio_rate_cents=None,
                stored_customer_rate_cents=0,
                calculated_margin=Decimal("0"),
                is_margin_ok=False,
                rate_drift_percent=None,
                is_rate_drifted=False,
                error=f"Country {country_code} not in configuration"
            )

        # Fetch actual Twilio rate
        actual_rate = await self.fetch_twilio_rate(country_code)
        actual_cents = int(actual_rate * 100) if actual_rate else None

        # Calculate margin based on stored rates
        margin = self.calculate_margin(
            stored.twilio_cost_per_segment_cents,
            stored.customer_cost_per_segment_cents
        )

        # Calculate rate drift
        rate_drift = None
        is_drifted = False
        if actual_cents is not None:
            if stored.twilio_cost_per_segment_cents > 0:
                drift = abs(actual_cents - stored.twilio_cost_per_segment_cents)
                rate_drift = Decimal(drift) / Decimal(stored.twilio_cost_per_segment_cents)
                is_drifted = rate_drift > RATE_DRIFT_THRESHOLD

        return RateComparison(
            country_code=country_code,
            country_name=stored.country_name,
            stored_twilio_rate_cents=stored.twilio_cost_per_segment_cents,
            actual_twilio_rate_cents=actual_cents,
            stored_customer_rate_cents=stored.customer_cost_per_segment_cents,
            calculated_margin=margin,
            is_margin_ok=margin >= MARGIN_ALERT_THRESHOLD,
            rate_drift_percent=rate_drift,
            is_rate_drifted=is_drifted,
            error=None if actual_cents is not None else "Could not fetch Twilio rate"
        )

    async def verify_all_countries(self) -> VerificationReport:
        """
        Verify all configured countries.

        Returns:
            VerificationReport with all comparisons and alerts
        """
        from datetime import datetime

        details = []
        margin_alerts = []
        drift_alerts = []
        api_errors = []
        ok_count = 0

        for country_code in SMS_COSTS_BY_COUNTRY.keys():
            result = await self.verify_country(country_code)
            details.append(result)

            if result.error:
                api_errors.append(f"{country_code}: {result.error}")
            elif result.is_rate_drifted:
                drift_alerts.append(
                    f"{country_code} ({result.country_name}): "
                    f"stored={result.stored_twilio_rate_cents}c, "
                    f"actual={result.actual_twilio_rate_cents}c, "
                    f"drift={result.rate_drift_percent:.1%}"
                )
            elif not result.is_margin_ok:
                margin_alerts.append(
                    f"{country_code} ({result.country_name}): "
                    f"margin={result.calculated_margin:.1%} (target: 80%)"
                )
            else:
                ok_count += 1

        issues = len(margin_alerts) + len(drift_alerts) + len(api_errors)

        return VerificationReport(
            timestamp=datetime.utcnow().isoformat(),
            countries_checked=len(SMS_COSTS_BY_COUNTRY),
            countries_ok=ok_count,
            countries_with_issues=issues,
            margin_alerts=margin_alerts,
            rate_drift_alerts=drift_alerts,
            api_errors=api_errors,
            details=details
        )


# Singleton
_verification_service: Optional[CostVerificationService] = None


def get_verification_service() -> CostVerificationService:
    """Get singleton verification service."""
    global _verification_service
    if _verification_service is None:
        _verification_service = CostVerificationService()
    return _verification_service


async def verify_all_countries() -> VerificationReport:
    """Convenience function for verification."""
    service = get_verification_service()
    return await service.verify_all_countries()
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.services.cost_verification import (
    CostVerificationService,
    get_verification_service,
    TARGET_MARGIN,
    MARGIN_ALERT_THRESHOLD
)

svc = get_verification_service()
print(f'Verification service configured: {svc.is_configured()}')
print(f'Target margin: {TARGET_MARGIN} ({TARGET_MARGIN*100}%)')
print(f'Alert threshold: {MARGIN_ALERT_THRESHOLD} ({MARGIN_ALERT_THRESHOLD*100}%)')

# Test margin calculation
from decimal import Decimal
margin = svc.calculate_margin(twilio_cost_cents=1, customer_cost_cents=5)
print(f'Margin test (1 cost, 5 charge): {margin} (expect 0.8)')
assert margin == Decimal('0.8'), f'Expected 0.8, got {margin}'

print('Cost verification service initialized')
"
```
  </verify>
  <done>Cost verification service can compare stored rates to Twilio API, calculates margin correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create manual verification script</name>
  <files>backend/scripts/verify_sms_costs.py</files>
  <action>
Create standalone script for manual cost verification.

```python
#!/usr/bin/env python3
"""
SMS Cost Verification Script.

Compares stored SMS rates against Twilio Pricing API.
Run manually or via cron to detect rate changes.

Usage:
    python scripts/verify_sms_costs.py
    python scripts/verify_sms_costs.py --json  # Output as JSON
    python scripts/verify_sms_costs.py --alert-only  # Only show alerts
"""
import asyncio
import argparse
import json
import sys
from pathlib import Path

# Add backend to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from app.services.cost_verification import verify_all_countries, VerificationReport


def format_report(report: VerificationReport, alert_only: bool = False) -> str:
    """Format verification report for display."""
    lines = []

    lines.append("=" * 60)
    lines.append("SMS COST VERIFICATION REPORT")
    lines.append(f"Timestamp: {report.timestamp}")
    lines.append("=" * 60)
    lines.append("")

    lines.append(f"Countries checked: {report.countries_checked}")
    lines.append(f"Countries OK: {report.countries_ok}")
    lines.append(f"Countries with issues: {report.countries_with_issues}")
    lines.append("")

    # Alerts
    if report.margin_alerts:
        lines.append("MARGIN ALERTS (below 75%):")
        for alert in report.margin_alerts:
            lines.append(f"  ! {alert}")
        lines.append("")

    if report.rate_drift_alerts:
        lines.append("RATE DRIFT ALERTS (>10% change):")
        for alert in report.rate_drift_alerts:
            lines.append(f"  ! {alert}")
        lines.append("")

    if report.api_errors:
        lines.append("API ERRORS:")
        for error in report.api_errors:
            lines.append(f"  ? {error}")
        lines.append("")

    # Details (skip if alert_only)
    if not alert_only:
        lines.append("-" * 60)
        lines.append("DETAILS BY COUNTRY:")
        lines.append("-" * 60)

        for detail in report.details:
            status = "OK" if detail.is_margin_ok and not detail.is_rate_drifted else "!!"
            lines.append(f"[{status}] {detail.country_code} ({detail.country_name})")
            lines.append(f"    Stored Twilio rate: {detail.stored_twilio_rate_cents}c")
            if detail.actual_twilio_rate_cents:
                lines.append(f"    Actual Twilio rate: {detail.actual_twilio_rate_cents}c")
            lines.append(f"    Customer rate: {detail.stored_customer_rate_cents}c")
            lines.append(f"    Margin: {detail.calculated_margin:.1%}")
            if detail.rate_drift_percent:
                lines.append(f"    Rate drift: {detail.rate_drift_percent:.1%}")
            if detail.error:
                lines.append(f"    Error: {detail.error}")
            lines.append("")

    # Summary
    lines.append("=" * 60)
    if report.countries_with_issues == 0:
        lines.append("STATUS: ALL OK")
    else:
        lines.append(f"STATUS: {report.countries_with_issues} ISSUE(S) FOUND")
    lines.append("=" * 60)

    return "\n".join(lines)


def report_to_dict(report: VerificationReport) -> dict:
    """Convert report to JSON-serializable dict."""
    return {
        "timestamp": report.timestamp,
        "countries_checked": report.countries_checked,
        "countries_ok": report.countries_ok,
        "countries_with_issues": report.countries_with_issues,
        "margin_alerts": report.margin_alerts,
        "rate_drift_alerts": report.rate_drift_alerts,
        "api_errors": report.api_errors,
        "details": [
            {
                "country_code": d.country_code,
                "country_name": d.country_name,
                "stored_twilio_rate_cents": d.stored_twilio_rate_cents,
                "actual_twilio_rate_cents": d.actual_twilio_rate_cents,
                "stored_customer_rate_cents": d.stored_customer_rate_cents,
                "calculated_margin": str(d.calculated_margin),
                "is_margin_ok": d.is_margin_ok,
                "rate_drift_percent": str(d.rate_drift_percent) if d.rate_drift_percent else None,
                "is_rate_drifted": d.is_rate_drifted,
                "error": d.error,
            }
            for d in report.details
        ]
    }


async def main():
    parser = argparse.ArgumentParser(description="Verify SMS costs against Twilio")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--alert-only", action="store_true", help="Only show alerts")
    args = parser.parse_args()

    print("Fetching Twilio rates...", file=sys.stderr)
    report = await verify_all_countries()

    if args.json:
        print(json.dumps(report_to_dict(report), indent=2))
    else:
        print(format_report(report, alert_only=args.alert_only))

    # Exit with error code if issues found
    sys.exit(1 if report.countries_with_issues > 0 else 0)


if __name__ == "__main__":
    asyncio.run(main())
```

Make executable:
```bash
chmod +x backend/scripts/verify_sms_costs.py
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Check script exists and is valid Python
python -m py_compile scripts/verify_sms_costs.py && echo "Script compiles OK"

# Check it can be imported (won't run due to __main__ guard)
python -c "import scripts.verify_sms_costs; print('Script imports OK')" 2>/dev/null || echo "Import test skipped"

# Show help
python scripts/verify_sms_costs.py --help 2>/dev/null || echo "Help: --json, --alert-only"
```
  </verify>
  <done>Verification script runs standalone, supports --json and --alert-only flags, exits with error code on issues</done>
</task>

<task type="auto">
  <name>Task 3: Create SMS pricing tests</name>
  <files>backend/tests/test_sms_pricing.py</files>
  <action>
Create comprehensive tests for SMS pricing and cost verification.

```python
"""
Tests for SMS pricing configuration and cost verification.
"""
import pytest
from decimal import Decimal

from config.sms_pricing import (
    SMS_COSTS_BY_COUNTRY,
    get_sms_cost,
    get_segments_per_topup,
    get_country_from_phone,
    MARGIN_PERCENT
)
from app.services.cost_verification import (
    CostVerificationService,
    TARGET_MARGIN,
    MARGIN_ALERT_THRESHOLD,
)


class TestSMSPricingConfig:
    """Test SMS pricing configuration."""

    def test_all_countries_configured(self):
        """All 8 required countries are configured."""
        required = {"US", "CA", "GB", "FR", "IT", "CH", "NZ", "ZA"}
        configured = set(SMS_COSTS_BY_COUNTRY.keys())
        missing = required - configured
        assert not missing, f"Missing countries: {missing}"

    def test_margin_is_80_percent(self):
        """Margin constant is 80%."""
        assert MARGIN_PERCENT == 80

    def test_us_pricing_correct(self):
        """US pricing matches research values."""
        us = get_sms_cost("US")
        # Research: $0.0113 Twilio, $0.0566 customer (ish)
        assert us.twilio_cost_per_segment_cents > 0
        assert us.customer_cost_per_segment_cents > us.twilio_cost_per_segment_cents
        # Should be ~5x Twilio cost for 80% margin
        ratio = us.customer_cost_per_segment_cents / us.twilio_cost_per_segment_cents
        assert 4.5 <= ratio <= 5.5, f"US ratio should be ~5x, got {ratio}"

    def test_gb_pricing_correct(self):
        """UK pricing matches research values."""
        gb = get_sms_cost("GB")
        # Research: $0.0524 Twilio
        assert gb.twilio_cost_per_segment_cents > 0
        # UK should be more expensive than US
        us = get_sms_cost("US")
        assert gb.twilio_cost_per_segment_cents > us.twilio_cost_per_segment_cents

    def test_segments_per_10_dollars(self):
        """Segments per $10 calculated correctly."""
        us_segments = get_segments_per_topup("US")
        gb_segments = get_segments_per_topup("GB")

        # US should get more segments (cheaper)
        assert us_segments > gb_segments
        # US should be around 176 per research
        assert 150 <= us_segments <= 200
        # GB should be around 38 per research
        assert 30 <= gb_segments <= 50

    def test_unknown_country_defaults_to_us(self):
        """Unknown country codes default to US rates."""
        unknown = get_sms_cost("XX")
        us = get_sms_cost("US")
        assert unknown.customer_cost_per_segment_cents == us.customer_cost_per_segment_cents

    @pytest.mark.parametrize("phone,expected", [
        ("+14155551234", "US"),
        ("+447700900123", "GB"),
        ("+33612345678", "FR"),
        ("+61412345678", "AU"),  # Australia not configured, should handle
    ])
    def test_country_from_phone(self, phone, expected):
        """Phone number parsing extracts country correctly."""
        result = get_country_from_phone(phone)
        assert result == expected


class TestMarginCalculations:
    """Test margin calculation logic."""

    def test_80_percent_margin(self):
        """80% margin when customer pays 5x Twilio cost."""
        svc = CostVerificationService()
        # If Twilio charges 1, we charge 5, profit is 4, margin is 4/5 = 80%
        margin = svc.calculate_margin(twilio_cost_cents=1, customer_cost_cents=5)
        assert margin == Decimal("0.8")

    def test_all_countries_maintain_80_margin(self):
        """All configured countries maintain ~80% margin."""
        svc = CostVerificationService()

        for country_code, cost in SMS_COSTS_BY_COUNTRY.items():
            margin = svc.calculate_margin(
                cost.twilio_cost_per_segment_cents,
                cost.customer_cost_per_segment_cents
            )
            assert margin >= Decimal("0.79"), f"{country_code} margin too low: {margin}"
            assert margin <= Decimal("0.81"), f"{country_code} margin too high: {margin}"

    def test_margin_alert_threshold(self):
        """Alert threshold is below target margin."""
        assert MARGIN_ALERT_THRESHOLD < TARGET_MARGIN
        assert MARGIN_ALERT_THRESHOLD >= Decimal("0.70")


class TestCostVerificationService:
    """Test cost verification service."""

    def test_service_instantiates(self):
        """Service can be instantiated."""
        svc = CostVerificationService()
        assert svc is not None

    def test_handles_missing_credentials(self):
        """Service handles missing Twilio credentials."""
        svc = CostVerificationService()
        # Without credentials, fetch should return None gracefully
        # (actual test depends on env vars)

    @pytest.mark.asyncio
    async def test_verify_country_handles_unknown(self):
        """Verify handles unknown country codes."""
        svc = CostVerificationService()
        result = await svc.verify_country("XX")
        assert result.error is not None
        assert "not in configuration" in result.error
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Run SMS pricing tests
pytest tests/test_sms_pricing.py -v --tb=short

# Run all tests
pytest tests/ -x -q --tb=short
```
  </verify>
  <done>SMS pricing tests verify 8 countries configured, 80% margin maintained, phone parsing works</done>
</task>

</tasks>

<verification>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# 1. Cost verification service works
python -c "
from app.services.cost_verification import get_verification_service
svc = get_verification_service()
print(f'Configured: {svc.is_configured()}')
"

# 2. Script exists and compiles
python -m py_compile scripts/verify_sms_costs.py && echo "Script OK"

# 3. All countries maintain 80% margin
python -c "
from config.sms_pricing import SMS_COSTS_BY_COUNTRY
from app.services.cost_verification import CostVerificationService
from decimal import Decimal

svc = CostVerificationService()
for cc, cost in SMS_COSTS_BY_COUNTRY.items():
    margin = svc.calculate_margin(
        cost.twilio_cost_per_segment_cents,
        cost.customer_cost_per_segment_cents
    )
    assert margin >= Decimal('0.79'), f'{cc} margin too low'
print('All countries maintain 80% margin')
"

# 4. SMS pricing tests pass
pytest tests/test_sms_pricing.py -v --tb=short

# 5. All tests pass
pytest tests/ -x -q --tb=short
```
</verification>

<success_criteria>
- Cost verification service fetches rates from Twilio Pricing API
- Margin calculation correct (80% = customer pays 5x Twilio cost)
- Alert triggers when margin drops below 75%
- Alert triggers when rate drifts more than 10%
- Manual verification script runs with --json and --alert-only options
- Script exits with error code when issues found (for CI/cron)
- All 8 countries verified to maintain 80% margin
- All SMS pricing tests pass
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-payments/02-06-SUMMARY.md`
</output>
