---
phase: 02-payments
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - backend/app/services/email.py
  - backend/app/routers/webhook.py
autonomous: true
user_setup:
  - service: sendgrid
    why: "Order confirmation emails with SMS number"
    env_vars:
      - name: SENDGRID_API_KEY
        source: "SendGrid Dashboard -> Settings -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Create dynamic email template for order confirmation"
        location: "SendGrid Dashboard -> Email API -> Dynamic Templates"
        details: "Template should include: sms_number, amount_paid, segments, quick_start_url"

must_haves:
  truths:
    - "User receives email after successful payment"
    - "Email contains assigned SMS number"
    - "Email contains quick start link"
    - "Email send failures are logged but don't break payment flow"
  artifacts:
    - path: "backend/app/services/email.py"
      provides: "SendGrid email service"
      exports: ["EmailService", "get_email_service", "send_order_confirmation"]
  key_links:
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/email.py"
      via: "send_order_confirmation called on checkout complete"
      pattern: "send_order_confirmation"
---

<objective>
Implement order confirmation email service using SendGrid.

Purpose: Complete PAY-05 - user receives order confirmation email with SMS number and quick start guide link. Email is triggered from webhook after successful payment.

Output: SendGrid email service with dynamic template support, integrated into webhook flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-payments/02-RESEARCH.md

# Webhook handler to integrate with
@backend/app/routers/webhook.py

# Account model for email lookup
@backend/app/models/account.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SendGrid email service</name>
  <files>backend/app/services/email.py</files>
  <action>
Create email service following patterns from research (02-RESEARCH.md "Order Confirmation Email").

1. **Add to settings.py:**
```python
# SendGrid configuration
SENDGRID_API_KEY: str = ""
SENDGRID_FROM_EMAIL: str = "noreply@thunderbird.app"
SENDGRID_WELCOME_TEMPLATE_ID: str = ""  # Dynamic template ID
BASE_URL: str = "https://thunderbird.app"  # For quick start link
```

2. **Create email.py:**

```python
"""
Email service using SendGrid.
Handles PAY-05 (order confirmation with SMS number and quick start).
"""
import logging
from typing import Optional
from dataclasses import dataclass

from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail, Email, To, Content, DynamicTemplateData

from config.settings import settings

logger = logging.getLogger(__name__)

@dataclass
class EmailResult:
    """Result of email send operation."""
    success: bool
    status_code: Optional[int] = None
    error: Optional[str] = None

class EmailService:
    """
    SendGrid email service.

    Handles transactional emails with dynamic templates.
    Fails gracefully - email errors don't break payment flow.
    """

    def __init__(self):
        self.api_key = settings.SENDGRID_API_KEY
        self.from_email = settings.SENDGRID_FROM_EMAIL
        self.client = None
        if self.api_key:
            self.client = SendGridAPIClient(self.api_key)

    def is_configured(self) -> bool:
        """Check if SendGrid is properly configured."""
        return bool(self.api_key and self.client)

    async def send_order_confirmation(
        self,
        to_email: str,
        sms_number: str,
        amount_paid_cents: int,
        segments_received: int
    ) -> EmailResult:
        """
        Send order confirmation email.

        PAY-05: Email contains SMS number and quick start guide.

        Args:
            to_email: Customer email address
            sms_number: Assigned Thunderbird SMS number
            amount_paid_cents: Amount charged
            segments_received: Estimated segments purchased

        Returns:
            EmailResult with success status
        """
        if not self.is_configured():
            logger.warning("SendGrid not configured, skipping email")
            return EmailResult(success=False, error="Email service not configured")

        try:
            message = Mail(
                from_email=Email(self.from_email, "Thunderbird"),
                to_emails=To(to_email),
            )

            # Use dynamic template if configured
            if settings.SENDGRID_WELCOME_TEMPLATE_ID:
                message.template_id = settings.SENDGRID_WELCOME_TEMPLATE_ID
                message.dynamic_template_data = DynamicTemplateData({
                    "sms_number": sms_number,
                    "amount_paid": f"${amount_paid_cents / 100:.2f}",
                    "segments": segments_received,
                    "quick_start_url": f"{settings.BASE_URL}/quickstart",
                    "account_url": f"{settings.BASE_URL}/account",
                })
            else:
                # Fallback to plain text if no template
                message.subject = "Welcome to Thunderbird - Your SMS Number"
                message.content = [Content(
                    "text/plain",
                    f"""Welcome to Thunderbird!

Your SMS number: {sms_number}

You paid: ${amount_paid_cents / 100:.2f}
Estimated messages: ~{segments_received} texts

Quick Start Guide: {settings.BASE_URL}/quickstart

To check your balance or top up:
{settings.BASE_URL}/account

Happy hiking!
The Thunderbird Team
"""
                )]

            response = self.client.send(message)

            if response.status_code in (200, 202):
                logger.info(f"Order confirmation sent to {to_email}")
                return EmailResult(success=True, status_code=response.status_code)
            else:
                logger.error(f"Email send failed: {response.status_code}")
                return EmailResult(
                    success=False,
                    status_code=response.status_code,
                    error=f"SendGrid returned {response.status_code}"
                )

        except Exception as e:
            logger.error(f"Email send error: {e}")
            return EmailResult(success=False, error=str(e))

    async def send_low_balance_warning(
        self,
        to_email: str,
        balance_cents: int,
        segments_remaining: int
    ) -> EmailResult:
        """
        Send low balance warning email.

        PAY-09: Warning at $2 remaining (also sent via SMS).

        Args:
            to_email: Customer email
            balance_cents: Current balance
            segments_remaining: Estimated texts remaining
        """
        if not self.is_configured():
            return EmailResult(success=False, error="Not configured")

        try:
            message = Mail(
                from_email=Email(self.from_email, "Thunderbird"),
                to_emails=To(to_email),
                subject="Low Balance Warning - Thunderbird",
            )
            message.content = [Content(
                "text/plain",
                f"""Your Thunderbird balance is low.

Current balance: ${balance_cents / 100:.2f}
Estimated remaining: ~{segments_remaining} texts

Top up now to avoid interruption:
{settings.BASE_URL}/account

Or text: BUY $10

The Thunderbird Team
"""
            )]

            response = self.client.send(message)
            return EmailResult(
                success=response.status_code in (200, 202),
                status_code=response.status_code
            )

        except Exception as e:
            logger.error(f"Low balance email error: {e}")
            return EmailResult(success=False, error=str(e))


# Singleton
_email_service: Optional[EmailService] = None

def get_email_service() -> EmailService:
    """Get singleton email service."""
    global _email_service
    if _email_service is None:
        _email_service = EmailService()
    return _email_service


async def send_order_confirmation(
    to_email: str,
    sms_number: str,
    amount_paid_cents: int,
    segments_received: int
) -> EmailResult:
    """Convenience function for sending order confirmation."""
    service = get_email_service()
    return await service.send_order_confirmation(
        to_email, sms_number, amount_paid_cents, segments_received
    )
```

3. **Add sendgrid to requirements.txt:**
```
sendgrid>=6.11.0
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Install sendgrid if not present
pip install sendgrid >/dev/null 2>&1

# Test imports
python -c "
from app.services.email import get_email_service, send_order_confirmation, EmailResult

svc = get_email_service()
print(f'Email service configured: {svc.is_configured()}')

# Should handle missing config gracefully
import asyncio
result = asyncio.run(svc.send_order_confirmation(
    'test@test.com', '+1234567890', 2999, 176
))
print(f'Without config: success={result.success}, error={result.error}')
assert not result.success  # Should fail gracefully
assert 'not configured' in result.error.lower()
print('Email service handles missing config gracefully')
"
```
  </verify>
  <done>Email service sends order confirmation with SMS number and quick start link, handles missing config gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Integrate email into webhook flow</name>
  <files>backend/app/routers/webhook.py</files>
  <action>
Update webhook handler to send confirmation email after successful payment.

1. **Update handle_checkout_completed in webhook.py:**

```python
from app.services.email import send_order_confirmation
from config.settings import settings  # For TWILIO_PHONE_NUMBER as SMS number

async def handle_checkout_completed(session):
    """
    Handle successful checkout session.

    1. Update order status to completed
    2. Save Stripe customer ID to account
    3. Add credits to balance
    4. Send confirmation email (PAY-05) - NEW
    """
    account_id = int(session.metadata.get("account_id"))
    order_id = int(session.metadata.get("order_id"))
    purchase_type = session.metadata.get("purchase_type")
    stripe_customer_id = session.customer

    logger.info(f"Checkout completed: order={order_id}, account={account_id}")

    # 1. Update order status
    order = order_store.get_by_id(order_id)
    if not order:
        logger.error(f"Order not found: {order_id}")
        return

    if order.status == "completed":
        logger.info(f"Order already completed: {order_id}")
        return

    order_store.update_status(order_id, "completed")

    # 2. Save Stripe customer ID
    if stripe_customer_id:
        account_store.update_stripe_customer_id(account_id, stripe_customer_id)

    # 3. Add credits to balance
    balance_service = get_balance_service()
    description = "Initial purchase" if purchase_type == "initial_access" else "Top-up"
    balance_service.add_credits(
        account_id=account_id,
        amount_cents=order.amount_cents,
        description=description,
        order_id=order_id
    )

    logger.info(f"Credits added: {order.amount_cents} cents to account {account_id}")

    # 4. Send confirmation email (PAY-05)
    account = account_store.get_by_id(account_id)
    if account and account.email:
        # Get SMS number (the Twilio number users text)
        sms_number = settings.TWILIO_PHONE_NUMBER or "+1234567890"

        # Estimate segments based on country (default to US)
        from config.sms_pricing import get_segments_per_topup, get_country_from_phone
        country = get_country_from_phone(account.phone) if account.phone else "US"
        # For initial purchase, estimate based on $30 worth
        segments = int((order.amount_cents / 1000) * get_segments_per_topup(country))

        email_result = await send_order_confirmation(
            to_email=account.email,
            sms_number=sms_number,
            amount_paid_cents=order.amount_cents,
            segments_received=segments
        )

        if email_result.success:
            logger.info(f"Confirmation email sent to {account.email}")
        else:
            # Log but don't fail - payment already succeeded
            logger.warning(f"Confirmation email failed: {email_result.error}")
```

2. **Ensure email failure doesn't break webhook:**
- Email send is wrapped in try/catch
- Failure is logged but webhook still returns success
- Payment fulfillment (balance credit) happens BEFORE email attempt
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
# Verify webhook imports email service
from app.routers.webhook import handle_checkout_completed
import inspect
source = inspect.getsource(handle_checkout_completed)
assert 'send_order_confirmation' in source, 'Email not integrated in webhook'
print('Webhook calls send_order_confirmation')

# Verify balance added before email (order matters for reliability)
balance_pos = source.find('add_credits')
email_pos = source.find('send_order_confirmation')
assert balance_pos < email_pos, 'Balance should be added before email attempt'
print('Balance credited before email (correct order)')
"
```
  </verify>
  <done>Webhook sends confirmation email after payment, email failures logged but don't break payment flow</done>
</task>

<task type="auto">
  <name>Task 3: Add email tests</name>
  <files>backend/tests/test_email.py</files>
  <action>
Create tests for email service.

```python
"""
Tests for email service.
"""
import pytest
from unittest.mock import patch, MagicMock
import asyncio

from app.services.email import EmailService, get_email_service, EmailResult


class TestEmailService:
    """Test email service functionality."""

    def test_not_configured_without_api_key(self):
        """Service reports not configured without API key."""
        with patch('app.services.email.settings') as mock_settings:
            mock_settings.SENDGRID_API_KEY = ""
            service = EmailService()
            assert not service.is_configured()

    def test_handles_missing_config_gracefully(self):
        """Send methods return error when not configured."""
        with patch('app.services.email.settings') as mock_settings:
            mock_settings.SENDGRID_API_KEY = ""
            service = EmailService()

            result = asyncio.run(service.send_order_confirmation(
                "test@test.com", "+1234567890", 2999, 100
            ))

            assert not result.success
            assert "not configured" in result.error.lower()

    @patch('app.services.email.SendGridAPIClient')
    def test_send_order_confirmation_success(self, mock_client_class):
        """Successful email send returns success result."""
        # Mock SendGrid client
        mock_client = MagicMock()
        mock_response = MagicMock()
        mock_response.status_code = 202
        mock_client.send.return_value = mock_response
        mock_client_class.return_value = mock_client

        with patch('app.services.email.settings') as mock_settings:
            mock_settings.SENDGRID_API_KEY = "test_key"
            mock_settings.SENDGRID_FROM_EMAIL = "test@test.com"
            mock_settings.SENDGRID_WELCOME_TEMPLATE_ID = ""
            mock_settings.BASE_URL = "https://test.com"

            service = EmailService()
            result = asyncio.run(service.send_order_confirmation(
                "customer@test.com", "+1234567890", 2999, 100
            ))

            assert result.success
            assert result.status_code == 202
            mock_client.send.assert_called_once()

    @patch('app.services.email.SendGridAPIClient')
    def test_send_order_confirmation_failure(self, mock_client_class):
        """Failed email send returns error result."""
        mock_client = MagicMock()
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_client.send.return_value = mock_response
        mock_client_class.return_value = mock_client

        with patch('app.services.email.settings') as mock_settings:
            mock_settings.SENDGRID_API_KEY = "test_key"
            mock_settings.SENDGRID_FROM_EMAIL = "test@test.com"
            mock_settings.SENDGRID_WELCOME_TEMPLATE_ID = ""
            mock_settings.BASE_URL = "https://test.com"

            service = EmailService()
            result = asyncio.run(service.send_order_confirmation(
                "customer@test.com", "+1234567890", 2999, 100
            ))

            assert not result.success
            assert result.status_code == 400

    @patch('app.services.email.SendGridAPIClient')
    def test_handles_exception_gracefully(self, mock_client_class):
        """Exception during send returns error result."""
        mock_client = MagicMock()
        mock_client.send.side_effect = Exception("Network error")
        mock_client_class.return_value = mock_client

        with patch('app.services.email.settings') as mock_settings:
            mock_settings.SENDGRID_API_KEY = "test_key"
            mock_settings.SENDGRID_FROM_EMAIL = "test@test.com"
            mock_settings.SENDGRID_WELCOME_TEMPLATE_ID = ""
            mock_settings.BASE_URL = "https://test.com"

            service = EmailService()
            result = asyncio.run(service.send_order_confirmation(
                "customer@test.com", "+1234567890", 2999, 100
            ))

            assert not result.success
            assert "Network error" in result.error


class TestLowBalanceEmail:
    """Test low balance warning email."""

    def test_low_balance_not_configured(self):
        """Low balance email handles missing config."""
        with patch('app.services.email.settings') as mock_settings:
            mock_settings.SENDGRID_API_KEY = ""
            service = EmailService()

            result = asyncio.run(service.send_low_balance_warning(
                "test@test.com", 200, 5
            ))

            assert not result.success
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# Run email tests
pytest tests/test_email.py -v --tb=short

# Run all tests
pytest tests/ -x -q --tb=short
```
  </verify>
  <done>Email tests pass, all existing tests pass</done>
</task>

</tasks>

<verification>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# 1. Email service exists and handles missing config
python -c "
from app.services.email import get_email_service
svc = get_email_service()
print(f'Email service initialized, configured={svc.is_configured()}')
"

# 2. Webhook integrates email
python -c "
import inspect
from app.routers.webhook import handle_checkout_completed
source = inspect.getsource(handle_checkout_completed)
assert 'send_order_confirmation' in source
print('Webhook sends confirmation email')
"

# 3. Email tests pass
pytest tests/test_email.py -v --tb=short

# 4. All tests pass
pytest tests/ -x -q --tb=short
```
</verification>

<success_criteria>
- Email service sends order confirmation with SMS number and quick start link
- Dynamic template support when SENDGRID_WELCOME_TEMPLATE_ID configured
- Fallback to plain text email if no template
- Email failures logged but don't break payment flow
- Webhook sends email after successful checkout completion
- Balance credited BEFORE email attempt (reliability order)
- All email tests pass
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-payments/02-04-SUMMARY.md`
</output>
