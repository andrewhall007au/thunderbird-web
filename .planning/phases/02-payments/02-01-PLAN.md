---
phase: 02-payments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/payments.py
  - backend/config/sms_pricing.py
  - alembic/versions/xxx_add_payment_tables.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Payment database tables exist and can store orders"
    - "Balance table tracks account balances in integer cents"
    - "Discount codes can be stored and queried"
    - "Country SMS costs are configured for 8 countries"
  artifacts:
    - path: "backend/app/models/payments.py"
      provides: "Order, AccountBalance, DiscountCode, CountrySMSCost models"
      exports: ["Order", "AccountBalance", "DiscountCode", "CountrySMSCost", "OrderStore", "BalanceStore", "DiscountCodeStore"]
    - path: "backend/config/sms_pricing.py"
      provides: "Country-specific SMS cost configuration"
      contains: "SMS_COSTS_BY_COUNTRY"
    - path: "alembic/versions/xxx_add_payment_tables.py"
      provides: "Database migration for payment tables"
      contains: "create_table.*orders"
  key_links:
    - from: "backend/app/models/payments.py"
      to: "backend/app/models/account.py"
      via: "account_id foreign key reference"
      pattern: "account_id.*INTEGER"
---

<objective>
Create payment database models and country SMS cost configuration for Phase 2 payments.

Purpose: Establish data foundation for all payment operations - orders, balances, discount codes, and country-specific SMS pricing. This enables PAY-06 (balance tracking), PAY-10 (country SMS costs), and PAY-11 (variable segments per $10).

Output: Payment models with SQLite stores, Alembic migration, and SMS cost configuration for 8 countries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-payments/02-RESEARCH.md

# Existing models to follow patterns from
@backend/app/models/account.py
@backend/app/models/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment models in backend/app/models/payments.py</name>
  <files>backend/app/models/payments.py</files>
  <action>
Create payment-related dataclasses and SQLite stores following the pattern in account.py:

1. **Order dataclass:**
   - id: int (primary key)
   - account_id: int (foreign key to accounts)
   - order_type: str ("initial_access" | "top_up")
   - amount_cents: int (amount charged)
   - stripe_session_id: Optional[str] (Stripe checkout session)
   - stripe_payment_intent_id: Optional[str] (for off-session payments)
   - discount_code_id: Optional[int] (if discount applied)
   - status: str ("pending" | "completed" | "failed" | "refunded")
   - created_at: datetime
   - completed_at: Optional[datetime]

2. **AccountBalance dataclass:**
   - id: int
   - account_id: int (unique - one balance per account)
   - balance_cents: int (current balance, can be negative temporarily)
   - updated_at: datetime

3. **DiscountCode dataclass:**
   - id: int
   - code: str (unique, uppercase, e.g., "LAUNCH10")
   - discount_type: str ("percent" | "fixed")
   - discount_value: int (percent as 10 for 10%, or cents for fixed)
   - max_uses: Optional[int] (None for unlimited)
   - current_uses: int (default 0)
   - active: bool (default True)
   - stripe_coupon_id: Optional[str] (linked Stripe coupon)
   - created_at: datetime

4. **Transaction dataclass (for audit trail):**
   - id: int
   - account_id: int
   - order_id: Optional[int]
   - transaction_type: str ("credit" | "debit" | "refund")
   - amount_cents: int
   - balance_after_cents: int
   - description: str (e.g., "Initial purchase", "SMS to +44...", "Top-up")
   - created_at: datetime

5. **CountrySMSCost dataclass:**
   - country_code: str (ISO 2-letter, e.g., "US", "GB")
   - country_name: str
   - twilio_cost_per_segment_cents: int (Twilio cost in cents)
   - customer_cost_per_segment_cents: int (what we charge)
   - segments_per_10_dollars: int (calculated for display)

6. **Store classes following AccountStore pattern:**
   - OrderStore: create(), get_by_id(), get_by_account_id(), update_status(), get_by_stripe_session()
   - BalanceStore: get_or_create(), add_credits(), deduct(), get_balance(), record_transaction()
   - DiscountCodeStore: create(), get_by_code(), increment_uses(), validate()

Use sqlite3 with context manager pattern. Store all amounts as INTEGER cents (never float).
Add singleton instances: order_store, balance_store, discount_code_store
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from app.models.payments import Order, AccountBalance, DiscountCode, Transaction, CountrySMSCost
from app.models.payments import order_store, balance_store, discount_code_store
print('Models imported successfully')
print(f'Order fields: {Order.__dataclass_fields__.keys()}')
print(f'AccountBalance fields: {AccountBalance.__dataclass_fields__.keys()}')
"
```
  </verify>
  <done>Payment model classes exist with correct fields, store classes instantiate without error</done>
</task>

<task type="auto">
  <name>Task 2: Create country SMS pricing configuration</name>
  <files>backend/config/sms_pricing.py</files>
  <action>
Create SMS pricing configuration based on research (02-RESEARCH.md Section "SMS Pricing by Country").

1. **SMS_COSTS_BY_COUNTRY dict:**
   Map country_code -> CountrySMSCost for 8 countries:
   - US: Twilio $0.0113 (1.13 cents), 80% margin -> customer 5.65 cents, 176 segments/$10
   - CA: Twilio $0.0170 (1.70 cents), 80% margin -> customer 8.50 cents, 117 segments/$10
   - GB: Twilio $0.0524 (5.24 cents), 80% margin -> customer 26.20 cents, 38 segments/$10
   - FR: Twilio $0.0798 (7.98 cents), 80% margin -> customer 39.90 cents, 25 segments/$10
   - IT: Twilio $0.0927 (9.27 cents), 80% margin -> customer 46.35 cents, 21 segments/$10
   - CH: Twilio $0.0725 (7.25 cents), 80% margin -> customer 36.25 cents, 27 segments/$10
   - NZ: Twilio $0.1050 (10.50 cents), 80% margin -> customer 52.50 cents, 19 segments/$10
   - ZA: Twilio $0.1089 (10.89 cents), 80% margin -> customer 54.45 cents, 18 segments/$10

2. **Helper functions:**
   - get_sms_cost(country_code: str) -> CountrySMSCost (default to US if unknown)
   - get_segments_per_topup(country_code: str) -> int
   - calculate_sms_cost_cents(country_code: str, segments: int) -> int
   - get_country_from_phone(phone: str) -> str (parse E.164 to extract country code)
   - MARGIN_PERCENT = 80 (constant for documentation)

3. **Margin calculation formula (documented in module docstring):**
   - customer_rate = twilio_rate / 0.20 (means we keep 80%, Twilio gets 20% of what customer pays)
   - segments_per_10_dollars = floor(1000 / customer_rate_cents)
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
from config.sms_pricing import SMS_COSTS_BY_COUNTRY, get_sms_cost, get_segments_per_topup, get_country_from_phone
print(f'Countries configured: {list(SMS_COSTS_BY_COUNTRY.keys())}')
us = get_sms_cost('US')
print(f'US: {us.segments_per_10_dollars} segments/\$10')
gb = get_sms_cost('GB')
print(f'GB: {gb.segments_per_10_dollars} segments/\$10')
# Test phone parsing
print(f'+1 phone -> {get_country_from_phone(\"+14155551234\")}')
print(f'+44 phone -> {get_country_from_phone(\"+447700900123\")}')
"
```
  </verify>
  <done>8 countries configured, margin calculations correct (US=176, GB=38 segments/$10), phone country detection works</done>
</task>

<task type="auto">
  <name>Task 3: Create Alembic migration for payment tables</name>
  <files>alembic/versions/xxx_add_payment_tables.py</files>
  <action>
Create new Alembic migration following the batch mode pattern established in Phase 1.

1. **Run alembic revision:**
```bash
cd /Users/andrewhall/thunderbird-web/backend
alembic revision -m "add_payment_tables"
```

2. **Edit the generated migration to create tables:**

```python
# Orders table
op.create_table(
    'orders',
    sa.Column('id', sa.Integer(), primary_key=True),
    sa.Column('account_id', sa.Integer(), nullable=False),
    sa.Column('order_type', sa.String(20), nullable=False),  # initial_access, top_up
    sa.Column('amount_cents', sa.Integer(), nullable=False),
    sa.Column('stripe_session_id', sa.String(255), nullable=True),
    sa.Column('stripe_payment_intent_id', sa.String(255), nullable=True),
    sa.Column('discount_code_id', sa.Integer(), nullable=True),
    sa.Column('status', sa.String(20), nullable=False, default='pending'),
    sa.Column('created_at', sa.String(50), nullable=False),
    sa.Column('completed_at', sa.String(50), nullable=True),
)
op.create_index('ix_orders_account_id', 'orders', ['account_id'])
op.create_index('ix_orders_stripe_session_id', 'orders', ['stripe_session_id'])

# Account balances table (one per account)
op.create_table(
    'account_balances',
    sa.Column('id', sa.Integer(), primary_key=True),
    sa.Column('account_id', sa.Integer(), nullable=False, unique=True),
    sa.Column('balance_cents', sa.Integer(), nullable=False, default=0),
    sa.Column('updated_at', sa.String(50), nullable=False),
)
op.create_index('ix_account_balances_account_id', 'account_balances', ['account_id'])

# Transactions table (audit trail)
op.create_table(
    'transactions',
    sa.Column('id', sa.Integer(), primary_key=True),
    sa.Column('account_id', sa.Integer(), nullable=False),
    sa.Column('order_id', sa.Integer(), nullable=True),
    sa.Column('transaction_type', sa.String(20), nullable=False),  # credit, debit, refund
    sa.Column('amount_cents', sa.Integer(), nullable=False),
    sa.Column('balance_after_cents', sa.Integer(), nullable=False),
    sa.Column('description', sa.String(255), nullable=False),
    sa.Column('created_at', sa.String(50), nullable=False),
)
op.create_index('ix_transactions_account_id', 'transactions', ['account_id'])

# Discount codes table
op.create_table(
    'discount_codes',
    sa.Column('id', sa.Integer(), primary_key=True),
    sa.Column('code', sa.String(50), nullable=False, unique=True),
    sa.Column('discount_type', sa.String(20), nullable=False),  # percent, fixed
    sa.Column('discount_value', sa.Integer(), nullable=False),
    sa.Column('max_uses', sa.Integer(), nullable=True),
    sa.Column('current_uses', sa.Integer(), nullable=False, default=0),
    sa.Column('active', sa.Boolean(), nullable=False, default=True),
    sa.Column('stripe_coupon_id', sa.String(255), nullable=True),
    sa.Column('created_at', sa.String(50), nullable=False),
)
op.create_index('ix_discount_codes_code', 'discount_codes', ['code'])

# Add stripe_customer_id to accounts table (for stored cards)
with op.batch_alter_table('accounts') as batch_op:
    batch_op.add_column(sa.Column('stripe_customer_id', sa.String(255), nullable=True))
```

3. **Run migration:**
```bash
alembic upgrade head
```
  </action>
  <verify>
```bash
cd /Users/andrewhall/thunderbird-web/backend && python -c "
import sqlite3
conn = sqlite3.connect('thunderbird.db')
cursor = conn.cursor()
# Check tables exist
cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")
tables = [row[0] for row in cursor.fetchall()]
print(f'Tables: {tables}')
assert 'orders' in tables, 'orders table missing'
assert 'account_balances' in tables, 'account_balances table missing'
assert 'transactions' in tables, 'transactions table missing'
assert 'discount_codes' in tables, 'discount_codes table missing'
# Check accounts has stripe_customer_id
cursor.execute('PRAGMA table_info(accounts)')
cols = [row[1] for row in cursor.fetchall()]
assert 'stripe_customer_id' in cols, 'stripe_customer_id column missing'
print('All payment tables created successfully')
conn.close()
"
```
  </verify>
  <done>Migration runs successfully, all 4 new tables exist, accounts has stripe_customer_id column</done>
</task>

</tasks>

<verification>
```bash
cd /Users/andrewhall/thunderbird-web/backend

# 1. Models import correctly
python -c "from app.models.payments import *; print('Models OK')"

# 2. SMS pricing configured
python -c "from config.sms_pricing import SMS_COSTS_BY_COUNTRY; print(f'{len(SMS_COSTS_BY_COUNTRY)} countries')"

# 3. Database tables exist
python -c "
import sqlite3
conn = sqlite3.connect('thunderbird.db')
cursor = conn.cursor()
cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")
tables = {row[0] for row in cursor.fetchall()}
required = {'orders', 'account_balances', 'transactions', 'discount_codes'}
missing = required - tables
assert not missing, f'Missing tables: {missing}'
print('All tables exist')
"

# 4. Existing tests still pass
pytest tests/ -x -q --tb=short
```
</verification>

<success_criteria>
- Payment models (Order, AccountBalance, DiscountCode, Transaction, CountrySMSCost) defined with correct fields
- Store classes (OrderStore, BalanceStore, DiscountCodeStore) follow AccountStore pattern
- 8 countries configured with correct SMS pricing (80% margin maintained)
- Phone-to-country parsing works for E.164 numbers
- Alembic migration creates all tables successfully
- accounts table has stripe_customer_id column
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-payments/02-01-SUMMARY.md`
</output>
