---
phase: 09-monitoring-alerting
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - backend/monitoring/api.py
  - app/monitoring/page.tsx
  - app/monitoring/components/StatusCard.tsx
  - app/monitoring/components/UptimeChart.tsx
  - app/monitoring/components/IncidentLog.tsx
autonomous: true

must_haves:
  truths:
    - "Status dashboard shows real-time health of all monitored checks"
    - "Dashboard shows uptime percentage for each check over last 24 hours"
    - "Dashboard shows response time trends over time"
    - "Active incidents are visible on the dashboard"
    - "Dashboard is accessible at /monitoring and auto-refreshes"
  artifacts:
    - path: "backend/monitoring/api.py"
      provides: "Dashboard API endpoints for metrics, uptime, incidents"
      exports: ["router"]
      contains: "APIRouter"
    - path: "app/monitoring/page.tsx"
      provides: "Status dashboard page with health overview"
      contains: "monitoring"
  key_links:
    - from: "app/monitoring/page.tsx"
      to: "backend/monitoring/api.py"
      via: "fetch calls to /api/monitoring/* endpoints"
      pattern: "fetch.*api/monitoring"
    - from: "backend/monitoring/api.py"
      to: "backend/monitoring/storage.py"
      via: "queries metrics database for dashboard data"
      pattern: "get_all_latest_statuses|get_uptime_stats|get_active_incidents"
---

<objective>
Build the status dashboard: API endpoints to serve monitoring data and a Next.js page to visualize system health.

Purpose: Without visibility, monitoring data is useless. The dashboard provides at-a-glance system health, historical uptime, response time trends, and active incidents - replacing the need to SSH into the server and check logs.

Output: `/monitoring` page showing real-time system health, uptime percentages, response time graphs, and incident history. API endpoints serving dashboard data from the monitoring SQLite DB.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-monitoring-alerting/09-RESEARCH.md
@.planning/phases/09-monitoring-alerting/09-01-SUMMARY.md

# Frontend patterns
@app/layout.tsx
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard API endpoints</name>
  <files>
    backend/monitoring/api.py
  </files>
  <action>
**backend/monitoring/api.py** - API endpoints for the dashboard:

Create a FastAPI APIRouter with prefix `/api/monitoring`. These endpoints will be mounted in the monitoring service's main.py (already created in Plan 01).

Endpoints:

1. `GET /api/monitoring/status` - Overall system status:
   ```json
   {
     "overall_status": "healthy" | "degraded" | "down",
     "checks": [
       {
         "name": "health_check",
         "display_name": "Backend Health",
         "status": "pass",
         "last_check_ms": 1706000000000,
         "duration_ms": 145.2,
         "error": null
       }
     ],
     "active_incidents": 0,
     "timestamp": "2026-02-04T12:00:00Z"
   }
   ```
   - overall_status: "healthy" if all pass, "degraded" if any warning, "down" if any critical failing
   - Calls `get_all_latest_statuses()` from storage
   - Include a display_name mapping: health_check -> "Backend Health", beta_signup_flow -> "Beta Signup", etc.

2. `GET /api/monitoring/uptime?hours=24` - Uptime statistics:
   ```json
   {
     "period_hours": 24,
     "checks": [
       {
         "name": "health_check",
         "display_name": "Backend Health",
         "total_checks": 1440,
         "successful_checks": 1438,
         "uptime_percent": 99.86,
         "avg_duration_ms": 142.5
       }
     ]
   }
   ```
   - Accept `hours` query param (default 24, max 720 = 30 days)
   - Calls `get_uptime_stats()` from storage

3. `GET /api/monitoring/metrics/{check_name}?hours=1` - Time series for a specific check:
   ```json
   {
     "check_name": "health_check",
     "period_hours": 1,
     "data_points": [
       {
         "timestamp_ms": 1706000000000,
         "status": "pass",
         "duration_ms": 145.2
       }
     ]
   }
   ```
   - Accept `hours` query param (default 1, max 168 = 7 days)
   - Calls `get_recent_metrics()` from storage
   - Limit to 1000 data points max

4. `GET /api/monitoring/incidents` - Active and recent incidents:
   ```json
   {
     "active": [
       {
         "id": "uuid",
         "check_name": "beta_signup_flow",
         "severity": "critical",
         "status": "active",
         "first_seen": "2026-02-04T12:00:00Z",
         "failure_count": 5,
         "message": "HTTP 500 on beta signup endpoint"
       }
     ],
     "recent_resolved": [...]
   }
   ```
   - Calls `get_active_incidents()` from storage
   - Include recently resolved incidents (last 24 hours)

5. `GET /api/monitoring/summary` - Daily summary stats (for the reporting requirement):
   ```json
   {
     "date": "2026-02-04",
     "total_checks_run": 2880,
     "total_failures": 3,
     "uptime_percent": 99.9,
     "avg_response_ms": 150.2,
     "incidents_today": 1,
     "alerts_sent": 2
   }
   ```

Mount the router in `backend/monitoring/main.py`:
```python
from monitoring.api import router as monitoring_api_router
app.include_router(monitoring_api_router)
```

All endpoints return JSON, no authentication required (dashboard is internal/admin - accessible via direct URL only, not linked in public nav). Add CORS middleware allowing localhost:3000 and thunderbird.bot origins.
  </action>
  <verify>
`python -c "from monitoring.api import router; print(f'API router with {len(router.routes)} routes')"` from backend/ directory shows 5+ routes.
Start monitoring service briefly and hit: `curl http://localhost:8001/api/monitoring/status` returns valid JSON.
  </verify>
  <done>Dashboard API serves system status, uptime stats, time series metrics, incident history, and daily summary. All endpoints return structured JSON from monitoring SQLite DB.</done>
</task>

<task type="auto">
  <name>Task 2: Next.js monitoring dashboard page</name>
  <files>
    app/monitoring/page.tsx
    app/monitoring/components/StatusCard.tsx
    app/monitoring/components/UptimeChart.tsx
    app/monitoring/components/IncidentLog.tsx
  </files>
  <action>
Create the monitoring dashboard as a Next.js page at `/monitoring`.

**app/monitoring/page.tsx** - Main dashboard page:
- 'use client' (needs useEffect for polling)
- Title: "System Health" with last-updated timestamp
- Auto-refresh: poll `/api/monitoring/status` every 30 seconds using setInterval in useEffect
- Layout: responsive grid
  - Top: Overall status banner (green "All Systems Operational" / yellow "Degraded" / red "System Down")
  - Row 1: StatusCard grid (3 columns on lg, 2 on md, 1 on mobile) for each check
  - Row 2: Uptime stats (24h uptime percentages per check)
  - Row 3: Response time chart (last hour)
  - Row 4: Active incidents (if any)
  - Row 5: Recent incident history
- Fetch from monitoring service via proxy. Add to `next.config.js` rewrites:
  ```js
  { source: '/api/monitoring/:path*', destination: 'http://localhost:8001/api/monitoring/:path*' }
  ```
  Wait - the existing proxy setup already handles `/api/*` to port 8000. The monitoring service runs on 8001. Two options:
  1. Mount monitoring API on the main backend (port 8000) - simpler for the dashboard
  2. Add separate proxy rule for /api/monitoring to port 8001

  Go with option 1: Add monitoring API routes to the main backend app. Import and mount the monitoring API router in `backend/app/main.py`:
  ```python
  # Only if monitoring module is available
  try:
      from monitoring.api import router as monitoring_api_router
      app.include_router(monitoring_api_router)
  except ImportError:
      pass
  ```
  This way the existing proxy handles it and the dashboard just fetches from `/api/monitoring/*`.

- Styling: Use existing Tailwind classes. Match the site's design language (dark bg cards, orange accents for the Thunderbird brand).
- NO external chart library needed for v1 - use simple colored bars for uptime visualization and a basic table for response times. Keep it lightweight.

**app/monitoring/components/StatusCard.tsx**:
- Props: `name: string, displayName: string, status: 'pass' | 'fail' | 'degraded', lastCheckMs: number, durationMs: number, error?: string`
- Visual: Card with colored left border (green=pass, red=fail, yellow=degraded)
- Shows: display name, status icon, last check time (relative: "2 min ago"), response time
- If error: show truncated error message with expandable detail

**app/monitoring/components/UptimeChart.tsx**:
- Props: `checks: Array<{name, displayName, uptimePercent, totalChecks, avgDuration}>`
- Visual: For each check, show a horizontal bar chart:
  - Check name on left
  - Colored bar representing uptime % (green >99.5%, yellow >99%, red <99%)
  - Percentage and average response time on right
- Simple CSS-based bars (no chart library needed)

**app/monitoring/components/IncidentLog.tsx**:
- Props: `active: Incident[], resolved: Incident[]`
- Visual: List of incidents with:
  - Severity badge (red for critical, orange for warning)
  - Check name and error message
  - Duration (first seen -> now for active, first seen -> resolved for resolved)
  - Status: "Investigating" for active, "Resolved" for resolved
- Active incidents at top with pulsing red dot
- Resolved incidents below with green checkmark

Do NOT add the monitoring page to the main navigation. It should be accessible via direct URL only (/monitoring). This is an internal admin tool.
  </action>
  <verify>
1. Verify page compiles: `npx next build` from project root (or at minimum check for syntax errors).
2. Verify components export correctly: All .tsx files parse without errors.
3. Monitoring API is mounted in main backend: `grep -n "monitoring" backend/app/main.py` shows the import.
  </verify>
  <done>Status dashboard at /monitoring shows real-time system health with auto-refresh, uptime percentages per check, response time data, and active/resolved incident history. Dashboard is internal (not in public nav) and fetches data via existing API proxy.</done>
</task>

</tasks>

<verification>
- /monitoring page loads and shows system health overview
- Status cards show current state of each monitored check with color coding
- Uptime bars show 24-hour uptime percentage per check
- Incident log shows active and recently resolved incidents
- Page auto-refreshes every 30 seconds
- Dashboard works on mobile (responsive grid)
- Monitoring API endpoints return valid JSON from metrics database
</verification>

<success_criteria>
- Admin can visit /monitoring and immediately see if any systems are down
- Uptime percentages are calculated correctly from stored metrics
- Active incidents are prominently displayed with severity and duration
- Dashboard does not appear in public navigation
- Page loads quickly without heavy dependencies (no Chart.js or Recharts in v1)
</success_criteria>

<output>
After completion, create `.planning/phases/09-monitoring-alerting/09-04-SUMMARY.md`
</output>
