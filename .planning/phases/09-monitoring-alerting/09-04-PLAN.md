---
phase: 09-monitoring-alerting
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - backend/monitoring/api.py
  - app/monitoring/page.tsx
  - app/monitoring/components/StatusCard.tsx
  - app/monitoring/components/UptimeChart.tsx
  - app/monitoring/components/IncidentLog.tsx
autonomous: true

must_haves:
  truths:
    - "Status dashboard shows real-time health of all monitored checks"
    - "Dashboard shows uptime percentage for each check over last 24 hours"
    - "Dashboard shows response time trends over time"
    - "Active incidents are visible on the dashboard"
    - "Incidents can be acknowledged from the dashboard to stop escalation"
    - "Incident timeline shows progression of events for each incident"
    - "Dashboard is accessible at /monitoring and auto-refreshes"
  artifacts:
    - path: "backend/monitoring/api.py"
      provides: "Dashboard API endpoints for metrics, uptime, incidents, acknowledgment, and timeline"
      exports: ["router"]
      contains: "APIRouter"
    - path: "app/monitoring/page.tsx"
      provides: "Status dashboard page with health overview"
      contains: "monitoring"
  key_links:
    - from: "app/monitoring/page.tsx"
      to: "backend/monitoring/api.py"
      via: "fetch calls to /api/monitoring/* endpoints"
      pattern: "fetch.*api/monitoring"
    - from: "backend/monitoring/api.py"
      to: "backend/monitoring/storage.py"
      via: "queries metrics database for dashboard data"
      pattern: "get_all_latest_statuses|get_uptime_stats|get_active_incidents|acknowledge_incident|get_incident_timeline"
---

<objective>
Build the status dashboard: API endpoints to serve monitoring data (including incident acknowledgment and timeline) and a Next.js page to visualize system health.

Purpose: Without visibility, monitoring data is useless. The dashboard provides at-a-glance system health, historical uptime, response time trends, active incidents with acknowledgment capability, and incident timelines - replacing the need to SSH into the server and check logs.

Output: `/monitoring` page showing real-time system health, uptime percentages, response time graphs, incident history with acknowledge buttons and incident timelines. API endpoints serving dashboard data from the monitoring SQLite DB.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-monitoring-alerting/09-RESEARCH.md
@.planning/phases/09-monitoring-alerting/09-01-SUMMARY.md

# Frontend patterns
@app/layout.tsx
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard API endpoints including acknowledgment and incident timeline</name>
  <files>
    backend/monitoring/api.py
  </files>
  <action>
**backend/monitoring/api.py** - API endpoints for the dashboard:

Create a FastAPI APIRouter with prefix `/api/monitoring`. These endpoints will be mounted in the monitoring service's main.py (already created in Plan 01).

Endpoints:

1. `GET /api/monitoring/status` - Overall system status:
   ```json
   {
     "overall_status": "healthy" | "degraded" | "down",
     "checks": [
       {
         "name": "health_check",
         "display_name": "Backend Health",
         "status": "pass",
         "last_check_ms": 1706000000000,
         "duration_ms": 145.2,
         "error": null
       }
     ],
     "active_incidents": 0,
     "timestamp": "2026-02-04T12:00:00Z"
   }
   ```
   - overall_status: "healthy" if all pass, "degraded" if any warning, "down" if any critical failing
   - Calls `get_all_latest_statuses()` from storage
   - Include a display_name mapping: health_check -> "Backend Health", beta_signup_flow -> "Beta Signup", db_query_performance -> "Database Queries", external_api_latency -> "External APIs", synthetic_login -> "Login Flow", synthetic_sms_webhook -> "SMS Webhook", etc.

2. `GET /api/monitoring/uptime?hours=24` - Uptime statistics:
   ```json
   {
     "period_hours": 24,
     "checks": [
       {
         "name": "health_check",
         "display_name": "Backend Health",
         "total_checks": 1440,
         "successful_checks": 1438,
         "uptime_percent": 99.86,
         "avg_duration_ms": 142.5
       }
     ]
   }
   ```
   - Accept `hours` query param (default 24, max 720 = 30 days)
   - Calls `get_uptime_stats()` from storage

3. `GET /api/monitoring/metrics/{check_name}?hours=1` - Time series for a specific check:
   ```json
   {
     "check_name": "health_check",
     "period_hours": 1,
     "data_points": [
       {
         "timestamp_ms": 1706000000000,
         "status": "pass",
         "duration_ms": 145.2
       }
     ]
   }
   ```
   - Accept `hours` query param (default 1, max 168 = 7 days)
   - Calls `get_recent_metrics()` from storage
   - Limit to 1000 data points max

4. `GET /api/monitoring/incidents` - Active and recent incidents:
   ```json
   {
     "active": [
       {
         "id": "uuid",
         "check_name": "beta_signup_flow",
         "severity": "critical",
         "status": "active",
         "first_seen": "2026-02-04T12:00:00Z",
         "failure_count": 5,
         "message": "HTTP 500 on beta signup endpoint"
       }
     ],
     "recent_resolved": [...]
   }
   ```
   - Calls `get_active_incidents()` from storage
   - Include recently resolved incidents (last 24 hours)

5. `POST /api/monitoring/incidents/{incident_id}/acknowledge` - Acknowledge an incident (MON-06):
   ```json
   // Request body (optional):
   { "acknowledged_by": "admin" }

   // Response:
   {
     "id": "uuid",
     "status": "acknowledged",
     "acknowledged_at": "2026-02-04T12:05:00Z"
   }
   ```
   - Calls `acknowledge_incident(incident_id)` from storage
   - Returns 404 if incident not found
   - Returns 400 if incident already resolved
   - Sets incident status to 'acknowledged' which stops alert escalation (warning->SMS)
   - Logs who acknowledged and when

6. `GET /api/monitoring/incidents/{incident_id}/timeline` - Incident timeline (MON-06):
   ```json
   {
     "incident": {
       "id": "uuid",
       "check_name": "beta_signup_flow",
       "severity": "critical",
       "status": "active",
       "first_seen": "2026-02-04T12:00:00Z",
       "last_seen": "2026-02-04T12:15:00Z",
       "failure_count": 5
     },
     "timeline": [
       {
         "timestamp": "2026-02-04T12:00:00Z",
         "event": "first_failure",
         "details": "HTTP 500 on beta signup endpoint"
       },
       {
         "timestamp": "2026-02-04T12:01:00Z",
         "event": "consecutive_failure",
         "details": "2nd consecutive failure"
       },
       {
         "timestamp": "2026-02-04T12:01:05Z",
         "event": "alert_sent",
         "details": "Critical SMS + email sent"
       },
       {
         "timestamp": "2026-02-04T12:05:00Z",
         "event": "acknowledged",
         "details": "Acknowledged by admin"
       }
     ]
   }
   ```
   - Calls `get_incident_timeline(incident_id)` from storage
   - Reconstructs timeline from incident record + associated metrics during incident window
   - Returns 404 if incident not found

7. `GET /api/monitoring/summary` - Daily summary stats (for the reporting requirement):
   ```json
   {
     "date": "2026-02-04",
     "total_checks_run": 2880,
     "total_failures": 3,
     "uptime_percent": 99.9,
     "avg_response_ms": 150.2,
     "incidents_today": 1,
     "alerts_sent": 2
   }
   ```

Mount the router in `backend/monitoring/main.py`:
```python
from monitoring.api import router as monitoring_api_router
app.include_router(monitoring_api_router)
```

Also mount in the main backend app for proxy access. Import and mount the monitoring API router in `backend/app/main.py`:
```python
# Only if monitoring module is available
try:
    from monitoring.api import router as monitoring_api_router
    app.include_router(monitoring_api_router)
except ImportError:
    pass
```
This way the existing proxy handles it and the dashboard just fetches from `/api/monitoring/*`.

All endpoints return JSON, no authentication required (dashboard is internal/admin - accessible via direct URL only, not linked in public nav). Add CORS middleware allowing localhost:3000 and thunderbird.bot origins.
  </action>
  <verify>
`python -c "from monitoring.api import router; print(f'API router with {len(router.routes)} routes')"` from backend/ directory shows 7+ routes.
Start monitoring service briefly and hit: `curl http://localhost:8001/api/monitoring/status` returns valid JSON.
  </verify>
  <done>Dashboard API serves system status, uptime stats, time series metrics, incident history, incident acknowledgment (POST), and incident timeline. All endpoints return structured JSON from monitoring SQLite DB.</done>
</task>

<task type="auto">
  <name>Task 2: Next.js monitoring dashboard page with acknowledge and timeline</name>
  <files>
    app/monitoring/page.tsx
    app/monitoring/components/StatusCard.tsx
    app/monitoring/components/UptimeChart.tsx
    app/monitoring/components/IncidentLog.tsx
  </files>
  <action>
Create the monitoring dashboard as a Next.js page at `/monitoring`.

**app/monitoring/page.tsx** - Main dashboard page:
- 'use client' (needs useEffect for polling)
- Title: "System Health" with last-updated timestamp
- Auto-refresh: poll `/api/monitoring/status` every 30 seconds using setInterval in useEffect
- Layout: responsive grid
  - Top: Overall status banner (green "All Systems Operational" / yellow "Degraded" / red "System Down")
  - Row 1: StatusCard grid (3 columns on lg, 2 on md, 1 on mobile) for each check
  - Row 2: Uptime stats (24h uptime percentages per check)
  - Row 3: Response time chart (last hour)
  - Row 4: Active incidents (if any) with acknowledge buttons and timeline links
  - Row 5: Recent incident history
- Fetch from monitoring service via proxy (existing `/api/*` proxy to port 8000, monitoring API mounted there)
- Styling: Use existing Tailwind classes. Match the site's design language (dark bg cards, orange accents for the Thunderbird brand).
- NO external chart library needed for v1 - use simple colored bars for uptime visualization and a basic table for response times. Keep it lightweight.

**app/monitoring/components/StatusCard.tsx**:
- Props: `name: string, displayName: string, status: 'pass' | 'fail' | 'degraded', lastCheckMs: number, durationMs: number, error?: string`
- Visual: Card with colored left border (green=pass, red=fail, yellow=degraded)
- Shows: display name, status icon, last check time (relative: "2 min ago"), response time
- If error: show truncated error message with expandable detail

**app/monitoring/components/UptimeChart.tsx**:
- Props: `checks: Array<{name, displayName, uptimePercent, totalChecks, avgDuration}>`
- Visual: For each check, show a horizontal bar chart:
  - Check name on left
  - Colored bar representing uptime % (green >99.5%, yellow >99%, red <99%)
  - Percentage and average response time on right
- Simple CSS-based bars (no chart library needed)

**app/monitoring/components/IncidentLog.tsx**:
- Props: `active: Incident[], resolved: Incident[], onAcknowledge: (id: string) => void`
- Visual: List of incidents with:
  - Severity badge (red for critical, orange for warning)
  - Check name and error message
  - Duration (first seen -> now for active, first seen -> resolved for resolved)
  - Status: "Investigating" for active, "Acknowledged" for acknowledged, "Resolved" for resolved
  - **Acknowledge button** (MON-06): For active (non-acknowledged) incidents, show "Acknowledge" button that calls `POST /api/monitoring/incidents/{id}/acknowledge`. Button becomes "Acknowledged" (disabled, green) after click. Acknowledged incidents still show in active list but with "Acknowledged" badge instead of "Investigating".
  - **Timeline link** (MON-06): Each incident (active or resolved) has a "View Timeline" expandable section. When expanded, fetches `GET /api/monitoring/incidents/{id}/timeline` and shows a vertical timeline of events (first failure, consecutive failures, alerts sent, acknowledged, resolved). Use simple Tailwind styling: vertical line with dot markers for each event.
- Active incidents at top with pulsing red dot (or pulsing yellow if acknowledged)
- Resolved incidents below with green checkmark

Do NOT add the monitoring page to the main navigation. It should be accessible via direct URL only (/monitoring). This is an internal admin tool.
  </action>
  <verify>
1. Verify page compiles: `npx next build` from project root (or at minimum check for syntax errors).
2. Verify components export correctly: All .tsx files parse without errors.
3. Monitoring API is mounted in main backend: `grep -n "monitoring" backend/app/main.py` shows the import.
  </verify>
  <done>Status dashboard at /monitoring shows real-time system health with auto-refresh, uptime percentages per check, response time data, active/resolved incident history with acknowledge buttons and incident timelines. Dashboard is internal (not in public nav) and fetches data via existing API proxy.</done>
</task>

</tasks>

<verification>
- /monitoring page loads and shows system health overview
- Status cards show current state of each monitored check with color coding
- Uptime bars show 24-hour uptime percentage per check
- Incident log shows active and recently resolved incidents
- Active incidents can be acknowledged via button click
- Acknowledged incidents stop escalation (no further warning->SMS)
- Incident timeline shows progression of events
- Page auto-refreshes every 30 seconds
- Dashboard works on mobile (responsive grid)
- Monitoring API endpoints return valid JSON from metrics database
- POST acknowledge endpoint returns updated incident status
- GET timeline endpoint returns chronological event list
</verification>

<success_criteria>
- Admin can visit /monitoring and immediately see if any systems are down
- Uptime percentages are calculated correctly from stored metrics
- Active incidents are prominently displayed with severity and duration
- Acknowledge button stops escalation and updates incident status
- Incident timeline provides clear chronological view of events
- Dashboard does not appear in public navigation
- Page loads quickly without heavy dependencies (no Chart.js or Recharts in v1)
</success_criteria>

<output>
After completion, create `.planning/phases/09-monitoring-alerting/09-04-SUMMARY.md`
</output>
