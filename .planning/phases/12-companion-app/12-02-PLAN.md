---
phase: 12-companion-app
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - app/prototype/lib/openmeteo.ts
  - app/prototype/lib/types.ts
  - app/prototype/components/ForecastPanel.tsx
  - app/prototype/components/TimeScrubber.tsx
  - app/prototype/components/WeatherGrid.tsx
  - app/prototype/components/PrototypeMap.tsx
  - app/prototype/components/PinPanel.tsx
  - app/prototype/page.tsx
autonomous: true

must_haves:
  truths:
    - "Dropping a pin fetches weather data from Open-Meteo for that location"
    - "Forecast cards show temp, wind, gusts, rain probability, precipitation for each pin"
    - "Time scrubber slides from now to +72 hours"
    - "Forecast cards update when time scrubber moves"
    - "Weather grid overlay shows model resolution cells (toggleable)"
    - "Multiple pins each have independent forecast data"
    - "All weather data is hourly resolution"
  artifacts:
    - path: "app/prototype/lib/openmeteo.ts"
      provides: "Open-Meteo API client with batch multi-location support"
      min_lines: 60
    - path: "app/prototype/lib/types.ts"
      provides: "TypeScript types for weather data, pins, forecasts"
      min_lines: 30
    - path: "app/prototype/components/ForecastPanel.tsx"
      provides: "Forecast cards for all pins with weather data display"
      min_lines: 100
    - path: "app/prototype/components/TimeScrubber.tsx"
      provides: "Horizontal time slider from now to +72h"
      min_lines: 60
    - path: "app/prototype/components/WeatherGrid.tsx"
      provides: "MapLibre layer showing weather model grid cells"
      min_lines: 50
  key_links:
    - from: "app/prototype/components/ForecastPanel.tsx"
      to: "app/prototype/lib/openmeteo.ts"
      via: "import weather fetching"
      pattern: "import.*openmeteo"
    - from: "app/prototype/components/TimeScrubber.tsx"
      to: "app/prototype/page.tsx"
      via: "onTimeChange callback"
      pattern: "onTimeChange"
---

<objective>
Add weather data to the prototype: fetch multi-pin forecasts from Open-Meteo, display forecast cards, add a time scrubber, and show weather model grid overlay.

Purpose: This is Step 2 of the POC. With pins already working from Plan 12-01, we now add the weather dimension. Users see actual forecast data for each pin location, can scrub through time to see how conditions change, and understand the model grid resolution through a visual overlay.

Output: Multi-pin weather comparison UI with forecast cards, time scrubber, and grid overlay.

Key architecture decisions:
- Call Open-Meteo directly from the frontend (no backend proxy for POC)
- Open-Meteo batch API: up to 1,000 locations in one call
- Hourly data: temperature_2m, wind_speed_10m, wind_gusts_10m, precipitation_probability, precipitation, weather_code, cloud_cover
- 72-hour forecast window (3 days)
- Open-Meteo auto-selects best model (HRRR 3km for US, ICON-D2 2km for Europe, etc.)
- Grid overlay is visual only â€” shows model resolution, not per-cell weather data
- Time scrubber controls which hour's data is displayed across all pins
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/12-companion-app/PROPOSAL.md
@.planning/phases/12-companion-app/RESEARCH.md

# Existing prototype files (from Plan 12-01):
@app/prototype/page.tsx
@app/prototype/components/PrototypeMap.tsx
@app/prototype/components/PinPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create weather types and Open-Meteo API client</name>
  <files>app/prototype/lib/types.ts, app/prototype/lib/openmeteo.ts</files>
  <action>
**types.ts** â€” Shared types for the prototype:

```typescript
export interface Pin {
  id: string;         // "A", "B", "C"...
  lat: number;
  lng: number;
  label: string;      // Same as id
  forecast?: PinForecast;
  loading?: boolean;
}

export interface PinForecast {
  hourly: HourlyData[];
  elevation: number;       // Model elevation in meters
  modelResolution: string; // e.g. "HRRR 3km", "GFS 13km"
  fetchedAt: Date;
}

export interface HourlyData {
  time: string;            // ISO 8601 datetime
  hoursFromNow: number;    // 0, 1, 2... 72
  temperature: number;     // Celsius
  windSpeed: number;       // km/h
  windGusts: number;       // km/h
  windDirection: number;   // degrees
  rainProbability: number; // 0-100%
  precipitation: number;   // mm
  weatherCode: number;     // WMO weather code
  cloudCover: number;      // 0-100%
}
```

**openmeteo.ts** â€” Open-Meteo API client:

1. **Batch fetch function:**
   ```typescript
   export async function fetchMultiPinWeather(
     pins: { lat: number; lng: number }[]
   ): Promise<Map<string, PinForecast>>
   ```

2. **API call construction:**
   - Base URL: `https://api.open-meteo.com/v1/forecast`
   - Parameters:
     - `latitude`: comma-separated lat values
     - `longitude`: comma-separated lng values
     - `hourly`: `temperature_2m,wind_speed_10m,wind_gusts_10m,wind_direction_10m,precipitation_probability,precipitation,weather_code,cloud_cover`
     - `forecast_hours`: 72
     - `timezone`: `auto`
   - Single fetch call with all pins (Open-Meteo supports up to 1,000)

3. **Response parsing:**
   - Open-Meteo returns array of location results when multiple coordinates
   - Parse each location's hourly data into `HourlyData[]`
   - Calculate `hoursFromNow` from each timestamp relative to current time
   - Extract `elevation` from response

4. **Model detection:** Open-Meteo doesn't directly report which model was used. Infer from location:
   - US (lat 24-50, lon -130 to -60): "HRRR 3km / GFS 13km"
   - Europe (lat 35-72, lon -25 to 45): "ICON-D2 2km"
   - Australia (lat -45 to -10, lon 110 to 155): "BOM ACCESS 2.2km"
   - Other: "GFS 13km"

5. **Weather code to condition text:** Map WMO weather codes to short descriptions:
   ```typescript
   const WMO_CODES: Record<number, string> = {
     0: 'Clear', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',
     45: 'Fog', 48: 'Rime fog',
     51: 'Light drizzle', 53: 'Drizzle', 55: 'Heavy drizzle',
     61: 'Light rain', 63: 'Rain', 65: 'Heavy rain',
     66: 'Freezing rain', 67: 'Heavy freezing rain',
     71: 'Light snow', 73: 'Snow', 75: 'Heavy snow',
     77: 'Snow grains', 80: 'Rain showers', 81: 'Mod rain showers',
     82: 'Heavy rain showers', 85: 'Snow showers', 86: 'Heavy snow showers',
     95: 'Thunderstorm', 96: 'Thunderstorm + hail', 99: 'Thunderstorm + heavy hail'
   };
   ```

6. **Error handling:** If Open-Meteo fails, set `forecast: undefined` on the pin and show error state in UI. Don't crash.

7. **Deduplication:** If two pins are within 0.01Â° (~1km), they'll get the same forecast. That's fine â€” no need to deduplicate.
  </action>
  <verify>
TypeScript compilation passes. Can be tested with a simple console.log call in the page component.
  </verify>
  <done>
Types defined for pins and forecasts. Open-Meteo client fetches batch weather for multiple locations with WMO code mapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ForecastPanel with per-pin weather cards</name>
  <files>app/prototype/components/ForecastPanel.tsx</files>
  <action>
Create the forecast display panel. This replaces/extends the PinPanel from 12-01 â€” it shows both pin coordinates AND weather data.

Props:
```typescript
interface ForecastPanelProps {
  pins: Pin[];
  currentHour: number;  // 0-72, from time scrubber
  onRemovePin: (id: string) => void;
  onClearPins: () => void;
  onCopyWxCommand: () => void;
}
```

Implementation:

1. **Layout:** Horizontal scrollable card strip at the bottom of the screen. Each pin gets a card. Cards scroll horizontally so all pins are accessible without vertical scrolling taking map space.

2. **Forecast card design (per pin):**
   ```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ [A] White Pass       â”‚  â† Pin label + nearest trail feature name (or just coords)
   â”‚ 1350m               â”‚  â† Elevation
   â”‚                     â”‚
   â”‚  â˜ï¸ 8Â°C             â”‚  â† Weather icon + temperature at currentHour
   â”‚  Wind: 25 km/h      â”‚  â† Wind speed
   â”‚  Gusts: 45 km/h     â”‚  â† Gust speed
   â”‚  Rain: 85% (2.4mm)  â”‚  â† Rain probability + precipitation amount
   â”‚  Cloud: 90%         â”‚  â† Cloud cover
   â”‚                     â”‚
   â”‚  â”€â”€ +6h â”€â”€          â”‚  â† Time indicator (how many hours from now)
   â”‚  HRRR 3km           â”‚  â† Model resolution
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ```

3. **Data source:** Each card reads from `pin.forecast.hourly[currentHour]`. If `currentHour` doesn't have data (e.g., gaps), find nearest available hour.

4. **Weather icon:** Use simple text/emoji representations based on WMO code:
   - Clear: â˜€ï¸ (code 0-1)
   - Partly cloudy: â›… (code 2)
   - Overcast: â˜ï¸ (code 3)
   - Rain: ğŸŒ§ï¸ (code 51-67, 80-82)
   - Snow: ğŸŒ¨ï¸ (code 71-77, 85-86)
   - Thunderstorm: â›ˆï¸ (code 95-99)
   - Fog: ğŸŒ«ï¸ (code 45-48)

5. **Loading state:** When `pin.loading` is true, show skeleton card with pulsing animation.

6. **Error state:** If pin has no forecast data (API failed), show "No data" with retry button.

7. **Empty state:** When no pins, show "Drop pins on the map to see forecasts".

8. **Card width:** Fixed width (180px) so cards are consistent. Each card is a snap point for horizontal scroll.

9. **Temperature display:** Show Â°C. Round to nearest integer.

10. **Wind display:** Show km/h. Include wind direction as compass bearing (N, NE, E, etc.) converted from degrees.

11. **SMS copy button:** Keep the WX command copy functionality from PinPanel â€” integrate it into the panel header.

12. **Card tap:** Tapping a card could fly the map to that pin's location (optional nice-to-have).
  </action>
  <verify>
Build passes. Cards display correctly with mock data. Cards update when currentHour changes.
  </verify>
  <done>
ForecastPanel renders horizontal scrollable forecast cards for each pin, displaying weather data at the selected hour, with loading and error states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TimeScrubber component</name>
  <files>app/prototype/components/TimeScrubber.tsx</files>
  <action>
Create a horizontal time slider that controls which hour of forecast data is displayed.

Props:
```typescript
interface TimeScrubberProps {
  currentHour: number;      // 0-72
  onHourChange: (hour: number) => void;
  maxHours: number;         // Usually 72
}
```

Implementation:

1. **Range input:** HTML `<input type="range" min="0" max="72" step="1">` as the base. Style it with Tailwind + custom CSS for the track and thumb.

2. **Time labels:** Below the slider, show key time markers:
   - "Now" at position 0
   - "+12h" at position 12
   - "+24h" (Tomorrow) at position 24
   - "+48h" at position 48
   - "+72h" at position 72

3. **Current time display:** Above the slider, show the selected time formatted as:
   - "Now" for hour 0
   - "Today 3pm" for hours 1-23
   - "Tomorrow 9am" for hours 24-47
   - "Wed 6am" for hours 48-72
   Use `Intl.DateTimeFormat` or simple date math from the current time.

4. **Day/night indicator:** Subtle background gradient on the track:
   - Light section for daylight hours (~6am-8pm)
   - Dark section for nighttime hours (~8pm-6am)
   - Helps users understand the time context

5. **Touch-friendly:** Large thumb (24px) for easy mobile dragging. Prevent page scroll while dragging the slider.

6. **Styling:** Zinc-700 track, blue-500 thumb, white text labels. Compact height (~60px total including labels).

7. **Position:** Between the map and the forecast panel. Always visible.

8. **Performance:** Use `onChange` (not `onInput`) or debounce to avoid re-rendering forecast cards on every pixel of slider movement. Actually, for smooth feel, use `onInput` but ensure the card rendering is efficient (no API calls on scrub â€” data is already loaded).
  </action>
  <verify>
Build passes. Slider moves smoothly. Time labels update correctly. Touch works on mobile viewport.
  </verify>
  <done>
TimeScrubber provides a 0-72h horizontal slider with time labels, day/night indicator, and touch-friendly interaction.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create WeatherGrid overlay for the map</name>
  <files>app/prototype/components/WeatherGrid.tsx</files>
  <action>
Create a MapLibre layer that shows the weather model grid resolution as an overlay on the map.

This is a visual reference layer that helps users understand "how big is one weather forecast cell." It does NOT show weather data per cell â€” that's a future enhancement. It shows the grid structure.

Props:
```typescript
interface WeatherGridProps {
  visible: boolean;
  center: { lat: number; lng: number };  // Center of the trail
  bounds: [number, number, number, number]; // [west, south, east, north]
  resolution: number;  // Grid cell size in km (3 for HRRR, 13 for GFS)
}
```

Implementation:

1. **Grid generation:** Generate a GeoJSON FeatureCollection of grid cell polygons covering the trail bounds.
   ```typescript
   function generateGrid(bounds, resolutionKm): GeoJSON.FeatureCollection {
     const cellSizeDeg = resolutionKm / 111; // ~111km per degree
     // Generate rectangular cells covering bounds + 1 cell padding
     // Each cell is a Polygon feature
   }
   ```
   Note: 1Â° latitude = ~111km everywhere. 1Â° longitude = ~111km * cos(latitude). Use the trail center latitude for the longitude correction.

2. **Rendering:** Use MapLibre Source + Layer:
   - Fill layer: very transparent (opacity 0.05), alternating light/dark for visibility
   - Line layer: thin grid lines (opacity 0.3, width 1, dashed)
   - Color: white lines on topo map background

3. **Performance:** Only generate grid cells visible in the current viewport bounds + small buffer. For a typical trail view at HRRR 3km resolution, this is ~100-500 cells â€” very manageable for GeoJSON rendering.

4. **Resolution label:** Show a small info badge on the map when grid is visible: "HRRR 3km grid" or "GFS 13km grid".

5. **Toggle:** The parent component controls visibility via the `visible` prop. Add a toggle button on the map (small grid icon in top-left).

6. **Latitude correction:** Grid cells should be roughly square visually, not stretched. Apply `cos(lat)` correction to longitude cell size.

7. **Integration with PrototypeMap:** This component renders inside the Map component as Source + Layer elements. Export it as a component that renders MapLibre Source/Layer children:
   ```tsx
   // Inside PrototypeMap's <Map>:
   {gridVisible && <WeatherGrid visible={gridVisible} center={...} bounds={...} resolution={3} />}
   ```
  </action>
  <verify>
Build passes. Grid overlay shows on the map when toggled on. Grid cells are approximately square at typical trail zoom levels. Grid toggle button works.
  </verify>
  <done>
WeatherGrid renders model resolution grid cells as a toggleable MapLibre overlay with resolution label.
  </done>
</task>

<task type="auto">
  <name>Task 5: Wire weather fetching into pin lifecycle and update page state</name>
  <files>app/prototype/page.tsx, app/prototype/components/PrototypeMap.tsx, app/prototype/components/PinPanel.tsx</files>
  <action>
Connect all the new components together. Update the page state to manage weather data and time.

Changes to `page.tsx`:

1. **New state:**
   ```typescript
   const [currentHour, setCurrentHour] = useState(0);
   const [gridVisible, setGridVisible] = useState(false);
   ```

2. **Pin type update:** Import `Pin` from `types.ts`. Update pin state to include forecast data.

3. **Weather fetch on pin add:**
   When `addPin(lat, lng)` is called:
   a. Add pin to state with `loading: true`
   b. Call `fetchMultiPinWeather([newPin])` â€” only fetch for the new pin (existing pins already have data)
   c. On success: update pin with forecast data, set `loading: false`
   d. On error: set `loading: false`, leave `forecast: undefined`

4. **Batch refetch:** Add a "Refresh All" button that re-fetches weather for all pins in one batch call.

5. **Updated layout:**
   ```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Trail Picker         â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚                     â”‚
   â”‚     MAP + Grid      â”‚  â† Map with optional grid overlay
   â”‚                     â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Time Scrubber       â”‚  â† 0-72h slider
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Forecast Cards      â”‚  â† Horizontal scrollable cards
   â”‚ + SMS Copy          â”‚  â† WX command copy button
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ```

6. **Grid toggle:** Add a small button in the map area (or in the header) to toggle grid visibility. Pass grid state to PrototypeMap.

Changes to `PrototypeMap.tsx`:

7. **Integrate WeatherGrid:** Add WeatherGrid as a child component inside the Map. Calculate trail bounds for the grid extent. Determine resolution based on trail location (USâ†’3km, elseâ†’13km).

8. **Grid toggle button:** Small icon button in the top-left of the map.

Changes to `PinPanel.tsx`:

9. **Replace PinPanel with ForecastPanel:** Update the import in page.tsx to use ForecastPanel instead of PinPanel. ForecastPanel handles both pin coordinates AND weather data display.

10. **Preserve SMS copy:** Ensure the WX command copy functionality is still accessible in the ForecastPanel.
  </action>
  <verify>
Full integration test: Select trail â†’ Map loads â†’ Drop pin â†’ Weather fetches â†’ Forecast card appears â†’ Scrub time â†’ Card data updates â†’ Toggle grid â†’ Grid shows. Copy WX command still works. Build passes.
  </verify>
  <done>
Weather data flows from pin drop through Open-Meteo fetch to forecast card display. Time scrubber controls displayed hour. Grid overlay toggleable. SMS copy preserved.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no errors
2. Dropping a pin triggers Open-Meteo API call and forecast card appears
3. Forecast card shows: temperature, wind, gusts, rain probability, precipitation, cloud cover
4. Time scrubber moves from 0 to 72 hours
5. Forecast cards update data when time scrubber moves
6. Weather grid overlay toggleable on/off
7. Grid shows appropriate resolution (3km for US trails, 13km for global)
8. Multiple pins each fetch independent weather data
9. WX command SMS copy still works
10. Loading states shown during weather fetch
11. Error states shown if Open-Meteo fails
</verification>

<success_criteria>
- Multi-pin weather data from Open-Meteo displays in forecast cards
- Time scrubber controls the displayed forecast hour (0-72h)
- Weather grid overlay shows model resolution
- All weather variables displayed: temp, wind, gusts, rain%, precipitation, cloud cover
- Loading and error states handled gracefully
- SMS WX command copy still functional
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-companion-app/12-02-SUMMARY.md`
</output>
