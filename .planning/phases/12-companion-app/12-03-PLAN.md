---
phase: 12-companion-app
plan: 03
type: execute
wave: 3
depends_on: [12-02]
files_modified:
  - app/prototype/lib/severity.ts
  - app/prototype/components/PrototypeMap.tsx
  - app/prototype/components/ForecastPanel.tsx
  - app/prototype/components/SatelliteSimulator.tsx
  - app/prototype/components/PayloadInspector.tsx
  - app/prototype/page.tsx
autonomous: true

must_haves:
  truths:
    - "Pins change color based on severity: green (safe), amber (caution), red (danger)"
    - "Pin colors update when the time scrubber moves"
    - "Severity thresholds based on wind, wind chill, rain probability, and precipitation"
    - "Satellite latency simulation adds configurable delay to weather requests"
    - "Payload size of weather requests/responses is measured and displayed"
    - "Forecast cards show severity badge with explanation"
  artifacts:
    - path: "app/prototype/lib/severity.ts"
      provides: "Severity calculation from weather data with configurable thresholds"
      min_lines: 40
    - path: "app/prototype/components/SatelliteSimulator.tsx"
      provides: "Toggle and controls for simulated satellite latency"
      min_lines: 40
    - path: "app/prototype/components/PayloadInspector.tsx"
      provides: "Display of request/response sizes in bytes"
      min_lines: 30
  key_links:
    - from: "app/prototype/lib/severity.ts"
      to: "app/prototype/lib/types.ts"
      via: "import HourlyData"
      pattern: "import.*HourlyData"
    - from: "app/prototype/components/PrototypeMap.tsx"
      to: "app/prototype/lib/severity.ts"
      via: "import severity calculation"
      pattern: "import.*severity"
---

<objective>
Add the decision-making layer to the POC: severity-based pin coloring, satellite latency simulation, and payload size measurement.

Purpose: This is Step 3 (final step) of the POC. Severity coloring is what makes the app a decision tool rather than just a data display ‚Äî hikers can see at a glance which trail sections are dangerous at a given time. Satellite simulation validates that the UX works under real satellite constraints (2-10 second latency). Payload inspection confirms data sizes are feasible for satellite transmission.

Output: Complete POC with color-coded severity, satellite simulation, and payload metrics.

Key architecture decisions:
- Severity is calculated client-side from the weather data already fetched
- Three levels: green (safe), amber (caution), red (danger)
- Thresholds based on the PROPOSAL.md risk table: wind, wind chill (derived), rain%, precipitation
- Wind chill calculated using the standard formula from temperature + wind speed
- Satellite simulation is a dev/testing tool ‚Äî toggle in a settings drawer
- Payload sizes measured by intercepting fetch responses
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/12-companion-app/PROPOSAL.md (severity thresholds table)
@.planning/phases/12-companion-app/RESEARCH.md

# Existing prototype files (from Plans 12-01 and 12-02):
@app/prototype/page.tsx
@app/prototype/lib/types.ts
@app/prototype/lib/openmeteo.ts
@app/prototype/components/PrototypeMap.tsx
@app/prototype/components/ForecastPanel.tsx
@app/prototype/components/TimeScrubber.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement severity calculation with configurable thresholds</name>
  <files>app/prototype/lib/severity.ts, app/prototype/lib/types.ts</files>
  <action>
Create the severity calculation module.

**severity.ts:**

1. **Severity levels:**
   ```typescript
   export type SeverityLevel = 'green' | 'amber' | 'red';

   export interface SeverityResult {
     level: SeverityLevel;
     reasons: string[];     // e.g., ["High wind: 55 km/h", "Hypothermia risk: -3¬∞C wind chill"]
     windChill: number;     // Calculated wind chill in ¬∞C
   }
   ```

2. **Wind chill calculation:** Use the standard North American wind chill formula:
   ```typescript
   export function calculateWindChill(tempC: number, windKmh: number): number {
     // Only applies when temp <= 10¬∞C and wind > 4.8 km/h
     if (tempC > 10 || windKmh <= 4.8) return tempC;
     return 13.12 + 0.6215 * tempC - 11.37 * Math.pow(windKmh, 0.16) + 0.3965 * tempC * Math.pow(windKmh, 0.16);
   }
   ```

3. **Threshold configuration (from PROPOSAL.md):**
   ```typescript
   export const DEFAULT_THRESHOLDS = {
     wind: { amber: 30, red: 50 },           // km/h
     windChill: { amber: 5, red: 0 },         // ¬∞C (below these values)
     rainProbability: { amber: 40, red: 70 },  // %
     precipitation: { red: 5 },                // mm (only triggers red when combined with high rain%)
     visibility: { amber: 5, red: 1 },         // km (not available from Open-Meteo basic, future use)
   };
   ```

4. **Severity calculation function:**
   ```typescript
   export function calculateSeverity(
     hourData: HourlyData,
     thresholds = DEFAULT_THRESHOLDS
   ): SeverityResult
   ```

   Logic:
   - Start at green
   - Check each threshold. If ANY condition is red ‚Üí overall red. If ANY is amber (and none red) ‚Üí overall amber.
   - Wind: `hourData.windSpeed >= thresholds.wind.red` ‚Üí red, `>= amber` ‚Üí amber
   - Wind gusts: `hourData.windGusts >= thresholds.wind.red * 1.2` ‚Üí red (gusts are often 20-50% above sustained)
   - Wind chill: calculate from temp + wind. `< thresholds.windChill.red` ‚Üí red, `< amber` ‚Üí amber
   - Rain: `hourData.rainProbability >= thresholds.rainProbability.red AND hourData.precipitation >= thresholds.precipitation.red` ‚Üí red. `rainProbability >= amber` ‚Üí amber.
   - Collect all triggered reasons into the `reasons` array
   - Return the highest severity level + all reasons

5. **Batch severity:** Helper that calculates severity for a full 72-hour forecast:
   ```typescript
   export function calculateHourlySeverities(
     hourlyData: HourlyData[]
   ): SeverityResult[]
   ```

6. **Update types.ts:** Add `severity?: SeverityResult` to the `HourlyData` interface or keep it computed on the fly (computed is cleaner ‚Äî no stale data).

7. **Color mapping:**
   ```typescript
   export const SEVERITY_COLORS = {
     green: { bg: '#22c55e', text: '#ffffff', label: 'Safe' },
     amber: { bg: '#f59e0b', text: '#000000', label: 'Caution' },
     red:   { bg: '#ef4444', text: '#ffffff', label: 'Danger' },
   };
   ```
  </action>
  <verify>
Write a few quick inline assertions or console.log tests:
- Wind 25 km/h, temp 15¬∞C ‚Üí green
- Wind 35 km/h, temp 3¬∞C ‚Üí amber (wind + cold)
- Wind 55 km/h, temp -2¬∞C ‚Üí red (high wind + hypothermia)
- Rain 80%, precip 8mm ‚Üí red
  </verify>
  <done>
Severity calculation module with wind chill formula, configurable thresholds, multi-factor assessment, and color mapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Color-code map pins and forecast cards by severity</name>
  <files>app/prototype/components/PrototypeMap.tsx, app/prototype/components/ForecastPanel.tsx, app/prototype/page.tsx</files>
  <action>
Integrate severity into the visual components.

**PrototypeMap.tsx changes:**

1. **Pin color by severity:** Import `calculateSeverity` and `SEVERITY_COLORS`. For each pin marker:
   - If pin has forecast data: calculate severity at `currentHour` ‚Üí use severity color for the marker
   - If pin has no data (loading/error): use default blue
   - The marker circle background changes to green/amber/red
   - The letter label stays white for contrast

2. **Pin pulse animation for red severity:** Add a subtle pulse/glow animation to red-severity pins. CSS keyframe animation with a red shadow that pulses. This draws attention to dangerous conditions.

3. **Severity updates on time scrub:** The `currentHour` prop already comes from the parent. When it changes, recalculate severity for each pin ‚Üí pins re-render with new colors. This should be efficient since severity calculation is pure math (no API calls).

**ForecastPanel.tsx changes:**

4. **Severity badge on forecast cards:** Add a colored badge at the top of each card:
   ```
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ üü¢ SAFE    [A]       ‚îÇ  ‚Üê Severity badge + pin label
   ‚îÇ OR                   ‚îÇ
   ‚îÇ üü° CAUTION [B]       ‚îÇ
   ‚îÇ OR                   ‚îÇ
   ‚îÇ üî¥ DANGER  [C]       ‚îÇ
   ```
   Badge uses severity color as background.

5. **Severity reasons tooltip:** Below the badge, show the reasons array as a compact list:
   - "Wind: 55 km/h"
   - "Wind chill: -3¬∞C"
   Only show reasons when severity is amber or red (green shows nothing ‚Äî no need to explain "safe").

6. **Card border color:** Add a left-border or top-border in the severity color to make the card's status instantly visible when scrolling.

**page.tsx changes:**

7. **Pass currentHour to PrototypeMap:** Ensure the map receives the current time scrubber hour for severity coloring.

8. **Summary bar:** Above the time scrubber, add a one-line summary:
   - "All pins safe ‚úì" (all green)
   - "2 pins caution, 1 danger ‚ö†" (mixed)
   - "3 pins danger ‚ö† ‚Äî check conditions" (all red)
  </action>
  <verify>
Drop pins on a trail. Move time scrubber. Verify:
- Pin colors change based on weather conditions at the selected hour
- Scrubbing to a stormy period should show amber/red pins
- Forecast card badges match pin colors
- Severity reasons display on amber/red cards
- Summary bar updates
  </verify>
  <done>
Pins and forecast cards are color-coded by severity. Colors update dynamically as time scrubber moves. Summary bar shows overall risk assessment.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add satellite latency simulation and payload inspector</name>
  <files>app/prototype/components/SatelliteSimulator.tsx, app/prototype/components/PayloadInspector.tsx, app/prototype/lib/openmeteo.ts, app/prototype/page.tsx</files>
  <action>
Add developer tools for validating the satellite experience.

**SatelliteSimulator.tsx:**

1. **Settings panel:** A collapsible dev tools drawer (accessed via a small satellite icon üì° in the header).

2. **Controls:**
   - **Satellite simulation toggle:** On/off switch
   - **Latency slider:** 2-10 seconds (the realistic range for satellite data)
   - **Connection type display:** Shows current simulated mode:
     - "Full connectivity" (simulation off)
     - "Satellite data" (simulation on)
     - "SMS only" (future ‚Äî not implemented yet)

3. **Visual indicator:** When satellite simulation is on, show a small persistent banner at the top:
   ```
   üì° Satellite mode ‚Äî {X}s latency
   ```
   With a subtle animation (dots cycling like a loading indicator).

**openmeteo.ts changes:**

4. **Inject latency:** Add an optional delay parameter to `fetchMultiPinWeather`:
   ```typescript
   export async function fetchMultiPinWeather(
     pins: { lat: number; lng: number }[],
     options?: { simulatedLatencyMs?: number }
   ): Promise<...>
   ```
   If `simulatedLatencyMs` is set, add `await new Promise(resolve => setTimeout(resolve, simulatedLatencyMs))` before the fetch.

5. **Measure payload sizes:** After the fetch response, measure and return payload metadata:
   ```typescript
   interface PayloadMetrics {
     requestUrl: string;
     requestSizeBytes: number;  // URL + headers approximate
     responseSizeBytes: number; // response body size
     responseTimeMs: number;    // actual API time (excluding simulated delay)
     totalTimeMs: number;       // including simulated delay
   }
   ```
   Use `response.headers.get('content-length')` or `response.text().then(t => t.length)` to measure response size.

**PayloadInspector.tsx:**

6. **Payload display panel:** Shows in the dev tools drawer (below satellite controls):
   ```
   Last request:
   ‚îú‚îÄ Request:  ~180 bytes (URL)
   ‚îú‚îÄ Response: 3,247 bytes (raw JSON)
   ‚îú‚îÄ Per pin:  ~812 bytes
   ‚îú‚îÄ API time: 340ms
   ‚îî‚îÄ Total:    5,340ms (incl. 5,000ms satellite delay)

   Satellite feasibility:
   ‚îú‚îÄ At ~4 Mbps: 6ms transfer
   ‚îú‚îÄ At ~100 kbps: 260ms transfer
   ‚îî‚îÄ Verdict: ‚úì Well within satellite bandwidth
   ```

7. **Feasibility calculation:**
   - Satellite data speed ~4 Mbps (theoretical) to ~100 kbps (realistic minimum)
   - Transfer time = responseSizeBytes * 8 / speed_bps
   - Show both theoretical and conservative estimates
   - Green/amber/red indicator: <1s green, 1-5s amber, >5s red

**page.tsx changes:**

8. **State for satellite simulation:**
   ```typescript
   const [satelliteMode, setSatelliteMode] = useState(false);
   const [satelliteLatencyMs, setSatelliteLatencyMs] = useState(5000);
   const [lastPayloadMetrics, setLastPayloadMetrics] = useState<PayloadMetrics | null>(null);
   ```

9. **Pass simulation settings to weather fetch:** When adding a pin, pass `{ simulatedLatencyMs: satelliteMode ? satelliteLatencyMs : undefined }` to `fetchMultiPinWeather`.

10. **Store payload metrics:** Save the returned metrics in state for display in PayloadInspector.

11. **Loading UX during satellite simulation:** When satellite mode is on and weather is loading:
    - Show a prominent loading overlay on the map: "üì° Fetching via satellite... Xs remaining"
    - Countdown timer based on the configured latency
    - The loading state should feel like a real satellite connection ‚Äî slow but working
  </action>
  <verify>
1. Toggle satellite mode on ‚Üí Set latency to 5s ‚Üí Drop a pin ‚Üí Verify 5-second delay before forecast appears
2. Check payload inspector shows actual byte sizes
3. Verify feasibility calculation is reasonable
4. Toggle satellite mode off ‚Üí Pin forecast loads immediately
5. Build passes
  </verify>
  <done>
Satellite simulation adds configurable latency to weather requests. Payload inspector shows request/response sizes with satellite feasibility assessment. Loading states reflect simulated satellite constraints.
  </done>
</task>

<task type="auto">
  <name>Task 4: Mobile polish and UX refinements</name>
  <files>app/prototype/page.tsx, app/prototype/components/PrototypeMap.tsx, app/prototype/components/ForecastPanel.tsx, app/prototype/components/TimeScrubber.tsx, app/prototype/components/TrailPicker.tsx</files>
  <action>
Final polish pass to ensure the POC works well on mobile devices.

1. **Responsive breakpoints:** Test and fix layout at:
   - iPhone SE (375px wide)
   - iPhone 14 Pro (393px wide)
   - iPad (768px wide)
   - Desktop (1024px+ wide)
   On desktop: side-by-side layout (map left, forecast panel right). On mobile: stacked (map top, panel bottom).

2. **Touch interactions:**
   - Map pins: large enough touch targets (min 44x44px per Apple HIG)
   - Time scrubber: fat thumb for easy dragging
   - Forecast cards: swipeable horizontal scroll with snap points
   - Trail picker: smooth scroll with momentum

3. **Viewport management:**
   - Map should not be covered by the iOS Safari bottom bar
   - Use `dvh` (dynamic viewport height) instead of `vh` where supported
   - `env(safe-area-inset-bottom)` padding for notched phones

4. **Performance:**
   - Verify no jank when scrubbing time (severity recalculation must be <16ms)
   - Trail rendering with 5000+ points should not lag (MapLibre handles this natively)
   - Limit re-renders: memoize severity calculations with `useMemo`

5. **Offline readiness indicator:** Since this is a web POC (not offline-capable), show a small indicator:
   - "Online ‚Äî weather data live" when connected
   - "Offline ‚Äî weather unavailable" when disconnected (via `navigator.onLine`)
   - The map tiles will also fail offline, but the UI should handle it gracefully

6. **Meta tags:** Add proper metadata to the page:
   ```typescript
   export const metadata = {
     title: 'Thunderbird Trail Weather ‚Äî Prototype',
     description: 'Multi-pin trail weather forecasting prototype',
   };
   ```
   Wait ‚Äî this is a client component, so use a `<Head>` or put metadata in a separate `layout.tsx` for the prototype route.

7. **Favicon/branding:** Use existing thunderbird.bot favicon. No new assets needed.

8. **Final integration test checklist** (run through manually):
   - [ ] Load /prototype on mobile
   - [ ] Select "Overland Track" from trail picker
   - [ ] Map zooms to Tasmania, trail line visible
   - [ ] Tap map to drop pin A
   - [ ] Forecast loads, card appears with weather data
   - [ ] Drop pins B and C
   - [ ] Scrub time to +24h ‚Äî pin colors may change
   - [ ] Copy WX command ‚Äî verify clipboard contents
   - [ ] Copy multi-pin WX ‚Äî verify all coordinates
   - [ ] Toggle weather grid ‚Äî grid visible at ~13km resolution
   - [ ] Enable satellite simulation ‚Äî next pin drop has delay
   - [ ] Check payload inspector ‚Äî shows byte sizes
   - [ ] Verify on desktop ‚Äî layout adapts to wider screen
  </action>
  <verify>
Run `npm run build` ‚Äî final build check. Manual test on mobile viewport in browser DevTools. All items in the integration test checklist above pass.
  </verify>
  <done>
POC is mobile-polished with responsive layout, touch-friendly interactions, safe-area handling, and performance optimizations. Full integration test passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no errors
2. Pins change color (green/amber/red) based on weather severity
3. Pin colors update dynamically as time scrubber moves
4. Severity reasons displayed on amber/red forecast cards
5. Satellite simulation toggle adds configurable delay
6. Payload inspector shows request/response sizes in bytes
7. Satellite feasibility assessment displayed (transfer time estimates)
8. Mobile layout works on iPhone-sized screens
9. Touch interactions are smooth and responsive
10. Wind chill calculated correctly from temperature + wind speed
11. Summary bar shows overall risk across all pins
12. Loading states work during both normal and satellite-simulated fetches
</verification>

<success_criteria>
- Green/amber/red severity on pins and forecast cards
- Severity updates when time scrubber moves
- Satellite simulation with configurable 2-10s latency
- Payload size measurement with feasibility assessment
- Mobile-responsive layout at all target breakpoints
- Touch-friendly interactions (44px minimum touch targets)
- Build passes
- Full integration test passes (trail ‚Üí pins ‚Üí weather ‚Üí severity ‚Üí SMS copy)
</success_criteria>

<output>
After completion, create `.planning/phases/12-companion-app/12-03-SUMMARY.md`
</output>
