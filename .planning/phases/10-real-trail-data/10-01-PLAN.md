---
phase: 10-real-trail-data
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/trail-curation/overpass-query.ts
  - scripts/trail-curation/simplify-coordinates.ts
  - scripts/trail-curation/validate-trails.ts
  - scripts/trail-curation/deduplicate-trails.ts
  - scripts/trail-curation/fetch-trail.ts
  - scripts/trail-curation/batch-fetch.ts
  - scripts/trail-curation/elevation-waypoints.ts
  - scripts/trail-curation/tsconfig.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "Running fetch-trail with a trail name returns simplified coordinates from OSM"
    - "Running validate-trails flags trails whose calculated distance is >2% shorter than official"
    - "Running deduplicate-trails removes geographic and name duplicates"
    - "Simplification reduces coordinates to 50-200 points while preserving trail shape"
    - "Running deduplicate-trails with a directory path scans all JSON files in that directory"
    - "Every fetched trail includes trailLow and trailHigh elevation waypoints automatically detected from coordinates"
  artifacts:
    - path: "scripts/trail-curation/overpass-query.ts"
      provides: "Overpass API query builder and executor for hiking routes"
      exports: ["queryOverpass", "buildTrailQuery"]
    - path: "scripts/trail-curation/simplify-coordinates.ts"
      provides: "Douglas-Peucker simplification with binary search for target point count"
      exports: ["simplifyCoordinates"]
    - path: "scripts/trail-curation/validate-trails.ts"
      provides: "Haversine distance validation against known official distances"
      exports: ["validateTrail", "validateBatch"]
    - path: "scripts/trail-curation/deduplicate-trails.ts"
      provides: "Fuzzy name matching + geographic proximity deduplication with directory scanning CLI"
      exports: ["deduplicateTrails", "deduplicateFromDirectory"]
    - path: "scripts/trail-curation/elevation-waypoints.ts"
      provides: "Detects min/max elevation points from coordinate arrays"
      exports: ["findElevationWaypoints", "ElevationWaypoint"]
    - path: "scripts/trail-curation/fetch-trail.ts"
      provides: "End-to-end single trail fetcher: query -> parse -> simplify -> validate -> elevation waypoints"
      exports: ["fetchTrail"]
    - path: "scripts/trail-curation/batch-fetch.ts"
      provides: "Batch runner that processes a trail list JSON and outputs results"
      exports: ["batchFetch"]
  key_links:
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/overpass-query.ts"
      via: "import queryOverpass"
      pattern: "import.*overpass-query"
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/simplify-coordinates.ts"
      via: "import simplifyCoordinates"
      pattern: "import.*simplify-coordinates"
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/elevation-waypoints.ts"
      via: "import findElevationWaypoints"
      pattern: "import.*elevation-waypoints"
    - from: "scripts/trail-curation/batch-fetch.ts"
      to: "scripts/trail-curation/fetch-trail.ts"
      via: "import fetchTrail"
      pattern: "import.*fetch-trail"
---

<objective>
Build the trail data curation pipeline -- a set of TypeScript scripts that can query OpenStreetMap's Overpass API for hiking trail data, simplify coordinates via Douglas-Peucker algorithm, validate trail distances against known official distances, deduplicate results, and automatically detect trailLow/trailHigh elevation waypoints.

Purpose: These scripts are the foundation for all trail data work in Phase 10. Without reliable automated tooling, curating 350+ trails with real coordinates would be impractical.

Output: A working `scripts/trail-curation/` directory with tools that can fetch any trail from OSM by name, simplify its coordinates to 50-200 points, validate accuracy, and identify the lowest and highest elevation points as named waypoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-real-trail-data/10-RESEARCH.md

# Existing trail data structure
@app/data/popularTrails.ts (first 15 lines -- TrailData interface)

# Existing scripts directory
@scripts/parse-gpx.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Overpass API query, coordinate simplification, and elevation waypoint modules</name>
  <files>
    scripts/trail-curation/overpass-query.ts
    scripts/trail-curation/simplify-coordinates.ts
    scripts/trail-curation/elevation-waypoints.ts
    scripts/trail-curation/tsconfig.json
    package.json
  </files>
  <action>
1. Install dependencies: `npm install simplify-js tsx` and `npm install -D @types/simplify-js`. tsx is needed to run TypeScript scripts directly (npx tsx script.ts).

2. Create `scripts/trail-curation/tsconfig.json` -- a standalone tsconfig for the scripts directory:
   - target: ES2020, module: ESNext, moduleResolution: bundler
   - strict: true, esModuleInterop: true
   - outDir: ./dist (not used directly -- we run via tsx)

3. Create `scripts/trail-curation/overpass-query.ts`:
   - `buildTrailQuery(trailName: string, bbox?: [number, number, number, number]): string` -- builds an Overpass QL query that searches for hiking route relations matching the trail name within an optional bounding box. Query should search `rel[route="hiking"]["name"~"${trailName}",i]` inside the bbox. Use timeout:60.
   - `queryOverpass(query: string): Promise<OverpassResponse>` -- sends the query to `https://overpass-api.de/api/interpreter` via fetch (native Node 18+ fetch). Parses JSON response. Implements retry with exponential backoff (3 attempts, 2s/4s/8s delays) for 429/5xx errors.
   - `extractCoordinates(response: OverpassResponse): [number, number, number][]` -- extracts ordered coordinates from the Overpass response. Handle both `way` members of a relation and standalone ways. Order coordinates along the route by following the member sequence. Return as [lng, lat, elevation] triplets. For elevation, default to 0 (elevation will come from the coordinate data if available, but OSM often lacks it -- this is acceptable since elevation is approximate anyway).
   - Export types: `OverpassResponse`, `OverpassElement`.
   - IMPORTANT: Overpass API returns lat/lon, but our TrailData uses [lng, lat, elevation]. Convert during extraction.
   - Handle edge cases: empty results, ways with no nodes, relations with gaps. For gaps, log a warning but still return what we have.

4. Create `scripts/trail-curation/simplify-coordinates.ts`:
   - `simplifyCoordinates(coords: [number, number, number][], targetPoints?: number): [number, number, number][]` -- uses simplify-js with Douglas-Peucker algorithm. Default targetPoints: 100. Uses binary search on tolerance to achieve target point count (within +/-20% of target). Always keep first and last points.
   - The simplify-js library expects `{x, y}` objects. Map [lng, lat, elev] to {x: lng, y: lat}, simplify, then map back and re-attach the nearest original elevation value.
   - `highQuality: true` in simplify-js options for better results.
   - If input has fewer points than target, return input unchanged.

5. Create `scripts/trail-curation/elevation-waypoints.ts`:
   - `interface ElevationWaypoint { name: string; coordinates: [number, number, number]; index: number; }` -- represents a named elevation point along the trail.
   - `findElevationWaypoints(coords: [number, number, number][]): { trailLow: ElevationWaypoint; trailHigh: ElevationWaypoint; }` -- scans the coordinate array and finds the point with the minimum elevation and the point with the maximum elevation. Returns both as named waypoints.
     - `trailLow`: the coordinate with the lowest elevation value (coords[i][2]). Name: "Trail Low Point". Stores the [lng, lat, elevation] and the index in the coordinate array.
     - `trailHigh`: the coordinate with the highest elevation value (coords[i][2]). Name: "Trail High Point". Stores the [lng, lat, elevation] and the index in the coordinate array.
     - If all elevations are 0 (OSM data lacks elevation), return both as the first coordinate with elevation 0 and set a flag `elevationDataAvailable: false` on each waypoint.
     - If multiple coordinates share the same min/max elevation, pick the first occurrence.
   - This module is intentionally simple -- it just finds min/max from the existing coordinate data. No external elevation API calls needed.
  </action>
  <verify>
Create a small test: `npx tsx scripts/trail-curation/test-query.ts` that queries for "Pacific Crest Trail" with bbox [-125, 32, -116, 49] and prints the number of coordinates returned, then simplifies to 100 points, then runs findElevationWaypoints and prints the trailLow and trailHigh. Should return coordinates, simplify successfully, and identify elevation extremes.
  </verify>
  <done>
Overpass query module can fetch trail data from OSM API and return ordered coordinates. Simplification module reduces any coordinate array to a target point count using Douglas-Peucker with binary search. Elevation waypoints module identifies the lowest and highest points along the trail from coordinate data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation, deduplication (with directory scanning), and batch processing pipeline</name>
  <files>
    scripts/trail-curation/validate-trails.ts
    scripts/trail-curation/deduplicate-trails.ts
    scripts/trail-curation/fetch-trail.ts
    scripts/trail-curation/batch-fetch.ts
  </files>
  <action>
1. Create `scripts/trail-curation/validate-trails.ts`:
   - `haversineDistance(coord1: [number, number], coord2: [number, number]): number` -- great-circle distance in km between two [lng, lat] points. Use the standard haversine formula (no library needed -- it's 10 lines of math).
   - `calculateTrailDistance(coords: [number, number, number][]): number` -- sum of haversine distances between consecutive coordinates. Returns total in km.
   - `validateTrail(trail: { name: string, coordinates: [number, number, number][], officialDistanceKm: number }): { valid: boolean, calculatedKm: number, officialKm: number, percentDiff: number, flag: string | null }` -- calculates distance, compares to official. Flag if >2% shorter. Flag reasons: "too_short" (>2% under), "too_long" (>20% over -- likely bad data), "no_official_distance" (if officialDistanceKm is 0).
   - `validateBatch(trails: TrailValidationInput[]): ValidationReport` -- runs validation on array, returns summary with pass/fail counts and flagged trails.

2. Create `scripts/trail-curation/deduplicate-trails.ts`:
   - `normalizeTrailName(name: string): string` -- lowercase, remove "trail"/"track"/"path" suffixes, trim whitespace, remove parenthetical qualifiers.
   - `levenshteinSimilarity(a: string, b: string): number` -- simple Levenshtein distance implementation (no library needed for this -- it's a standard DP algorithm), return as similarity ratio 0-1.
   - `geographicProximity(coords1: [number, number, number][], coords2: [number, number, number][]): number` -- distance in km between start points of two trails.
   - `deduplicateTrails(trails: TrailCandidate[]): { unique: TrailCandidate[], duplicates: { trail: TrailCandidate, duplicateOf: string, reason: string }[] }` -- mark as duplicate if: (a) normalized name similarity > 85% AND start points within 5km, OR (b) exact name match regardless of distance (same trail, different data). Keep the version with more coordinate points.
   - `deduplicateFromDirectory(dirPath: string): Promise<{ unique: TrailCandidate[], duplicates: {...}[] }>` -- scans all `*.json` files in the given directory, reads each file as a TrailCandidate[] (or as an object with a trails/results array), merges all trails into a single array, then runs `deduplicateTrails` on the combined set. This enables cross-region deduplication.
   - **CLI support:** When the script is run directly (`npx tsx scripts/trail-curation/deduplicate-trails.ts <path>`), detect whether `<path>` is a file or a directory:
     - If a directory: call `deduplicateFromDirectory(path)`, print results summary (total trails scanned, duplicates found, unique count)
     - If a file: read it as TrailCandidate[], call `deduplicateTrails`, print results
     - Usage: `npx tsx scripts/trail-curation/deduplicate-trails.ts scripts/trail-curation/results/`

3. Create `scripts/trail-curation/fetch-trail.ts`:
   - `interface TrailInput { name: string; searchName?: string; region: string; country: string; officialDistanceKm: number; typicalDays: string; bbox?: [number, number, number, number]; targetPoints?: number; }` -- input spec for a single trail. `searchName` is the OSM search term if different from display name.
   - `fetchTrail(input: TrailInput): Promise<TrailResult>` -- end-to-end pipeline: query Overpass (using searchName or name) -> extract coords -> simplify to targetPoints (default 100) -> validate distance -> detect elevation waypoints (trailLow/trailHigh) -> return TrailResult with all data and any flags.
   - `interface TrailResult { success: boolean; trail?: TrailData; validation?: ValidationResult; elevationWaypoints?: { trailLow: ElevationWaypoint; trailHigh: ElevationWaypoint; }; flags: string[]; error?: string; rawPointCount?: number; simplifiedPointCount?: number; }` -- includes the TrailData object ready for popularTrails.ts, plus elevation waypoints metadata and other metadata.
   - Generate the trail `id` from the name: lowercase, replace spaces with underscores, remove special characters.
   - IMPORTANT: After simplification, call `findElevationWaypoints(simplifiedCoords)` from elevation-waypoints.ts and include the result in TrailResult.elevationWaypoints.

4. Create `scripts/trail-curation/batch-fetch.ts`:
   - Reads a JSON file of TrailInput[] from a path argument (process.argv[2]).
   - Processes trails sequentially (to respect Overpass API rate limits) with a 2-second delay between requests.
   - Writes results to an output JSON file (process.argv[3] or default `trail-results-{timestamp}.json`).
   - Prints progress: "Fetching trail 1/50: Pacific Crest Trail... OK (142 points, 4265km calculated vs 4265km official, trailLow: 260m, trailHigh: 4009m)"
   - At the end, prints summary: X succeeded, Y failed, Z flagged for validation.
   - Failed trails are written to a separate `failed-trails-{timestamp}.json` for retry.
   - Each result in the output JSON includes the elevationWaypoints field (trailLow and trailHigh).
   - Usage: `npx tsx scripts/trail-curation/batch-fetch.ts trails-us.json output-us.json`
  </action>
  <verify>
1. Create a minimal test input file `scripts/trail-curation/test-input.json` with 2-3 well-known trails (e.g., Tour du Mont Blanc with bbox [5.5, 45.5, 7.5, 46.5] and officialDistanceKm 170, Milford Track with bbox [167.5, -45.0, 168.5, -44.5] and officialDistanceKm 53). Run `npx tsx scripts/trail-curation/batch-fetch.ts scripts/trail-curation/test-input.json scripts/trail-curation/test-output.json` and verify it produces output with real coordinates and elevation waypoints (trailLow/trailHigh).
2. Test directory-based dedup: `npx tsx scripts/trail-curation/deduplicate-trails.ts scripts/trail-curation/` should scan JSON files and report any duplicates found.
  </verify>
  <done>
Complete trail curation pipeline works end-to-end: can take a JSON list of trail names/metadata, query OSM, simplify coordinates, validate distances, detect trailLow/trailHigh elevation waypoints, and output results ready for integration into popularTrails.ts. Failed/flagged trails are tracked separately for manual intervention. Deduplication script supports both single-file and directory-scanning modes for cross-region duplicate detection.
  </done>
</task>

</tasks>

<verification>
1. `npx tsx scripts/trail-curation/batch-fetch.ts scripts/trail-curation/test-input.json scripts/trail-curation/test-output.json` completes without errors
2. Output JSON contains trail objects with 50-200 coordinate points each
3. Output JSON contains elevationWaypoints with trailLow and trailHigh for each trail
4. Validation report shows distance calculations within expected ranges
5. `npx tsx scripts/trail-curation/deduplicate-trails.ts scripts/trail-curation/results/` scans directory and reports results
6. `npm run build` still passes (scripts don't affect Next.js build)
</verification>

<success_criteria>
- All 7 script modules exist and are importable (overpass-query, simplify-coordinates, elevation-waypoints, validate-trails, deduplicate-trails, fetch-trail, batch-fetch)
- batch-fetch can process a trail list JSON and produce validated, simplified trail data with elevation waypoints
- Pipeline handles Overpass API failures gracefully (retry, error reporting)
- Distance validation flags trails >2% shorter than official distance
- Coordinate simplification achieves target point count within +/-20%
- Elevation waypoints (trailLow/trailHigh) are automatically detected for every fetched trail
- Deduplication supports both file and directory input for cross-region scanning
</success_criteria>

<output>
After completion, create `.planning/phases/10-real-trail-data/10-01-SUMMARY.md`
</output>
