---
phase: 10-real-trail-data
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/trail-curation/overpass-query.ts
  - scripts/trail-curation/simplify-coordinates.ts
  - scripts/trail-curation/validate-trails.ts
  - scripts/trail-curation/deduplicate-trails.ts
  - scripts/trail-curation/fallback-sources.ts
  - scripts/trail-curation/fetch-trail.ts
  - scripts/trail-curation/batch-fetch.ts
  - scripts/trail-curation/elevation-waypoints.ts
  - scripts/trail-curation/tsconfig.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "Running fetch-trail with a trail name returns simplified coordinates from OSM"
    - "When OSM validation fails (>2% distance diff), fetch-trail automatically tries fallback sources for that country before giving up"
    - "Running validate-trails flags trails whose calculated distance is >2% shorter than official"
    - "Running deduplicate-trails removes geographic and name duplicates"
    - "Simplification reduces coordinates to 50-200 points while preserving trail shape"
    - "Running deduplicate-trails with a directory path scans all JSON files in that directory"
    - "Every fetched trail includes trailLow and trailHigh elevation waypoints automatically detected from coordinates"
    - "Every fetched trail records which data source it came from (OSM, government, etc.) for attribution"
  artifacts:
    - path: "scripts/trail-curation/overpass-query.ts"
      provides: "Overpass API query builder and executor for hiking routes"
      exports: ["queryOverpass", "buildTrailQuery"]
    - path: "scripts/trail-curation/simplify-coordinates.ts"
      provides: "Douglas-Peucker simplification with binary search for target point count"
      exports: ["simplifyCoordinates"]
    - path: "scripts/trail-curation/validate-trails.ts"
      provides: "Haversine distance validation against known official distances"
      exports: ["validateTrail", "validateBatch"]
    - path: "scripts/trail-curation/deduplicate-trails.ts"
      provides: "Fuzzy name matching + geographic proximity deduplication with directory scanning CLI"
      exports: ["deduplicateTrails", "deduplicateFromDirectory"]
    - path: "scripts/trail-curation/elevation-waypoints.ts"
      provides: "Detects min/max elevation points from coordinate arrays"
      exports: ["findElevationWaypoints", "ElevationWaypoint"]
    - path: "scripts/trail-curation/fallback-sources.ts"
      provides: "Per-country prioritized fallback data source registry with concrete URLs/endpoints"
      exports: ["getFallbackSources", "fetchFromFallback", "FallbackSource"]
    - path: "scripts/trail-curation/fetch-trail.ts"
      provides: "End-to-end single trail fetcher with automatic fallback chain: OSM -> government sources -> manual flag"
      exports: ["fetchTrail"]
    - path: "scripts/trail-curation/batch-fetch.ts"
      provides: "Batch runner that processes a trail list JSON, uses fallback chain, and outputs results with source attribution"
      exports: ["batchFetch"]
  key_links:
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/overpass-query.ts"
      via: "import queryOverpass"
      pattern: "import.*overpass-query"
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/simplify-coordinates.ts"
      via: "import simplifyCoordinates"
      pattern: "import.*simplify-coordinates"
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/elevation-waypoints.ts"
      via: "import findElevationWaypoints"
      pattern: "import.*elevation-waypoints"
    - from: "scripts/trail-curation/fetch-trail.ts"
      to: "scripts/trail-curation/fallback-sources.ts"
      via: "import getFallbackSources, fetchFromFallback"
      pattern: "import.*fallback-sources"
    - from: "scripts/trail-curation/batch-fetch.ts"
      to: "scripts/trail-curation/fetch-trail.ts"
      via: "import fetchTrail"
      pattern: "import.*fetch-trail"
---

<objective>
Build the trail data curation pipeline -- a set of TypeScript scripts that can query OpenStreetMap's Overpass API for hiking trail data, automatically fall back to government/open data sources when OSM data fails validation, simplify coordinates via Douglas-Peucker algorithm, validate trail distances against known official distances, deduplicate results, and automatically detect trailLow/trailHigh elevation waypoints.

Purpose: These scripts are the foundation for all trail data work in Phase 10. Without reliable automated tooling, curating 350+ trails with real coordinates would be impractical. The fallback source chain is critical -- with ~10% of trails expected to fail OSM validation, automated fallback to government data sources reduces manual intervention from ~35 trails to a much smaller number.

Output: A working `scripts/trail-curation/` directory with tools that can fetch any trail from OSM by name, automatically retry from country-specific government sources on validation failure, simplify its coordinates to 50-200 points, validate accuracy, and identify the lowest and highest elevation points as named waypoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-real-trail-data/10-RESEARCH.md

# Existing trail data structure
@app/data/popularTrails.ts (first 15 lines -- TrailData interface)

# Existing scripts directory
@scripts/parse-gpx.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Overpass API query, coordinate simplification, elevation waypoints, and fallback data sources modules</name>
  <files>
    scripts/trail-curation/overpass-query.ts
    scripts/trail-curation/simplify-coordinates.ts
    scripts/trail-curation/elevation-waypoints.ts
    scripts/trail-curation/fallback-sources.ts
    scripts/trail-curation/tsconfig.json
    package.json
  </files>
  <action>
1. Install dependencies: `npm install simplify-js tsx` and `npm install -D @types/simplify-js`. tsx is needed to run TypeScript scripts directly (npx tsx script.ts).

2. Create `scripts/trail-curation/tsconfig.json` -- a standalone tsconfig for the scripts directory:
   - target: ES2020, module: ESNext, moduleResolution: bundler
   - strict: true, esModuleInterop: true
   - outDir: ./dist (not used directly -- we run via tsx)

3. Create `scripts/trail-curation/overpass-query.ts`:
   - `buildTrailQuery(trailName: string, bbox?: [number, number, number, number]): string` -- builds an Overpass QL query that searches for hiking route relations matching the trail name within an optional bounding box. Query should search `rel[route="hiking"]["name"~"${trailName}",i]` inside the bbox. Use timeout:60.
   - `queryOverpass(query: string): Promise<OverpassResponse>` -- sends the query to `https://overpass-api.de/api/interpreter` via fetch (native Node 18+ fetch). Parses JSON response. Implements retry with exponential backoff (3 attempts, 2s/4s/8s delays) for 429/5xx errors.
   - `extractCoordinates(response: OverpassResponse): [number, number, number][]` -- extracts ordered coordinates from the Overpass response. Handle both `way` members of a relation and standalone ways. Order coordinates along the route by following the member sequence. Return as [lng, lat, elevation] triplets. For elevation, default to 0 (elevation will come from the coordinate data if available, but OSM often lacks it -- this is acceptable since elevation is approximate anyway).
   - Export types: `OverpassResponse`, `OverpassElement`.
   - IMPORTANT: Overpass API returns lat/lon, but our TrailData uses [lng, lat, elevation]. Convert during extraction.
   - Handle edge cases: empty results, ways with no nodes, relations with gaps. For gaps, log a warning but still return what we have.

4. Create `scripts/trail-curation/simplify-coordinates.ts`:
   - `simplifyCoordinates(coords: [number, number, number][], targetPoints?: number): [number, number, number][]` -- uses simplify-js with Douglas-Peucker algorithm. Default targetPoints: 100. Uses binary search on tolerance to achieve target point count (within +/-20% of target). Always keep first and last points.
   - The simplify-js library expects `{x, y}` objects. Map [lng, lat, elev] to {x: lng, y: lat}, simplify, then map back and re-attach the nearest original elevation value.
   - `highQuality: true` in simplify-js options for better results.
   - If input has fewer points than target, return input unchanged.

5. Create `scripts/trail-curation/elevation-waypoints.ts`:
   - `interface ElevationWaypoint { name: string; coordinates: [number, number, number]; index: number; }` -- represents a named elevation point along the trail.
   - `findElevationWaypoints(coords: [number, number, number][]): { trailLow: ElevationWaypoint; trailHigh: ElevationWaypoint; }` -- scans the coordinate array and finds the point with the minimum elevation and the point with the maximum elevation. Returns both as named waypoints.
     - `trailLow`: the coordinate with the lowest elevation value (coords[i][2]). Name: "Trail Low Point". Stores the [lng, lat, elevation] and the index in the coordinate array.
     - `trailHigh`: the coordinate with the highest elevation value (coords[i][2]). Name: "Trail High Point". Stores the [lng, lat, elevation] and the index in the coordinate array.
     - If all elevations are 0 (OSM data lacks elevation), return both as the first coordinate with elevation 0 and set a flag `elevationDataAvailable: false` on each waypoint.
     - If multiple coordinates share the same min/max elevation, pick the first occurrence.
   - This module is intentionally simple -- it just finds min/max from the existing coordinate data. No external elevation API calls needed.

6. Create `scripts/trail-curation/fallback-sources.ts`:

   This module defines a per-country registry of fallback data sources to try when OSM data fails the 2% distance validation check. Each country has a prioritized list of sources. The pipeline tries them in order: OSM first (handled by overpass-query.ts), then the fallback sources defined here, then finally flags as "needs_manual_trace".

   - `interface FallbackSource { id: string; name: string; country: string; type: 'arcgis_featureserver' | 'geojson_url' | 'shapefile_url' | 'wfs' | 'gpx_download'; url: string; queryParam?: string; format: 'geojson' | 'shapefile' | 'gpx'; attribution: string; notes?: string; }` -- represents a single data source endpoint.

   - `getFallbackSources(country: string): FallbackSource[]` -- returns the ordered list of fallback sources for a given country code. Returns empty array if no fallbacks are defined for the country.

   - `fetchFromFallback(source: FallbackSource, trailName: string, bbox?: [number, number, number, number]): Promise<[number, number, number][] | null>` -- attempts to fetch trail coordinates from the given fallback source. Returns coordinates in [lng, lat, elevation] format, or null if trail not found/fetch failed. Each source type has its own fetch strategy:

     - `arcgis_featureserver`: HTTP GET to `{url}/query?where=TRAIL_NAME+LIKE+'%{trailName}%'&outFields=*&f=geojson&outSR=4326`. Parse the GeoJSON FeatureCollection, extract coordinates from the first matching feature's geometry.
     - `geojson_url`: HTTP GET the URL (may be a static file or API). Parse GeoJSON, search features for name match. Extract coordinates from matching feature.
     - `shapefile_url`: Download the .zip, use `shpjs` (npm package) to parse to GeoJSON in memory, then search features for name match. NOTE: install `shpjs` as a dependency (`npm install shpjs`).
     - `wfs`: HTTP GET `{url}?service=WFS&version=2.0.0&request=GetFeature&typeName={queryParam}&outputFormat=application/json&CQL_FILTER=name+LIKE+'%{trailName}%'`. Parse GeoJSON response.
     - `gpx_download`: HTTP GET the URL, parse XML manually (DOMParser or simple regex extraction of `<trkpt lat="..." lon="...">` elements). Convert to [lng, lat, elevation] array.

   - The per-country source registry (hardcoded data -- this is the critical part):

     **US sources:**
     ```
     {
       id: 'usfs_trails',
       name: 'USFS National Forest System Trails',
       country: 'US',
       type: 'arcgis_featureserver',
       url: 'https://apps.fs.usda.gov/arcx/rest/services/EDW/EDW_TrailNFSPublish_01/MapServer/0',
       format: 'geojson',
       attribution: 'USDA Forest Service',
       notes: 'Covers all National Forest trails. Query by TRAIL_NAME field.'
     },
     {
       id: 'nps_trails',
       name: 'NPS Trails',
       country: 'US',
       type: 'arcgis_featureserver',
       url: 'https://mapservices.nps.gov/arcgis/rest/services/NationalDatasets/NPS_Public_POIs/MapServer/0',
       format: 'geojson',
       attribution: 'National Park Service',
       notes: 'NPS points of interest including trails. Try POINAME field for trail name matching.'
     },
     {
       id: 'blm_trails',
       name: 'BLM National Recreation Trails',
       country: 'US',
       type: 'arcgis_featureserver',
       url: 'https://gis.blm.gov/arcgis/rest/services/recreation/BLM_Natl_Recreation_Trails/MapServer/0',
       format: 'geojson',
       attribution: 'Bureau of Land Management',
       notes: 'BLM-managed recreation trails on public lands.'
     }
     ```

     **Canada sources:**
     ```
     {
       id: 'parks_canada',
       name: 'Parks Canada Open Data - Trail Network',
       country: 'CA',
       type: 'geojson_url',
       url: 'https://open.canada.ca/data/en/dataset/64a90e8d-5bc0-4027-8645-b5881b4068d4',
       format: 'geojson',
       attribution: 'Parks Canada / Government of Canada',
       notes: 'National parks trail network. The dataset page links to downloadable GeoJSON/shapefile. Use the API endpoint: https://maps-cartes.ec.gc.ca/arcgis/rest/services/Parks_Canada_Trails/MapServer/0 for direct query. Query by TRAIL_E (English name) or TRAIL_F (French name).'
     },
     {
       id: 'bc_parks_trails',
       name: 'BC Parks Trails',
       country: 'CA',
       type: 'arcgis_featureserver',
       url: 'https://services6.arcgis.com/ubm4tcTYICKBpist/arcgis/rest/services/BC_Parks_Trails/FeatureServer/0',
       format: 'geojson',
       attribution: 'BC Parks / Province of British Columbia',
       notes: 'British Columbia provincial park trails. Query by TRAIL_NAME.'
     },
     {
       id: 'ontario_parks',
       name: 'Ontario Parks Trails',
       country: 'CA',
       type: 'geojson_url',
       url: 'https://geohub.lio.gov.on.ca/datasets/mnrf::ontario-trail-network/explore',
       format: 'geojson',
       attribution: 'Ontario Ministry of Natural Resources and Forestry',
       notes: 'Ontario trail network open data. Download GeoJSON from the GeoHub API: https://services1.arcgis.com/pMeXRvgWClLJZr3s/arcgis/rest/services/Ontario_Trail_Network/FeatureServer/0/query'
     }
     ```

     **Australia sources:**
     ```
     {
       id: 'tas_listmap',
       name: 'Tasmania Parks and Wildlife Tracks',
       country: 'AU',
       type: 'wfs',
       url: 'https://services.thelist.tas.gov.au/arcgis/rest/services/Public/OpenDataWFS/MapServer/WFSServer',
       queryParam: 'PWS_TRACKS',
       format: 'geojson',
       attribution: 'Tasmania Parks and Wildlife Service / theLIST',
       notes: 'Tasmania walking track data via WFS. listmap.tas.gov.au hosts this. Query by TRACK_NAME. This is the best source for Tasmanian trails not well-covered in OSM.'
     },
     {
       id: 'nsw_npws',
       name: 'NSW National Parks Walking Tracks',
       country: 'AU',
       type: 'arcgis_featureserver',
       url: 'https://mapprod3.environment.nsw.gov.au/arcgis/rest/services/Common/NPWS_Tracks/MapServer/0',
       format: 'geojson',
       attribution: 'NSW National Parks and Wildlife Service',
       notes: 'NSW national park walking tracks. Query by TRACK_NAME.'
     },
     {
       id: 'parks_victoria',
       name: 'Parks Victoria Tracks',
       country: 'AU',
       type: 'arcgis_featureserver',
       url: 'https://services.land.vic.gov.au/catalogue/publicproxy/guest/dv_geoserver/PARKS_WALKING_TRACKS/ows',
       format: 'geojson',
       attribution: 'Parks Victoria / State of Victoria',
       notes: 'Victoria state park walking tracks. Use WFS GetFeature with name filter.'
     },
     {
       id: 'qld_parks',
       name: 'Queensland Parks Walking Tracks',
       country: 'AU',
       type: 'arcgis_featureserver',
       url: 'https://spatial-gis.information.qld.gov.au/arcgis/rest/services/PlanningCadastre/LandParcelPropertyFramework/MapServer',
       format: 'geojson',
       attribution: 'Queensland Government',
       notes: 'Queensland parks recreation data. Limited trail coverage but worth trying for QLD trails.'
     }
     ```

     **New Zealand sources:**
     ```
     {
       id: 'doc_tracks',
       name: 'DOC Tracks and Routes',
       country: 'NZ',
       type: 'arcgis_featureserver',
       url: 'https://geoportal.doc.govt.nz/arcgis/rest/services/GeoportalServices/DOC_Tracks/MapServer/0',
       format: 'geojson',
       attribution: 'Department of Conservation / New Zealand Government',
       notes: 'DOC manages virtually all NZ hiking tracks. This is the authoritative source. Query by TRACK_NAME. Excellent coverage including all Great Walks.'
     },
     {
       id: 'linz_tracks',
       name: 'LINZ Topographic Track Data',
       country: 'NZ',
       type: 'wfs',
       url: 'https://data.linz.govt.nz/services/query/v1/vector.json',
       queryParam: 'layer-50329',
       format: 'geojson',
       attribution: 'Land Information New Zealand (LINZ)',
       notes: 'LINZ NZ Topo50 track centrelines (layer 50329). Use data.linz.govt.nz API. Requires free API key (set LINZ_API_KEY env var). Covers all tracks on NZ topo maps.'
     }
     ```

     **UK sources:**
     ```
     {
       id: 'os_open_roads',
       name: 'Ordnance Survey Open Data - Paths',
       country: 'GB',
       type: 'geojson_url',
       url: 'https://api.os.uk/features/v1/wfs',
       format: 'geojson',
       attribution: 'Ordnance Survey / Crown Copyright',
       notes: 'OS OpenData includes public rights of way. Requires free OS Data Hub API key (set OS_API_KEY env var). Use WFS GetFeature with path name filter.'
     },
     {
       id: 'natural_england_trails',
       name: 'Natural England National Trails',
       country: 'GB',
       type: 'geojson_url',
       url: 'https://services.arcgis.com/JJzESW51TqeY9uat/arcgis/rest/services/National_Trails_England_and_Wales/FeatureServer/0',
       format: 'geojson',
       attribution: 'Natural England',
       notes: 'The 16 official National Trails of England and Wales. Query by Trail_Name. High quality data for major routes like Pennine Way, South West Coast Path, etc.'
     }
     ```

     **France sources:**
     ```
     {
       id: 'ign_bdtopo',
       name: 'IGN BD TOPO - Sentiers',
       country: 'FR',
       type: 'wfs',
       url: 'https://data.geopf.fr/wfs/ows',
       queryParam: 'BDTOPO_V3:troncon_de_route',
       format: 'geojson',
       attribution: 'IGN (Institut national de l information geographique et forestiere)',
       notes: 'IGN BD TOPO includes hiking paths (nature=sentier). Use WFS GetFeature with CQL_FILTER on nature and toponyme fields. Free since 2021 open data policy.'
     }
     ```

     **Switzerland sources:**
     ```
     {
       id: 'swisstopo_wanderwege',
       name: 'SwissTopo Hiking Trails (Wanderwege)',
       country: 'CH',
       type: 'geojson_url',
       url: 'https://data.geo.admin.ch/api/stac/v1/collections/ch.astra.wanderland-wanderwegnetz',
       format: 'geojson',
       attribution: 'swisstopo / Swiss Confederation',
       notes: 'Official Swiss hiking network from SchweizMobil/SwissTopo. Access via STAC API at data.geo.admin.ch. The Wanderland layer contains all marked hiking trails. Download GeoJSON from the STAC item assets.'
     }
     ```

     **Italy sources:**
     ```
     {
       id: 'opendata_trentino',
       name: 'OpenData Trentino - Sentieri',
       country: 'IT',
       type: 'geojson_url',
       url: 'https://dati.trentino.it/dataset/sentieri',
       format: 'geojson',
       attribution: 'Provincia Autonoma di Trento',
       notes: 'Covers Dolomites trails in Trentino region (Alta Via 1, Alta Via 2, Tre Cime, etc.). Download GeoJSON from the dataset page API endpoint.'
     }
     ```

     **Japan sources:**
     ```
     {
       id: 'gsi_trails',
       name: 'GSI (Geospatial Information Authority) Topo Data',
       country: 'JP',
       type: 'geojson_url',
       url: 'https://cyberjapandata.gsi.go.jp/xyz/experimental_bvmap/{z}/{x}/{y}.pbf',
       format: 'geojson',
       attribution: 'Geospatial Information Authority of Japan',
       notes: 'GSI vector tiles include trail paths but require tile-based extraction. Limited trail-specific data. Better to rely on OSM for Japan (strong mapper community) and flag remaining as manual.'
     }
     ```

     **South Africa sources:**
     ```
     {
       id: 'sanparks',
       name: 'SANParks Trail Data',
       country: 'ZA',
       type: 'geojson_url',
       url: 'https://egis.environment.gov.za/geoserver/ows',
       format: 'geojson',
       attribution: 'South African National Parks / Department of Forestry, Fisheries and the Environment',
       notes: 'South Africa environmental GIS portal. Limited trail-specific data but may have park boundary and route information. Also try CapeNature data at https://www.capenature.co.za (manual download). SA trails may have highest manual intervention rate.'
     }
     ```

     **Germany sources:**
     ```
     {
       id: 'bkg_trails',
       name: 'BKG Open Data - Wanderwege',
       country: 'DE',
       type: 'wfs',
       url: 'https://sgx.geodatenzentrum.de/wfs_dlm250',
       queryParam: 'dlm250:Wanderweg',
       format: 'geojson',
       attribution: 'BKG (Bundesamt fur Kartographie und Geodasie)',
       notes: 'German Federal Agency for Cartography and Geodesy. DLM250 includes marked hiking trails (Wanderwege). Use WFS GetFeature. Germany also has excellent OSM coverage so this is mainly a fallback.'
     }
     ```

   - `tryFallbackChain(country: string, trailName: string, bbox?: [number, number, number, number]): Promise<{ coordinates: [number, number, number][] | null; source: FallbackSource | null; attemptsLog: { sourceId: string; success: boolean; error?: string }[] }>` -- tries all fallback sources for the given country in priority order. Returns the first successful result along with a log of all attempts. Returns null coordinates if all fallbacks fail.

   - IMPORTANT implementation notes:
     - Each fetch attempt should have a 30-second timeout
     - Log each attempt: `"  Trying fallback: {source.name}... {OK|FAILED: reason}"`
     - Some endpoints may require API keys (LINZ, OS). Check env vars and skip sources that need keys if not configured (with a warning: "Skipping {source.name} -- {ENV_VAR} not set")
     - GeoJSON coordinate extraction: handle both LineString and MultiLineString geometries. For MultiLineString, concatenate all line segments.
     - For shapefile sources, wrap in try/catch -- shpjs may fail on corrupt files
     - Return coordinates in the same [lng, lat, elevation] format as the Overpass module
  </action>
  <verify>
Create a small test: `npx tsx scripts/trail-curation/test-query.ts` that:
1. Queries for "Pacific Crest Trail" with bbox [-125, 32, -116, 49] and prints the number of coordinates returned, then simplifies to 100 points, then runs findElevationWaypoints and prints the trailLow and trailHigh. Should return coordinates, simplify successfully, and identify elevation extremes.
2. Calls `getFallbackSources('US')` and prints the list -- should return USFS, NPS, BLM sources.
3. Calls `getFallbackSources('NZ')` and prints the list -- should return DOC and LINZ sources.
4. Calls `getFallbackSources('XX')` for an unknown country -- should return empty array.
  </verify>
  <done>
Overpass query module can fetch trail data from OSM API and return ordered coordinates. Simplification module reduces any coordinate array to a target point count using Douglas-Peucker with binary search. Elevation waypoints module identifies the lowest and highest points along the trail from coordinate data. Fallback sources module provides a per-country registry of concrete government/open data endpoints with a tryFallbackChain function that attempts each source in priority order.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation, deduplication (with directory scanning), and batch processing pipeline with fallback integration</name>
  <files>
    scripts/trail-curation/validate-trails.ts
    scripts/trail-curation/deduplicate-trails.ts
    scripts/trail-curation/fetch-trail.ts
    scripts/trail-curation/batch-fetch.ts
  </files>
  <action>
1. Create `scripts/trail-curation/validate-trails.ts`:
   - `haversineDistance(coord1: [number, number], coord2: [number, number]): number` -- great-circle distance in km between two [lng, lat] points. Use the standard haversine formula (no library needed -- it's 10 lines of math).
   - `calculateTrailDistance(coords: [number, number, number][]): number` -- sum of haversine distances between consecutive coordinates. Returns total in km.
   - `validateTrail(trail: { name: string, coordinates: [number, number, number][], officialDistanceKm: number }): { valid: boolean, calculatedKm: number, officialKm: number, percentDiff: number, flag: string | null }` -- calculates distance, compares to official. Flag if >2% shorter. Flag reasons: "too_short" (>2% under), "too_long" (>20% over -- likely bad data), "no_official_distance" (if officialDistanceKm is 0).
   - `validateBatch(trails: TrailValidationInput[]): ValidationReport` -- runs validation on array, returns summary with pass/fail counts and flagged trails.

2. Create `scripts/trail-curation/deduplicate-trails.ts`:
   - `normalizeTrailName(name: string): string` -- lowercase, remove "trail"/"track"/"path" suffixes, trim whitespace, remove parenthetical qualifiers.
   - `levenshteinSimilarity(a: string, b: string): number` -- simple Levenshtein distance implementation (no library needed for this -- it's a standard DP algorithm), return as similarity ratio 0-1.
   - `geographicProximity(coords1: [number, number, number][], coords2: [number, number, number][]): number` -- distance in km between start points of two trails.
   - `deduplicateTrails(trails: TrailCandidate[]): { unique: TrailCandidate[], duplicates: { trail: TrailCandidate, duplicateOf: string, reason: string }[] }` -- mark as duplicate if: (a) normalized name similarity > 85% AND start points within 5km, OR (b) exact name match regardless of distance (same trail, different data). Keep the version with more coordinate points.
   - `deduplicateFromDirectory(dirPath: string): Promise<{ unique: TrailCandidate[], duplicates: {...}[] }>` -- scans all `*.json` files in the given directory, reads each file as a TrailCandidate[] (or as an object with a trails/results array), merges all trails into a single array, then runs `deduplicateTrails` on the combined set. This enables cross-region deduplication.
   - **CLI support:** When the script is run directly (`npx tsx scripts/trail-curation/deduplicate-trails.ts <path>`), detect whether `<path>` is a file or a directory:
     - If a directory: call `deduplicateFromDirectory(path)`, print results summary (total trails scanned, duplicates found, unique count)
     - If a file: read it as TrailCandidate[], call `deduplicateTrails`, print results
     - Usage: `npx tsx scripts/trail-curation/deduplicate-trails.ts scripts/trail-curation/results/`

3. Create `scripts/trail-curation/fetch-trail.ts`:
   - `interface TrailInput { name: string; searchName?: string; region: string; country: string; officialDistanceKm: number; typicalDays: string; bbox?: [number, number, number, number]; targetPoints?: number; }` -- input spec for a single trail. `searchName` is the OSM search term if different from display name.

   - `interface TrailResult { success: boolean; trail?: TrailData; validation?: ValidationResult; elevationWaypoints?: { trailLow: ElevationWaypoint; trailHigh: ElevationWaypoint; }; flags: string[]; error?: string; rawPointCount?: number; simplifiedPointCount?: number; dataSource: string; fallbackAttempts?: { sourceId: string; success: boolean; error?: string }[]; }` -- includes the TrailData object ready for popularTrails.ts, plus metadata about which source provided the data and what fallbacks were attempted.

   - `fetchTrail(input: TrailInput): Promise<TrailResult>` -- end-to-end pipeline WITH AUTOMATIC FALLBACK:
     1. Query Overpass (using searchName or name) -> extract coords -> simplify -> validate distance
     2. IF validation passes (within 2% of official distance): return result with `dataSource: 'osm'`
     3. IF validation FAILS (>2% shorter or OSM returned no data):
        a. Import `tryFallbackChain` from `fallback-sources.ts`
        b. Call `tryFallbackChain(input.country, input.searchName || input.name, input.bbox)`
        c. IF fallback returns coordinates: simplify -> validate -> detect elevation waypoints -> return result with `dataSource: fallbackSource.id` (e.g., 'usfs_trails', 'doc_tracks')
        d. IF all fallbacks also fail: return result with `success: false`, `flags: ['all_sources_exhausted']`, and the full `fallbackAttempts` log
     4. Log the decision: `"OSM validation failed for {name} ({percentDiff}% diff). Trying fallback sources..."` and `"Fallback succeeded via {source.name}"` or `"All fallback sources exhausted for {name}"`

   - Generate the trail `id` from the name: lowercase, replace spaces with underscores, remove special characters.
   - IMPORTANT: After simplification, call `findElevationWaypoints(simplifiedCoords)` from elevation-waypoints.ts and include the result in TrailResult.elevationWaypoints.
   - IMPORTANT: The `dataSource` field must always be populated -- either 'osm', a fallback source id, or 'manual' (for future manual entries).

4. Create `scripts/trail-curation/batch-fetch.ts`:
   - Reads a JSON file of TrailInput[] from a path argument (process.argv[2]).
   - Processes trails sequentially (to respect Overpass API rate limits) with a 2-second delay between requests.
   - Writes results to an output JSON file (process.argv[3] or default `trail-results-{timestamp}.json`).
   - Prints progress with source attribution: "Fetching trail 1/50: Pacific Crest Trail... OK via OSM (142 points, 4265km calculated vs 4265km official, trailLow: 260m, trailHigh: 4009m)" or "Fetching trail 5/50: Coyote Gulch... OK via USFS (fallback) (87 points, ...)" or "Fetching trail 8/50: Some Trail... FAILED (all sources exhausted)"
   - At the end, prints summary:
     ```
     === BATCH SUMMARY ===
     Total: 50
     Succeeded via OSM: 42
     Succeeded via fallback: 5 (USFS: 3, NPS: 1, BLM: 1)
     Failed (all sources exhausted): 3
     Flagged for validation: 2
     ```
   - Failed trails (after all fallbacks exhausted) are written to a separate `failed-trails-{timestamp}.json` for manual intervention.
   - Each result in the output JSON includes the `dataSource` and `fallbackAttempts` fields.
   - Usage: `npx tsx scripts/trail-curation/batch-fetch.ts trails-us.json output-us.json`
  </action>
  <verify>
1. Create a minimal test input file `scripts/trail-curation/test-input.json` with 2-3 well-known trails (e.g., Tour du Mont Blanc with bbox [5.5, 45.5, 7.5, 46.5] and officialDistanceKm 170, Milford Track with bbox [167.5, -45.0, 168.5, -44.5] and officialDistanceKm 53). Run `npx tsx scripts/trail-curation/batch-fetch.ts scripts/trail-curation/test-input.json scripts/trail-curation/test-output.json` and verify it produces output with real coordinates, elevation waypoints (trailLow/trailHigh), and `dataSource` field populated for each trail.
2. Test directory-based dedup: `npx tsx scripts/trail-curation/deduplicate-trails.ts scripts/trail-curation/` should scan JSON files and report any duplicates found.
3. Verify the batch summary includes the fallback breakdown (even if 0 fallbacks were needed for the test trails).
  </verify>
  <done>
Complete trail curation pipeline works end-to-end with automatic fallback: can take a JSON list of trail names/metadata, query OSM, automatically retry from country-specific government sources when OSM validation fails, simplify coordinates, validate distances, detect trailLow/trailHigh elevation waypoints, and output results with source attribution. Failed/flagged trails are only those where ALL sources (OSM + all country fallbacks) were exhausted -- a much smaller number than OSM-only failures. Deduplication script supports both single-file and directory-scanning modes for cross-region duplicate detection.
  </done>
</task>

</tasks>

<verification>
1. `npx tsx scripts/trail-curation/batch-fetch.ts scripts/trail-curation/test-input.json scripts/trail-curation/test-output.json` completes without errors
2. Output JSON contains trail objects with 50-200 coordinate points each
3. Output JSON contains elevationWaypoints with trailLow and trailHigh for each trail
4. Output JSON contains `dataSource` field for each trail
5. Validation report shows distance calculations within expected ranges
6. `npx tsx scripts/trail-curation/deduplicate-trails.ts scripts/trail-curation/results/` scans directory and reports results
7. `getFallbackSources('US')` returns 3 sources (USFS, NPS, BLM)
8. `getFallbackSources('NZ')` returns 2 sources (DOC, LINZ)
9. `getFallbackSources('AU')` returns 4 sources (TAS ListMap, NSW NPWS, Parks Victoria, QLD)
10. `npm run build` still passes (scripts don't affect Next.js build)
</verification>

<success_criteria>
- All 8 script modules exist and are importable (overpass-query, simplify-coordinates, elevation-waypoints, fallback-sources, validate-trails, deduplicate-trails, fetch-trail, batch-fetch)
- fallback-sources defines concrete endpoints for all 11 countries (US, CA, AU, NZ, GB, FR, CH, IT, JP, ZA, DE)
- fetch-trail automatically tries fallback sources when OSM validation fails, before flagging as failed
- batch-fetch prints source attribution for each trail (OSM vs fallback source) and a summary breakdown
- batch-fetch can process a trail list JSON and produce validated, simplified trail data with elevation waypoints and source attribution
- Pipeline handles Overpass API failures gracefully (retry, then fallback, then error reporting)
- Distance validation flags trails >2% shorter than official distance
- Coordinate simplification achieves target point count within +/-20%
- Elevation waypoints (trailLow/trailHigh) are automatically detected for every fetched trail
- Deduplication supports both file and directory input for cross-region scanning
</success_criteria>

<output>
After completion, create `.planning/phases/10-real-trail-data/10-01-SUMMARY.md`
</output>
