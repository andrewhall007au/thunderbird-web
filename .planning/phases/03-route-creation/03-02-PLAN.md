---
phase: 03-route-creation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/route_builder.py
  - backend/app/routers/routes.py
autonomous: true

must_haves:
  truths:
    - "User can upload GPX file and get parsed track data"
    - "System generates unique 5-char SMS codes from waypoint names"
    - "User can save draft route to their account"
    - "User can retrieve their saved routes"
  artifacts:
    - path: "backend/app/services/route_builder.py"
      provides: "GPX parsing, SMS code generation, route CRUD"
      exports: ["RouteBuilderService", "get_route_builder_service"]
    - path: "backend/app/routers/routes.py"
      provides: "REST API endpoints for route operations"
      exports: ["router"]
  key_links:
    - from: "backend/app/routers/routes.py"
      to: "backend/app/services/route_builder.py"
      via: "service dependency injection"
      pattern: "get_route_builder_service"
    - from: "backend/app/services/route_builder.py"
      to: "backend/app/models/custom_route.py"
      via: "store operations"
      pattern: "CustomRouteStore|CustomWaypointStore"
---

<objective>
Implement backend route builder service and API for GPX upload, parsing, and route management.

Purpose: Enable users to upload GPX files, create routes with waypoints, and save drafts - core backend for ROUT-01, ROUT-05, ROUT-06, ROUT-09.
Output: Working API endpoints for GPX upload, route CRUD, and SMS code generation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-route-creation/03-RESEARCH.md
@.planning/phases/03-route-creation/03-01-SUMMARY.md
@backend/app/services/route_builder.py
@backend/app/routers/payments.py
@backend/app/models/custom_route.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement RouteBuilderService with GPX parsing and SMS code generation</name>
  <files>backend/app/services/route_builder.py</files>
  <action>
Replace the existing stub with full implementation. Follow patterns from existing services.

1. **GPX Parsing** (using gpxpy):
```python
import gpxpy
import re
from typing import Set, Dict, List, Optional

async def parse_gpx(self, gpx_content: bytes) -> Dict:
    """
    Parse GPX file and extract route data.
    Returns dict with track_geojson, waypoints, metadata.
    """
    gpx = gpxpy.parse(gpx_content.decode('utf-8'))

    # Extract track points as GeoJSON LineString
    track_coords = []
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:
                track_coords.append([point.longitude, point.latitude])

    # Simplify if too many points (>500)
    if len(track_coords) > 500:
        track_coords = self._simplify_track(track_coords, 500)

    # Extract existing waypoints from GPX
    waypoints = []
    for wp in gpx.waypoints:
        waypoints.append({
            'name': wp.name or 'Waypoint',
            'lat': wp.latitude,
            'lng': wp.longitude,
            'elevation': wp.elevation or 0
        })

    return {
        'track_geojson': {
            'type': 'Feature',
            'geometry': {
                'type': 'LineString',
                'coordinates': track_coords
            }
        },
        'waypoints': waypoints,
        'metadata': {
            'name': gpx.name or 'Untitled Route',
            'description': gpx.description
        }
    }
```

2. **SMS Code Generation** (unique 5-char codes):
```python
def generate_sms_code(self, name: str, existing_codes: Set[str]) -> str:
    """
    Generate unique 5-char SMS code from name.
    "Lake Oberon" -> "LAKEO"
    "Mt. Hesperus" -> "HESPE"
    """
    # Remove common prefixes
    cleaned = re.sub(r'^(Mt\.?|Mount|Lake|The|Camp|Point|Peak)\s+', '', name, flags=re.IGNORECASE)
    cleaned = re.sub(r'[^A-Za-z]', '', cleaned).upper()

    # Take first 5 chars, pad if needed
    base_code = cleaned[:5].ljust(5, 'X')

    # Check for collision
    code = base_code
    suffix = 1
    while code in existing_codes or self._is_reserved_code(code):
        if suffix <= 9:
            code = base_code[:4] + str(suffix)
        else:
            code = base_code[:3] + str(suffix)
        suffix += 1

    return code

def _is_reserved_code(self, code: str) -> bool:
    """Check if code conflicts with system commands."""
    reserved = {'HELP', 'STOP', 'START', 'CAST', 'CHECK', 'ALERT'}
    return code in reserved
```

3. **Route CRUD Operations**:
- `create_route(account_id, name, gpx_data) -> CustomRoute`
- `get_route(route_id, account_id) -> Optional[CustomRoute]` (validates ownership)
- `get_routes_by_account(account_id) -> List[CustomRoute]`
- `update_route(route_id, account_id, name, status) -> Optional[CustomRoute]`
- `delete_route(route_id, account_id) -> bool`

4. **Waypoint Operations**:
- `add_waypoint(route_id, account_id, waypoint_data) -> CustomWaypoint`
- `update_waypoint(waypoint_id, account_id, data) -> Optional[CustomWaypoint]`
- `delete_waypoint(waypoint_id, account_id) -> bool`
- `reorder_waypoints(route_id, account_id, waypoint_ids) -> bool`

All methods should validate account ownership before operations.

5. **Track Simplification** (Douglas-Peucker lite):
```python
def _simplify_track(self, coords: List, target: int) -> List:
    """Simplify track to target number of points by sampling."""
    if len(coords) <= target:
        return coords
    step = len(coords) / target
    return [coords[int(i * step)] for i in range(target)]
```
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && python -c "from app.services.route_builder import get_route_builder_service; svc = get_route_builder_service(); print(svc.generate_sms_code('Lake Oberon', set()))"</verify>
  <done>Service parses GPX files, generates unique SMS codes, provides CRUD for routes and waypoints</done>
</task>

<task type="auto">
  <name>Task 2: Create routes API router with endpoints</name>
  <files>backend/app/routers/routes.py</files>
  <action>
Create new API router following patterns from payments.py.

```python
"""
Route builder API endpoints.

ROUT-01: GPX upload
ROUT-05, ROUT-06: Waypoint naming with SMS code generation
ROUT-09: Save draft routes
"""
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from pydantic import BaseModel
from typing import Optional, List

from app.services.route_builder import get_route_builder_service
from app.services.auth import get_current_account
from app.models.account import Account

router = APIRouter(prefix="/api/routes", tags=["routes"])
```

**Pydantic Models:**
- `RouteResponse`: id, name, status, waypoint_count, created_at
- `RouteDetailResponse`: RouteResponse + gpx_data, waypoints[]
- `WaypointResponse`: id, name, type, sms_code, lat, lng, elevation, order_index
- `CreateRouteRequest`: name
- `UpdateRouteRequest`: name?, status?
- `CreateWaypointRequest`: name, type, lat, lng, elevation?
- `UpdateWaypointRequest`: name?, type?, lat?, lng?, elevation?
- `ReorderWaypointsRequest`: waypoint_ids[]

**Endpoints:**

1. `POST /api/routes/upload-gpx` - Upload GPX file, parse and return data
   - Accepts: multipart/form-data with file
   - Returns: parsed track_geojson, waypoints, metadata
   - Does NOT save to database yet (preview only)

2. `POST /api/routes` - Create new route
   - Body: CreateRouteRequest + optional gpx_data
   - Returns: RouteResponse

3. `GET /api/routes` - List user's routes
   - Returns: List[RouteResponse]

4. `GET /api/routes/{route_id}` - Get route detail
   - Returns: RouteDetailResponse with waypoints

5. `PATCH /api/routes/{route_id}` - Update route
   - Body: UpdateRouteRequest
   - Returns: RouteResponse

6. `DELETE /api/routes/{route_id}` - Delete route
   - Returns: {"success": true}

7. `POST /api/routes/{route_id}/waypoints` - Add waypoint
   - Body: CreateWaypointRequest
   - Returns: WaypointResponse (includes generated sms_code)

8. `PATCH /api/routes/{route_id}/waypoints/{waypoint_id}` - Update waypoint
   - Body: UpdateWaypointRequest
   - Returns: WaypointResponse

9. `DELETE /api/routes/{route_id}/waypoints/{waypoint_id}` - Delete waypoint
   - Returns: {"success": true}

10. `POST /api/routes/{route_id}/waypoints/reorder` - Reorder waypoints
    - Body: ReorderWaypointsRequest
    - Returns: List[WaypointResponse]

All endpoints require authentication via `get_current_account` dependency.
All route endpoints validate account ownership.
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && python -c "from app.routers.routes import router; print(f'Router has {len(router.routes)} routes')"</verify>
  <done>Routes router created with all endpoints, authentication required, ownership validation</done>
</task>

<task type="auto">
  <name>Task 3: Register routes router in main app</name>
  <files>backend/main.py</files>
  <action>
Add routes router to the FastAPI application.

1. Import the router:
```python
from app.routers.routes import router as routes_router
```

2. Include the router:
```python
app.include_router(routes_router)
```

Follow the existing pattern for how other routers (auth, payments) are included.
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && python -c "from main import app; routes = [r.path for r in app.routes]; print('API routes:', [r for r in routes if '/routes' in r])"</verify>
  <done>Routes router registered, /api/routes/* endpoints accessible</done>
</task>

</tasks>

<verification>
1. GPX parsing works: Upload a test GPX file to `/api/routes/upload-gpx`
2. Route creation: POST to `/api/routes` creates route in database
3. SMS code generation: Creating waypoint returns unique 5-char code
4. All endpoints require authentication (401 without token)
5. Route ownership: Cannot access/modify another user's routes (403)
</verification>

<success_criteria>
- GPX files parse and return track coordinates + waypoints
- SMS codes generate correctly: "Lake Oberon" -> "LAKEO"
- Code collisions handled with numeric suffix
- Routes save to database with correct account_id
- CRUD operations work for routes and waypoints
- All endpoints protected by authentication
</success_criteria>

<output>
After completion, create `.planning/phases/03-route-creation/03-02-SUMMARY.md`
</output>
