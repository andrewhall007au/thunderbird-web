---
phase: 03-route-creation
plan: 07
type: execute
wave: 5
depends_on: ["03-04", "03-05", "03-06"]
files_modified:
  - backend/tests/test_route_builder.py
  - backend/tests/test_route_library.py
autonomous: false

must_haves:
  truths:
    - "All 12 ROUT requirements are testable"
    - "Backend API endpoints work correctly"
    - "Frontend route creation flow is functional"
    - "Mobile responsiveness verified on map"
  artifacts:
    - path: "backend/tests/test_route_builder.py"
      provides: "Tests for route builder service and API"
      contains: "test_.*gpx|test_.*waypoint|test_.*sms_code"
    - path: "backend/tests/test_route_library.py"
      provides: "Tests for route library service and clone"
      contains: "test_.*clone|test_.*library"
  key_links: []
---

<objective>
Write backend tests and verify complete Phase 3 functionality.

Purpose: Ensure all 12 ROUT requirements work correctly before marking phase complete.
Output: Passing test suite and human verification of UI/UX.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-route-creation/03-02-SUMMARY.md
@.planning/phases/03-route-creation/03-05-SUMMARY.md
@.planning/phases/03-route-creation/03-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write backend tests for route builder</name>
  <files>backend/tests/test_route_builder.py</files>
  <action>
Create comprehensive tests for route builder service and API.

```python
"""
Tests for route builder service and API.

Covers:
- ROUT-01: GPX upload
- ROUT-05: Waypoint naming
- ROUT-06: SMS code generation
- ROUT-09: Save draft routes
"""
import pytest
from fastapi.testclient import TestClient
from io import BytesIO

from main import app
from app.services.route_builder import RouteBuilderService


# Sample GPX content for testing
SAMPLE_GPX = """<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Test">
  <metadata><name>Test Trail</name></metadata>
  <trk>
    <name>Test Track</name>
    <trkseg>
      <trkpt lat="-42.123" lon="146.456"><ele>500</ele></trkpt>
      <trkpt lat="-42.124" lon="146.457"><ele>550</ele></trkpt>
      <trkpt lat="-42.125" lon="146.458"><ele>600</ele></trkpt>
    </trkseg>
  </trk>
  <wpt lat="-42.123" lon="146.456">
    <name>Start Point</name>
    <ele>500</ele>
  </wpt>
</gpx>"""


class TestSMSCodeGeneration:
    """Test SMS code generation algorithm (ROUT-06)."""

    def test_basic_name_to_code(self):
        service = RouteBuilderService()
        code = service.generate_sms_code("Lake Oberon", set())
        assert code == "OBERO"

    def test_removes_common_prefixes(self):
        service = RouteBuilderService()
        assert service.generate_sms_code("Mount Everest", set()) == "EVERE"
        assert service.generate_sms_code("Mt. Kosciuszko", set()) == "KOSCI"
        assert service.generate_sms_code("Camp Muir", set()) == "MUIRX"
        assert service.generate_sms_code("The Pinnacle", set()) == "PINNA"

    def test_handles_collision(self):
        service = RouteBuilderService()
        existing = {"OBERO"}
        code = service.generate_sms_code("Lake Oberon", existing)
        assert code == "OBER1"

    def test_handles_multiple_collisions(self):
        service = RouteBuilderService()
        existing = {"OBERO", "OBER1", "OBER2", "OBER3"}
        code = service.generate_sms_code("Lake Oberon", existing)
        assert code == "OBER4"

    def test_pads_short_names(self):
        service = RouteBuilderService()
        code = service.generate_sms_code("Al", set())
        assert len(code) == 5
        assert code == "ALXXX"

    def test_avoids_reserved_codes(self):
        service = RouteBuilderService()
        # "Helping Hand" would generate HELPI -> HELP1 if HELP reserved
        code = service.generate_sms_code("Help", set())
        assert code != "HELPX"  # Should avoid anything starting with HELP


class TestGPXParsing:
    """Test GPX file parsing (ROUT-01)."""

    @pytest.mark.asyncio
    async def test_parse_gpx_extracts_track(self):
        service = RouteBuilderService()
        result = await service.parse_gpx(SAMPLE_GPX.encode())

        assert 'track_geojson' in result
        assert result['track_geojson']['geometry']['type'] == 'LineString'
        coords = result['track_geojson']['geometry']['coordinates']
        assert len(coords) == 3
        # Check coordinate order (lon, lat for GeoJSON)
        assert coords[0][0] == 146.456  # longitude
        assert coords[0][1] == -42.123  # latitude

    @pytest.mark.asyncio
    async def test_parse_gpx_extracts_waypoints(self):
        service = RouteBuilderService()
        result = await service.parse_gpx(SAMPLE_GPX.encode())

        assert 'waypoints' in result
        assert len(result['waypoints']) == 1
        wp = result['waypoints'][0]
        assert wp['name'] == 'Start Point'
        assert wp['lat'] == -42.123
        assert wp['lng'] == 146.456

    @pytest.mark.asyncio
    async def test_parse_gpx_extracts_metadata(self):
        service = RouteBuilderService()
        result = await service.parse_gpx(SAMPLE_GPX.encode())

        assert result['metadata']['name'] == 'Test Trail'


class TestRouteAPI:
    """Test route API endpoints."""

    @pytest.fixture
    def client(self):
        return TestClient(app)

    @pytest.fixture
    def auth_headers(self, client):
        """Create test user and return auth headers."""
        # Register
        client.post("/api/auth/register", json={
            "email": "test@example.com",
            "password": "testpass123"
        })
        # Login
        response = client.post("/api/auth/login", json={
            "email": "test@example.com",
            "password": "testpass123"
        })
        token = response.json()["token"]
        return {"Authorization": f"Bearer {token}"}

    def test_upload_gpx_returns_parsed_data(self, client, auth_headers):
        """ROUT-01: Upload GPX file."""
        files = {"file": ("test.gpx", BytesIO(SAMPLE_GPX.encode()), "application/gpx+xml")}
        response = client.post("/api/routes/upload-gpx", files=files, headers=auth_headers)

        assert response.status_code == 200
        data = response.json()
        assert 'track_geojson' in data
        assert 'waypoints' in data

    def test_create_route_saves_to_database(self, client, auth_headers):
        """ROUT-09: Save draft route."""
        response = client.post("/api/routes", json={
            "name": "My Test Route"
        }, headers=auth_headers)

        assert response.status_code == 200
        data = response.json()
        assert data['name'] == "My Test Route"
        assert data['status'] == "draft"
        assert 'id' in data

    def test_create_route_requires_auth(self, client):
        """Routes require authentication."""
        response = client.post("/api/routes", json={"name": "Test"})
        assert response.status_code == 401

    def test_list_routes_returns_user_routes(self, client, auth_headers):
        """User can list their routes."""
        # Create a route first
        client.post("/api/routes", json={"name": "Route 1"}, headers=auth_headers)
        client.post("/api/routes", json={"name": "Route 2"}, headers=auth_headers)

        response = client.get("/api/routes", headers=auth_headers)
        assert response.status_code == 200
        routes = response.json()
        assert len(routes) >= 2

    def test_add_waypoint_generates_sms_code(self, client, auth_headers):
        """ROUT-06: SMS code auto-generated."""
        # Create route
        route = client.post("/api/routes", json={"name": "Test"}, headers=auth_headers).json()

        # Add waypoint
        response = client.post(f"/api/routes/{route['id']}/waypoints", json={
            "name": "Lake Oberon Camp",
            "type": "camp",
            "lat": -42.123,
            "lng": 146.456
        }, headers=auth_headers)

        assert response.status_code == 200
        wp = response.json()
        assert wp['sms_code'] == "OBERO"

    def test_delete_waypoint_works(self, client, auth_headers):
        """ROUT-08: Delete waypoints."""
        # Create route and waypoint
        route = client.post("/api/routes", json={"name": "Test"}, headers=auth_headers).json()
        wp = client.post(f"/api/routes/{route['id']}/waypoints", json={
            "name": "Test Point",
            "type": "poi",
            "lat": -42.0,
            "lng": 146.0
        }, headers=auth_headers).json()

        # Delete waypoint
        response = client.delete(
            f"/api/routes/{route['id']}/waypoints/{wp['id']}",
            headers=auth_headers
        )
        assert response.status_code == 200

        # Verify it's gone
        route_detail = client.get(f"/api/routes/{route['id']}", headers=auth_headers).json()
        assert len(route_detail['waypoints']) == 0
```

Run tests:
```bash
cd /Users/andrewhall/thunderbird-web/backend && pytest tests/test_route_builder.py -v
```
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && pytest tests/test_route_builder.py -v</verify>
  <done>Route builder tests pass covering GPX parsing, SMS codes, and API</done>
</task>

<task type="auto">
  <name>Task 2: Write backend tests for route library</name>
  <files>backend/tests/test_route_library.py</files>
  <action>
Create tests for route library service.

```python
"""
Tests for route library service.

Covers:
- ROUT-10: Route library displays admin-uploaded trails
- ROUT-11: User can clone and customize library routes
"""
import pytest
from fastapi.testclient import TestClient

from main import app
from app.services.route_library import RouteLibraryService
from app.models.custom_route import RouteLibraryStore


class TestRouteLibraryService:
    """Test route library service."""

    @pytest.fixture
    def library_route(self):
        """Create a test library route."""
        store = RouteLibraryStore()
        return store.create(
            name="Western Arthurs",
            description="Classic Tasmanian traverse",
            gpx_data={
                'track_geojson': {
                    'type': 'Feature',
                    'geometry': {
                        'type': 'LineString',
                        'coordinates': [[146.0, -42.0], [146.1, -42.1]]
                    }
                },
                'waypoints': [
                    {'name': 'Lake Oberon', 'lat': -42.05, 'lng': 146.05, 'elevation': 850}
                ]
            },
            country="Australia",
            region="Tasmania",
            difficulty_grade=4,
            distance_km=65.0,
            typical_days="5-7"
        )

    def test_list_active_routes(self, library_route):
        """ROUT-10: Library displays admin-uploaded trails."""
        service = RouteLibraryService()
        routes = service.list_active_routes()

        assert len(routes) >= 1
        assert any(r.name == "Western Arthurs" for r in routes)

    def test_list_routes_filter_by_country(self, library_route):
        """Can filter by country."""
        service = RouteLibraryService()

        aus_routes = service.list_active_routes(country="Australia")
        assert any(r.name == "Western Arthurs" for r in aus_routes)

        nz_routes = service.list_active_routes(country="New Zealand")
        assert not any(r.name == "Western Arthurs" for r in nz_routes)

    def test_get_route_detail(self, library_route):
        """Can get full route detail."""
        service = RouteLibraryService()
        detail = service.get_route_detail(library_route.id)

        assert detail is not None
        assert detail.name == "Western Arthurs"
        assert detail.track_geojson is not None
        assert len(detail.waypoint_preview) == 1

    def test_clone_creates_user_route(self, library_route):
        """ROUT-11: User can clone library routes."""
        service = RouteLibraryService()

        # Mock account_id
        account_id = 1

        cloned = service.clone_to_account(library_route.id, account_id)

        assert cloned is not None
        assert cloned.name == "Western Arthurs (Copy)"
        assert cloned.is_library_clone is True
        assert cloned.source_library_id == library_route.id
        assert cloned.account_id == account_id

    def test_clone_copies_waypoints(self, library_route):
        """Cloned route has waypoints with unique SMS codes."""
        service = RouteLibraryService()
        account_id = 1

        cloned = service.clone_to_account(library_route.id, account_id)

        # Get waypoints for cloned route
        from app.models.custom_route import CustomWaypointStore
        wp_store = CustomWaypointStore()
        waypoints = wp_store.get_by_route_id(cloned.id)

        assert len(waypoints) == 1
        assert waypoints[0].name == "Lake Oberon"
        assert len(waypoints[0].sms_code) == 5

    def test_cloned_route_is_independent(self, library_route):
        """Changes to cloned route don't affect library."""
        service = RouteLibraryService()
        account_id = 1

        cloned = service.clone_to_account(library_route.id, account_id)

        # Modify cloned route name
        from app.models.custom_route import CustomRouteStore
        route_store = CustomRouteStore()
        route_store.update(cloned.id, name="My Custom Arthurs")

        # Check library route unchanged
        detail = service.get_route_detail(library_route.id)
        assert detail.name == "Western Arthurs"


class TestLibraryAPI:
    """Test library API endpoints."""

    @pytest.fixture
    def client(self):
        return TestClient(app)

    @pytest.fixture
    def library_route(self):
        store = RouteLibraryStore()
        return store.create(
            name="Test Library Route",
            gpx_data={'track_geojson': None, 'waypoints': []},
            country="Australia",
            region="Tasmania"
        )

    @pytest.fixture
    def auth_headers(self, client):
        client.post("/api/auth/register", json={
            "email": "library@test.com",
            "password": "testpass123"
        })
        response = client.post("/api/auth/login", json={
            "email": "library@test.com",
            "password": "testpass123"
        })
        token = response.json()["token"]
        return {"Authorization": f"Bearer {token}"}

    def test_list_library_is_public(self, client, library_route):
        """Library list doesn't require auth."""
        response = client.get("/api/library")
        assert response.status_code == 200

    def test_get_library_route_detail(self, client, library_route):
        """Can get library route detail."""
        response = client.get(f"/api/library/{library_route.id}")
        assert response.status_code == 200
        data = response.json()
        assert data['name'] == "Test Library Route"

    def test_clone_requires_auth(self, client, library_route):
        """Clone requires authentication."""
        response = client.post(f"/api/library/{library_route.id}/clone")
        assert response.status_code == 401

    def test_clone_creates_route(self, client, library_route, auth_headers):
        """Clone creates new route for user."""
        response = client.post(
            f"/api/library/{library_route.id}/clone",
            headers=auth_headers
        )
        assert response.status_code == 200
        data = response.json()
        assert data['success'] is True
        assert 'route_id' in data

        # Verify route exists
        route_response = client.get(
            f"/api/routes/{data['route_id']}",
            headers=auth_headers
        )
        assert route_response.status_code == 200
```

Run tests:
```bash
cd /Users/andrewhall/thunderbird-web/backend && pytest tests/test_route_library.py -v
```
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && pytest tests/test_route_library.py -v</verify>
  <done>Route library tests pass covering list, detail, and clone functionality</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 3 Route Creation functionality:
- GPX file upload with parsing
- Interactive map with MapLibre GL JS
- Waypoint creation, editing, drag, delete
- Auto SMS code generation
- Save/load draft routes
- Route library with clone
- Mobile-responsive map
  </what-built>
  <how-to-verify>
1. **Start servers:**
   ```
   cd backend && uvicorn main:app --reload
   cd frontend && npm run dev
   ```

2. **Test GPX Upload (ROUT-01, ROUT-02):**
   - Go to http://localhost:3000/create
   - Drag and drop a GPX file (or click to select)
   - Verify track displays as blue line on map

3. **Test Waypoint Creation (ROUT-03, ROUT-04):**
   - Click on the map to add a waypoint
   - Verify pin appears with correct color
   - Add camp (green), peak (orange), POI (blue)

4. **Test Waypoint Editing (ROUT-05, ROUT-06, ROUT-07, ROUT-08):**
   - Click on a waypoint to select it
   - Change the name - verify SMS code updates
   - Drag waypoint to new position
   - Delete a waypoint using delete button

5. **Test Save/Load (ROUT-09):**
   - Click "Save Draft" (must be logged in)
   - Reload page with ?id=X parameter
   - Verify route and waypoints load correctly

6. **Test Route Library (ROUT-10, ROUT-11):**
   - Import a test route: `python scripts/import_library_route.py test.gpx --name "Test Trail" --country "Australia"`
   - Go to http://localhost:3000/library
   - Click on route to view details
   - Click "Clone & Customize"
   - Verify redirected to editor with copied route

7. **Test Mobile (ROUT-12):**
   - Open /create on mobile device or Chrome DevTools mobile view
   - Verify map uses two-finger zoom/pan
   - Verify single-finger scrolls page (not map)
   - Verify waypoint touch targets are usable
  </how-to-verify>
  <resume-signal>
Type "approved" if all 12 ROUT requirements work correctly.
If issues found, describe what's broken and I'll create fix plans.
  </resume-signal>
</task>

</tasks>

<verification>
Backend tests pass:
- pytest tests/test_route_builder.py -v
- pytest tests/test_route_library.py -v

All ROUT requirements manually verified:
- ROUT-01 through ROUT-12 functional
</verification>

<success_criteria>
- All backend tests pass
- Human verification approves all 12 requirements
- Phase 3 ready for integration with Phase 4 (User Flows)
</success_criteria>

<output>
After completion, create `.planning/phases/03-route-creation/03-07-SUMMARY.md`
</output>
