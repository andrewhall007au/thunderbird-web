---
phase: 03-route-creation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/custom_route.py
  - backend/alembic/versions/xxx_add_custom_routes_tables.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Custom routes and waypoints can be stored in database"
    - "SMS codes are unique across all waypoints"
    - "Route library entries exist for admin-uploaded trails"
  artifacts:
    - path: "backend/app/models/custom_route.py"
      provides: "SQLAlchemy models for CustomRoute, CustomWaypoint, RouteLibrary"
      exports: ["CustomRoute", "CustomWaypoint", "RouteLibrary", "RouteStatus", "WaypointType"]
    - path: "backend/alembic/versions/xxx_add_custom_routes_tables.py"
      provides: "Database migration for route tables"
      contains: "create_table.*custom_routes"
  key_links:
    - from: "backend/app/models/custom_route.py"
      to: "backend/app/models/account.py"
      via: "foreign key account_id"
      pattern: "ForeignKey.*accounts\\.id"
---

<objective>
Create database models and migration for custom routes, waypoints, and route library.

Purpose: Foundation for all route creation features - every subsequent plan depends on these models.
Output: SQLAlchemy models and Alembic migration for custom_routes, custom_waypoints, route_library tables.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-route-creation/03-RESEARCH.md
@backend/app/models/account.py
@backend/app/models/database.py
@backend/app/models/payments.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomRoute and CustomWaypoint SQLAlchemy models</name>
  <files>backend/app/models/custom_route.py</files>
  <action>
Create SQLAlchemy models following existing patterns from account.py and payments.py:

1. `RouteStatus` enum: draft, active, archived
2. `WaypointType` enum: camp, peak, poi

3. `CustomRoute` model:
   - id: Integer primary key
   - account_id: ForeignKey to accounts.id, nullable=False
   - name: String(255), nullable=False
   - gpx_data: JSON (parsed GPX as dict, NOT raw XML)
   - status: Enum(RouteStatus), default=draft
   - is_library_clone: Boolean, default=False
   - source_library_id: Integer, nullable (for cloned routes)
   - created_at: DateTime, default=utcnow
   - updated_at: DateTime, default=utcnow, onupdate=utcnow
   - Relationship: waypoints (one-to-many with cascade delete)

4. `CustomWaypoint` model:
   - id: Integer primary key
   - route_id: ForeignKey to custom_routes.id, nullable=False
   - type: Enum(WaypointType), default=poi
   - name: String(255), nullable=False
   - sms_code: String(5), nullable=False, indexed, UNIQUE
   - lat: Float, nullable=False
   - lng: Float, nullable=False
   - elevation: Float, default=0
   - order_index: Integer, default=0 (for waypoint ordering)
   - created_at: DateTime, default=utcnow
   - Relationship: route (many-to-one)

5. `RouteLibrary` model (admin-uploaded popular trails):
   - id: Integer primary key
   - name: String(255), nullable=False
   - description: Text
   - gpx_data: JSON
   - country: String(100)
   - region: String(255)
   - difficulty_grade: Integer (1-5)
   - distance_km: Float
   - typical_days: String(50)
   - is_active: Boolean, default=True
   - created_at: DateTime, default=utcnow
   - updated_at: DateTime

6. Add store classes with CRUD operations:
   - CustomRouteStore with get_by_id, get_by_account_id, create, update, delete
   - CustomWaypointStore with get_by_route_id, create, update, delete, check_sms_code_exists
   - RouteLibraryStore with list_active, get_by_id

Follow the SQLite connection pattern from account.py (contextmanager, row_factory).
  </action>
  <verify>python -c "from backend.app.models.custom_route import CustomRoute, CustomWaypoint, RouteLibrary, RouteStatus, WaypointType; print('Models imported successfully')"</verify>
  <done>Models importable, all fields defined, relationships configured, store classes with CRUD methods</done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for route tables</name>
  <files>backend/alembic/versions/xxx_add_custom_routes_tables.py</files>
  <action>
Create Alembic migration following the pattern from existing migrations (842752b6b27d_add_payment_tables.py):

1. Run alembic revision to generate migration file:
   ```
   cd backend && alembic revision -m "add_custom_routes_tables"
   ```

2. Edit the migration to create tables:

```python
def upgrade():
    # custom_routes table
    op.create_table(
        'custom_routes',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('account_id', sa.Integer(), sa.ForeignKey('accounts.id'), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('gpx_data', sa.JSON(), nullable=True),
        sa.Column('status', sa.String(20), default='draft'),
        sa.Column('is_library_clone', sa.Boolean(), default=False),
        sa.Column('source_library_id', sa.Integer(), nullable=True),
        sa.Column('created_at', sa.DateTime(), default=datetime.utcnow),
        sa.Column('updated_at', sa.DateTime(), default=datetime.utcnow),
    )
    op.create_index('idx_custom_routes_account', 'custom_routes', ['account_id'])

    # custom_waypoints table
    op.create_table(
        'custom_waypoints',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('route_id', sa.Integer(), sa.ForeignKey('custom_routes.id', ondelete='CASCADE'), nullable=False),
        sa.Column('type', sa.String(20), default='poi'),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('sms_code', sa.String(5), nullable=False, unique=True),
        sa.Column('lat', sa.Float(), nullable=False),
        sa.Column('lng', sa.Float(), nullable=False),
        sa.Column('elevation', sa.Float(), default=0),
        sa.Column('order_index', sa.Integer(), default=0),
        sa.Column('created_at', sa.DateTime(), default=datetime.utcnow),
    )
    op.create_index('idx_waypoints_route', 'custom_waypoints', ['route_id'])
    op.create_index('idx_waypoints_sms_code', 'custom_waypoints', ['sms_code'], unique=True)

    # route_library table
    op.create_table(
        'route_library',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('description', sa.Text()),
        sa.Column('gpx_data', sa.JSON()),
        sa.Column('country', sa.String(100)),
        sa.Column('region', sa.String(255)),
        sa.Column('difficulty_grade', sa.Integer()),
        sa.Column('distance_km', sa.Float()),
        sa.Column('typical_days', sa.String(50)),
        sa.Column('is_active', sa.Boolean(), default=True),
        sa.Column('created_at', sa.DateTime(), default=datetime.utcnow),
        sa.Column('updated_at', sa.DateTime()),
    )
    op.create_index('idx_library_active', 'route_library', ['is_active'])

def downgrade():
    op.drop_table('custom_waypoints')
    op.drop_table('custom_routes')
    op.drop_table('route_library')
```

Use SQLite-compatible types (no PostgreSQL-specific features).
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && alembic upgrade head && alembic current</verify>
  <done>Migration applies successfully, tables created with correct schema, indexes in place</done>
</task>

<task type="auto">
  <name>Task 3: Add gpxpy to backend requirements</name>
  <files>backend/requirements.txt</files>
  <action>
Add gpxpy dependency for GPX parsing (used in Plan 02):

```
# GPX Parsing
gpxpy>=1.6.0
```

Add after the existing dependencies section. This is needed for the route builder service.

Run pip install to verify it works:
```
cd backend && pip install gpxpy
```
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && pip show gpxpy</verify>
  <done>gpxpy added to requirements.txt and installable</done>
</task>

</tasks>

<verification>
1. Models import without error
2. Migration applies cleanly: `alembic upgrade head`
3. Tables exist in database: `sqlite3 thunderbird.db ".tables"` shows custom_routes, custom_waypoints, route_library
4. gpxpy is installed: `pip show gpxpy`
</verification>

<success_criteria>
- CustomRoute, CustomWaypoint, RouteLibrary models defined with all fields
- sms_code has UNIQUE constraint for collision prevention
- Migration creates all tables with proper foreign keys and indexes
- gpxpy dependency ready for Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/03-route-creation/03-01-SUMMARY.md`
</output>
