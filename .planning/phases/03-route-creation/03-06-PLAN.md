---
phase: 03-route-creation
plan: 06
type: execute
wave: 4
depends_on: ["03-02"]
files_modified:
  - backend/app/services/route_library.py
  - backend/app/routers/library.py
  - backend/scripts/import_library_route.py
  - app/library/page.tsx
  - app/create/page.tsx
autonomous: true

must_haves:
  truths:
    - "Route library displays admin-uploaded popular trails"
    - "User can view library route details"
    - "User can clone library route to their account"
    - "Cloned route is editable and independent from source"
  artifacts:
    - path: "backend/app/services/route_library.py"
      provides: "Service for library operations and cloning"
      exports: ["RouteLibraryService", "get_route_library_service"]
    - path: "backend/app/routers/library.py"
      provides: "API endpoints for route library"
      exports: ["router"]
    - path: "app/library/page.tsx"
      provides: "Route library browse page"
      min_lines: 80
  key_links:
    - from: "backend/app/routers/library.py"
      to: "backend/app/services/route_library.py"
      via: "service injection"
      pattern: "get_route_library_service"
    - from: "app/library/page.tsx"
      to: "/api/library"
      via: "fetch"
      pattern: "fetch.*api/library"
---

<objective>
Implement route library with admin-uploaded trails and user cloning.

Purpose: Enable users to browse popular trails and clone them for customization - delivers ROUT-10, ROUT-11.
Output: Route library browse UI, clone functionality, and admin import script.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-route-creation/03-RESEARCH.md
@.planning/phases/03-route-creation/03-02-SUMMARY.md
@backend/app/models/custom_route.py
@backend/app/routers/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RouteLibraryService with clone functionality</name>
  <files>backend/app/services/route_library.py</files>
  <action>
Create service for route library operations.

```python
"""
Route Library Service.

ROUT-10: Route library displays admin-uploaded popular trails
ROUT-11: User can clone and customize library routes
"""
from typing import List, Optional
from dataclasses import dataclass

from app.models.custom_route import (
    RouteLibraryStore,
    CustomRouteStore,
    CustomWaypointStore,
    RouteLibrary,
    CustomRoute,
    RouteStatus
)


@dataclass
class LibraryRouteDetail:
    """Library route with all details for display."""
    id: int
    name: str
    description: str
    country: str
    region: str
    difficulty_grade: int
    distance_km: float
    typical_days: str
    waypoint_preview: List[dict]  # First few waypoints for preview
    track_geojson: Optional[dict]


class RouteLibraryService:
    """Service for route library operations."""

    def __init__(self):
        self.library_store = RouteLibraryStore()
        self.route_store = CustomRouteStore()
        self.waypoint_store = CustomWaypointStore()

    def list_active_routes(self, country: Optional[str] = None) -> List[RouteLibrary]:
        """
        Get all active library routes, optionally filtered by country.
        """
        routes = self.library_store.list_active()
        if country:
            routes = [r for r in routes if r.country == country]
        return routes

    def get_route_detail(self, library_id: int) -> Optional[LibraryRouteDetail]:
        """
        Get detailed library route info for display.
        """
        route = self.library_store.get_by_id(library_id)
        if not route:
            return None

        # Extract waypoint preview from GPX data
        waypoint_preview = []
        if route.gpx_data and 'waypoints' in route.gpx_data:
            waypoint_preview = route.gpx_data['waypoints'][:5]  # First 5 waypoints

        # Extract track GeoJSON
        track_geojson = None
        if route.gpx_data and 'track_geojson' in route.gpx_data:
            track_geojson = route.gpx_data['track_geojson']

        return LibraryRouteDetail(
            id=route.id,
            name=route.name,
            description=route.description or '',
            country=route.country or '',
            region=route.region or '',
            difficulty_grade=route.difficulty_grade or 3,
            distance_km=route.distance_km or 0,
            typical_days=route.typical_days or '',
            waypoint_preview=waypoint_preview,
            track_geojson=track_geojson
        )

    def clone_to_account(self, library_id: int, account_id: int) -> Optional[CustomRoute]:
        """
        Clone a library route to user's account.

        Creates a new draft route with:
        - Copied GPX data
        - Copied waypoints (with new unique SMS codes)
        - is_library_clone = True
        - source_library_id set

        ROUT-11: User can clone and customize library routes
        """
        library_route = self.library_store.get_by_id(library_id)
        if not library_route:
            return None

        # Create the cloned route
        route = self.route_store.create(
            account_id=account_id,
            name=f"{library_route.name} (Copy)",
            gpx_data=library_route.gpx_data,
            is_library_clone=True,
            source_library_id=library_id
        )

        # Clone waypoints if they exist in GPX data
        if library_route.gpx_data and 'waypoints' in library_route.gpx_data:
            existing_codes = set()
            for i, wp_data in enumerate(library_route.gpx_data['waypoints']):
                # Generate unique SMS code for each waypoint
                sms_code = self._generate_sms_code(wp_data.get('name', f'WP{i+1}'), existing_codes)
                existing_codes.add(sms_code)

                self.waypoint_store.create(
                    route_id=route.id,
                    name=wp_data.get('name', f'Waypoint {i+1}'),
                    waypoint_type='poi',  # Default type, user can change
                    lat=wp_data.get('lat', 0),
                    lng=wp_data.get('lng', 0),
                    elevation=wp_data.get('elevation', 0),
                    sms_code=sms_code,
                    order_index=i
                )

        return route

    def _generate_sms_code(self, name: str, existing_codes: set) -> str:
        """Generate unique SMS code (same logic as route_builder)."""
        import re
        cleaned = re.sub(r'^(Mt\.?|Mount|Lake|The|Camp|Point|Peak)\s+', '', name, flags=re.IGNORECASE)
        cleaned = re.sub(r'[^A-Za-z]', '', cleaned).upper()
        base_code = cleaned[:5].ljust(5, 'X')

        code = base_code
        suffix = 1
        reserved = {'HELP', 'STOP', 'START', 'CAST', 'CHECK', 'ALERT'}

        while code in existing_codes or code in reserved or self.waypoint_store.check_sms_code_exists(code):
            if suffix <= 9:
                code = base_code[:4] + str(suffix)
            else:
                code = base_code[:3] + str(suffix)
            suffix += 1

        return code


# Singleton
_route_library_service: Optional[RouteLibraryService] = None


def get_route_library_service() -> RouteLibraryService:
    global _route_library_service
    if _route_library_service is None:
        _route_library_service = RouteLibraryService()
    return _route_library_service
```
  </action>
  <verify>python -c "from backend.app.services.route_library import get_route_library_service; print('Service loaded')"</verify>
  <done>RouteLibraryService with list, detail, and clone operations</done>
</task>

<task type="auto">
  <name>Task 2: Create library API router and admin import script</name>
  <files>backend/app/routers/library.py, backend/scripts/import_library_route.py</files>
  <action>
**backend/app/routers/library.py:**

```python
"""
Route Library API endpoints.

ROUT-10: Browse library routes
ROUT-11: Clone library routes
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from typing import Optional, List

from app.services.route_library import get_route_library_service
from app.services.auth import get_current_account
from app.models.account import Account

router = APIRouter(prefix="/api/library", tags=["library"])


class LibraryRouteResponse(BaseModel):
    id: int
    name: str
    description: Optional[str] = None
    country: Optional[str] = None
    region: Optional[str] = None
    difficulty_grade: Optional[int] = None
    distance_km: Optional[float] = None
    typical_days: Optional[str] = None


class LibraryRouteDetailResponse(LibraryRouteResponse):
    waypoint_preview: List[dict] = []
    track_geojson: Optional[dict] = None


class CloneResponse(BaseModel):
    success: bool
    route_id: int
    message: str


@router.get("", response_model=List[LibraryRouteResponse])
async def list_library_routes(
    country: Optional[str] = Query(None, description="Filter by country")
):
    """
    List all active library routes.
    No authentication required - public endpoint.
    """
    service = get_route_library_service()
    routes = service.list_active_routes(country=country)

    return [
        LibraryRouteResponse(
            id=r.id,
            name=r.name,
            description=r.description,
            country=r.country,
            region=r.region,
            difficulty_grade=r.difficulty_grade,
            distance_km=r.distance_km,
            typical_days=r.typical_days
        )
        for r in routes
    ]


@router.get("/{library_id}", response_model=LibraryRouteDetailResponse)
async def get_library_route(library_id: int):
    """
    Get detailed library route info including track preview.
    No authentication required - public endpoint.
    """
    service = get_route_library_service()
    detail = service.get_route_detail(library_id)

    if not detail:
        raise HTTPException(status_code=404, detail="Library route not found")

    return LibraryRouteDetailResponse(
        id=detail.id,
        name=detail.name,
        description=detail.description,
        country=detail.country,
        region=detail.region,
        difficulty_grade=detail.difficulty_grade,
        distance_km=detail.distance_km,
        typical_days=detail.typical_days,
        waypoint_preview=detail.waypoint_preview,
        track_geojson=detail.track_geojson
    )


@router.post("/{library_id}/clone", response_model=CloneResponse)
async def clone_library_route(
    library_id: int,
    account: Account = Depends(get_current_account)
):
    """
    Clone a library route to user's account.
    Creates a new draft route that the user can customize.
    """
    service = get_route_library_service()
    route = service.clone_to_account(library_id, account.id)

    if not route:
        raise HTTPException(status_code=404, detail="Library route not found")

    return CloneResponse(
        success=True,
        route_id=route.id,
        message=f"Route cloned successfully. Edit at /create?id={route.id}"
    )
```

Register router in main.py (add with other routers):
```python
from app.routers.library import router as library_router
app.include_router(library_router)
```

**backend/scripts/import_library_route.py:**

```python
#!/usr/bin/env python3
"""
Import GPX file to route library (admin use).

Usage:
    python import_library_route.py path/to/route.gpx --name "Western Arthurs" --country "Australia" --region "Tasmania"
"""
import argparse
import sys
from pathlib import Path

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

import gpxpy
from app.models.custom_route import RouteLibraryStore


def parse_gpx(gpx_content: str) -> dict:
    """Parse GPX file to structured data."""
    gpx = gpxpy.parse(gpx_content)

    # Extract track
    track_coords = []
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:
                track_coords.append([point.longitude, point.latitude])

    # Extract waypoints
    waypoints = []
    for wp in gpx.waypoints:
        waypoints.append({
            'name': wp.name or 'Waypoint',
            'lat': wp.latitude,
            'lng': wp.longitude,
            'elevation': wp.elevation or 0
        })

    return {
        'track_geojson': {
            'type': 'Feature',
            'geometry': {
                'type': 'LineString',
                'coordinates': track_coords
            }
        },
        'waypoints': waypoints,
        'metadata': {
            'name': gpx.name,
            'description': gpx.description
        }
    }


def main():
    parser = argparse.ArgumentParser(description='Import GPX to route library')
    parser.add_argument('gpx_file', help='Path to GPX file')
    parser.add_argument('--name', required=True, help='Route name')
    parser.add_argument('--description', default='', help='Route description')
    parser.add_argument('--country', required=True, help='Country')
    parser.add_argument('--region', default='', help='Region')
    parser.add_argument('--difficulty', type=int, default=3, help='Difficulty 1-5')
    parser.add_argument('--distance', type=float, help='Distance in km')
    parser.add_argument('--days', default='', help='Typical days (e.g., "5-7")')

    args = parser.parse_args()

    # Read and parse GPX
    gpx_path = Path(args.gpx_file)
    if not gpx_path.exists():
        print(f"Error: File not found: {gpx_path}")
        sys.exit(1)

    print(f"Parsing {gpx_path}...")
    gpx_content = gpx_path.read_text()
    gpx_data = parse_gpx(gpx_content)

    # Calculate distance if not provided
    distance = args.distance
    if distance is None and gpx_data['track_geojson']['geometry']['coordinates']:
        # Rough distance estimate from track points
        coords = gpx_data['track_geojson']['geometry']['coordinates']
        distance = len(coords) * 0.05  # Very rough estimate
        print(f"Estimated distance: {distance:.1f} km")

    # Create library entry
    store = RouteLibraryStore()
    route = store.create(
        name=args.name,
        description=args.description,
        gpx_data=gpx_data,
        country=args.country,
        region=args.region,
        difficulty_grade=args.difficulty,
        distance_km=distance,
        typical_days=args.days
    )

    print(f"Created library route: {route.name} (ID: {route.id})")
    print(f"  Country: {route.country}")
    print(f"  Region: {route.region}")
    print(f"  Waypoints: {len(gpx_data.get('waypoints', []))}")
    print(f"  Track points: {len(gpx_data['track_geojson']['geometry']['coordinates'])}")


if __name__ == '__main__':
    main()
```

Make script executable:
```bash
chmod +x backend/scripts/import_library_route.py
```

Create scripts directory if needed:
```bash
mkdir -p backend/scripts
```
  </action>
  <verify>cd /Users/andrewhall/thunderbird-web/backend && python -c "from app.routers.library import router; print(f'{len(router.routes)} routes')"</verify>
  <done>Library API router created, admin import script ready</done>
</task>

<task type="auto">
  <name>Task 3: Create route library browse page</name>
  <files>app/library/page.tsx, app/lib/api.ts</files>
  <action>
**Add library API functions to app/lib/api.ts:**

```typescript
// Add to existing api.ts

export interface LibraryRouteResponse {
  id: number;
  name: string;
  description?: string;
  country?: string;
  region?: string;
  difficulty_grade?: number;
  distance_km?: number;
  typical_days?: string;
}

export interface LibraryRouteDetailResponse extends LibraryRouteResponse {
  waypoint_preview: Array<{ name: string; lat: number; lng: number }>;
  track_geojson?: GeoJSON.Feature;
}

export async function getLibraryRoutes(country?: string): Promise<LibraryRouteResponse[]> {
  const url = country
    ? `/api/library?country=${encodeURIComponent(country)}`
    : '/api/library';
  return apiRequest(url);
}

export async function getLibraryRoute(id: number): Promise<LibraryRouteDetailResponse> {
  return apiRequest(`/api/library/${id}`);
}

export async function cloneLibraryRoute(id: number): Promise<{ success: boolean; route_id: number }> {
  return apiRequest(`/api/library/${id}/clone`, { method: 'POST' });
}
```

**app/library/page.tsx:**

```typescript
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import dynamic from 'next/dynamic';
import { useRouter } from 'next/navigation';
import {
  getLibraryRoutes,
  getLibraryRoute,
  cloneLibraryRoute,
  LibraryRouteResponse,
  LibraryRouteDetailResponse
} from '../lib/api';
import { Map, Mountain, Clock, Ruler, Copy, X, ChevronRight } from 'lucide-react';

// Dynamic import for map preview
const MapEditor = dynamic(() => import('../components/map/MapEditor'), {
  ssr: false,
  loading: () => <div className="h-64 bg-gray-800 rounded-lg animate-pulse" />
});

const DIFFICULTY_LABELS = ['Easy', 'Moderate', 'Challenging', 'Difficult', 'Expert'];

export default function LibraryPage() {
  const router = useRouter();
  const [routes, setRoutes] = useState<LibraryRouteResponse[]>([]);
  const [selectedRoute, setSelectedRoute] = useState<LibraryRouteDetailResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isCloning, setIsCloning] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadRoutes();
  }, []);

  async function loadRoutes() {
    try {
      const data = await getLibraryRoutes();
      setRoutes(data);
    } catch (e) {
      setError('Failed to load route library');
    } finally {
      setIsLoading(false);
    }
  }

  async function handleSelectRoute(id: number) {
    try {
      const detail = await getLibraryRoute(id);
      setSelectedRoute(detail);
    } catch (e) {
      setError('Failed to load route details');
    }
  }

  async function handleClone() {
    if (!selectedRoute) return;

    setIsCloning(true);
    try {
      const result = await cloneLibraryRoute(selectedRoute.id);
      router.push(`/create?id=${result.route_id}`);
    } catch (e) {
      setError('Failed to clone route. Please log in first.');
      setIsCloning(false);
    }
  }

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-950 text-white p-8">
        <div className="max-w-6xl mx-auto animate-pulse space-y-4">
          <div className="h-8 bg-gray-800 rounded w-1/3"></div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {[1, 2, 3].map(i => (
              <div key={i} className="h-48 bg-gray-800 rounded-lg"></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-950 text-white">
      <div className="max-w-6xl mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-2">Route Library</h1>
        <p className="text-gray-400 mb-8">
          Browse popular trails and clone them to create your own custom route
        </p>

        {error && (
          <div className="mb-6 p-4 bg-red-900/50 border border-red-500 rounded-lg text-red-200">
            {error}
            <button onClick={() => setError(null)} className="ml-4 underline">Dismiss</button>
          </div>
        )}

        {routes.length === 0 ? (
          <div className="text-center py-12 bg-gray-900 rounded-lg">
            <Map className="w-16 h-16 mx-auto mb-4 text-gray-600" />
            <h2 className="text-xl font-semibold text-gray-300 mb-2">No routes in library yet</h2>
            <p className="text-gray-500 mb-6">Check back soon or create your own route</p>
            <Link
              href="/create"
              className="inline-flex items-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-500"
            >
              Create Route
            </Link>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {routes.map((route) => (
              <button
                key={route.id}
                onClick={() => handleSelectRoute(route.id)}
                className="text-left p-4 bg-gray-900 rounded-lg hover:bg-gray-800/50 transition-colors group"
              >
                <h2 className="text-lg font-semibold text-white group-hover:text-blue-400 transition-colors">
                  {route.name}
                </h2>
                <p className="text-sm text-gray-500 mt-1">
                  {route.region}, {route.country}
                </p>

                <div className="flex items-center gap-4 mt-4 text-sm text-gray-400">
                  {route.distance_km && (
                    <span className="flex items-center gap-1">
                      <Ruler className="w-4 h-4" />
                      {route.distance_km.toFixed(0)} km
                    </span>
                  )}
                  {route.typical_days && (
                    <span className="flex items-center gap-1">
                      <Clock className="w-4 h-4" />
                      {route.typical_days} days
                    </span>
                  )}
                  {route.difficulty_grade && (
                    <span className="flex items-center gap-1">
                      <Mountain className="w-4 h-4" />
                      {DIFFICULTY_LABELS[route.difficulty_grade - 1] || 'Unknown'}
                    </span>
                  )}
                </div>

                <div className="mt-4 flex items-center text-blue-400 text-sm opacity-0 group-hover:opacity-100 transition-opacity">
                  View details <ChevronRight className="w-4 h-4" />
                </div>
              </button>
            ))}
          </div>
        )}

        {/* Route Detail Modal */}
        {selectedRoute && (
          <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
            <div className="bg-gray-900 rounded-xl max-w-3xl w-full max-h-[90vh] overflow-y-auto">
              <div className="p-6">
                <div className="flex items-start justify-between mb-4">
                  <div>
                    <h2 className="text-2xl font-bold text-white">{selectedRoute.name}</h2>
                    <p className="text-gray-400">
                      {selectedRoute.region}, {selectedRoute.country}
                    </p>
                  </div>
                  <button
                    onClick={() => setSelectedRoute(null)}
                    className="p-2 text-gray-400 hover:text-white"
                  >
                    <X className="w-6 h-6" />
                  </button>
                </div>

                {selectedRoute.description && (
                  <p className="text-gray-300 mb-6">{selectedRoute.description}</p>
                )}

                <div className="flex flex-wrap gap-4 mb-6 text-sm">
                  {selectedRoute.distance_km && (
                    <div className="px-3 py-2 bg-gray-800 rounded-lg">
                      <span className="text-gray-400">Distance:</span>{' '}
                      <span className="text-white">{selectedRoute.distance_km.toFixed(0)} km</span>
                    </div>
                  )}
                  {selectedRoute.typical_days && (
                    <div className="px-3 py-2 bg-gray-800 rounded-lg">
                      <span className="text-gray-400">Duration:</span>{' '}
                      <span className="text-white">{selectedRoute.typical_days} days</span>
                    </div>
                  )}
                  {selectedRoute.difficulty_grade && (
                    <div className="px-3 py-2 bg-gray-800 rounded-lg">
                      <span className="text-gray-400">Difficulty:</span>{' '}
                      <span className="text-white">{DIFFICULTY_LABELS[selectedRoute.difficulty_grade - 1]}</span>
                    </div>
                  )}
                </div>

                {/* Map Preview */}
                {selectedRoute.track_geojson && (
                  <div className="mb-6 h-64 rounded-lg overflow-hidden">
                    <MapEditor trackGeojson={selectedRoute.track_geojson} />
                  </div>
                )}

                {/* Waypoint Preview */}
                {selectedRoute.waypoint_preview.length > 0 && (
                  <div className="mb-6">
                    <h3 className="text-sm font-medium text-gray-400 uppercase tracking-wider mb-2">
                      Key Waypoints
                    </h3>
                    <ul className="space-y-1 text-sm text-gray-300">
                      {selectedRoute.waypoint_preview.map((wp, i) => (
                        <li key={i}>&bull; {wp.name}</li>
                      ))}
                    </ul>
                  </div>
                )}

                {/* Clone Button */}
                <button
                  onClick={handleClone}
                  disabled={isCloning}
                  className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Copy className="w-5 h-5" />
                  {isCloning ? 'Cloning...' : 'Clone & Customize'}
                </button>
                <p className="text-center text-sm text-gray-500 mt-2">
                  Creates a copy you can edit and customize
                </p>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
```

Create directory:
```bash
mkdir -p app/library
```
  </action>
  <verify>npm run dev, visit /library, verify routes display (may be empty initially), modal opens on click, clone redirects to editor</verify>
  <done>Library browse page with route cards, detail modal, and clone button</done>
</task>

</tasks>

<verification>
1. GET /api/library returns list of active library routes
2. GET /api/library/{id} returns route detail with track preview
3. POST /api/library/{id}/clone creates new route in user's account
4. /library page displays route cards with info
5. Clicking card shows detail modal with map preview
6. Clone button creates copy and redirects to editor
7. import_library_route.py script works to add routes
</verification>

<success_criteria>
- ROUT-10: Route library displays admin-uploaded popular trails
- ROUT-11: User can clone and customize library routes
- Cloned routes are independent (changes don't affect library)
- Admin can add routes via CLI script
</success_criteria>

<output>
After completion, create `.planning/phases/03-route-creation/03-06-SUMMARY.md`
</output>
