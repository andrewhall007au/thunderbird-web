---
phase: 03-route-creation
plan: 05
type: execute
wave: 4
depends_on: ["03-02", "03-04"]
files_modified:
  - app/create/page.tsx
  - app/lib/api.ts
  - app/hooks/useAuth.ts
autonomous: true

must_haves:
  truths:
    - "User can save draft route to their account"
    - "Saved routes persist across page reloads"
    - "User can load and continue editing saved routes"
    - "Save requires authentication"
  artifacts:
    - path: "app/lib/api.ts"
      provides: "API client for route operations"
      exports: ["saveRoute", "loadRoute", "uploadGPX"]
    - path: "app/create/page.tsx"
      provides: "Save/load functionality integrated"
      contains: "saveRoute|handleSave"
  key_links:
    - from: "app/create/page.tsx"
      to: "app/lib/api.ts"
      via: "API calls"
      pattern: "saveRoute|loadRoute"
    - from: "app/lib/api.ts"
      to: "/api/routes"
      via: "fetch"
      pattern: "fetch.*api/routes"
---

<objective>
Connect frontend route editor to backend API for saving and loading draft routes.

Purpose: Enable users to save their route progress and continue editing later - delivers ROUT-09.
Output: Full save/load workflow with authentication integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-route-creation/03-02-SUMMARY.md
@.planning/phases/03-route-creation/03-04-SUMMARY.md
@backend/app/routers/routes.py
@app/create/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API client for route operations</name>
  <files>app/lib/api.ts</files>
  <action>
Create API client module for route operations. Follow existing patterns if any API utilities exist.

```typescript
// app/lib/api.ts

const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

interface ApiError {
  detail: string;
}

async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const token = localStorage.getItem('token'); // JWT from auth

  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...options.headers
    }
  });

  if (!response.ok) {
    const error: ApiError = await response.json().catch(() => ({ detail: 'Request failed' }));
    throw new Error(error.detail || `HTTP ${response.status}`);
  }

  return response.json();
}

// Types matching backend models
export interface RouteResponse {
  id: number;
  name: string;
  status: 'draft' | 'active' | 'archived';
  waypoint_count: number;
  created_at: string;
}

export interface WaypointResponse {
  id: number;
  name: string;
  type: 'camp' | 'peak' | 'poi';
  sms_code: string;
  lat: number;
  lng: number;
  elevation: number;
  order_index: number;
}

export interface RouteDetailResponse extends RouteResponse {
  gpx_data: {
    track_geojson?: GeoJSON.Feature;
    waypoints?: Array<{ name: string; lat: number; lng: number; elevation?: number }>;
    metadata?: { name?: string; description?: string };
  } | null;
  waypoints: WaypointResponse[];
}

export interface GPXUploadResponse {
  track_geojson: GeoJSON.Feature;
  waypoints: Array<{ name: string; lat: number; lng: number; elevation?: number }>;
  metadata: { name?: string; description?: string };
}

// Route operations
export async function uploadGPX(file: File): Promise<GPXUploadResponse> {
  const token = localStorage.getItem('token');
  const formData = new FormData();
  formData.append('file', file);

  const response = await fetch(`${API_BASE}/api/routes/upload-gpx`, {
    method: 'POST',
    headers: token ? { Authorization: `Bearer ${token}` } : {},
    body: formData
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Upload failed' }));
    throw new Error(error.detail || 'Failed to upload GPX');
  }

  return response.json();
}

export async function createRoute(data: {
  name: string;
  gpx_data?: object;
}): Promise<RouteResponse> {
  return apiRequest('/api/routes', {
    method: 'POST',
    body: JSON.stringify(data)
  });
}

export async function getRoutes(): Promise<RouteResponse[]> {
  return apiRequest('/api/routes');
}

export async function getRoute(id: number): Promise<RouteDetailResponse> {
  return apiRequest(`/api/routes/${id}`);
}

export async function updateRoute(
  id: number,
  data: { name?: string; status?: string; gpx_data?: object }
): Promise<RouteResponse> {
  return apiRequest(`/api/routes/${id}`, {
    method: 'PATCH',
    body: JSON.stringify(data)
  });
}

export async function deleteRoute(id: number): Promise<void> {
  await apiRequest(`/api/routes/${id}`, { method: 'DELETE' });
}

// Waypoint operations
export async function addWaypoint(
  routeId: number,
  data: { name: string; type: string; lat: number; lng: number; elevation?: number }
): Promise<WaypointResponse> {
  return apiRequest(`/api/routes/${routeId}/waypoints`, {
    method: 'POST',
    body: JSON.stringify(data)
  });
}

export async function updateWaypoint(
  routeId: number,
  waypointId: number,
  data: { name?: string; type?: string; lat?: number; lng?: number; elevation?: number }
): Promise<WaypointResponse> {
  return apiRequest(`/api/routes/${routeId}/waypoints/${waypointId}`, {
    method: 'PATCH',
    body: JSON.stringify(data)
  });
}

export async function deleteWaypoint(routeId: number, waypointId: number): Promise<void> {
  await apiRequest(`/api/routes/${routeId}/waypoints/${waypointId}`, {
    method: 'DELETE'
  });
}
```

Create the directory:
```bash
mkdir -p app/lib
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>API client with typed methods for all route/waypoint operations</done>
</task>

<task type="auto">
  <name>Task 2: Add save/load functionality to create page</name>
  <files>app/create/page.tsx</files>
  <action>
Update create page with save/load workflow and authentication check.

Add to imports:
```typescript
import { useRouter, useSearchParams } from 'next/navigation';
import {
  createRoute,
  updateRoute,
  getRoute,
  addWaypoint,
  updateWaypoint as apiUpdateWaypoint,
  deleteWaypoint as apiDeleteWaypoint,
  uploadGPX as apiUploadGPX
} from '../lib/api';
```

Add state for route persistence:
```typescript
const router = useRouter();
const searchParams = useSearchParams();
const routeId = searchParams.get('id'); // For editing existing route

const [isSaving, setIsSaving] = useState(false);
const [saveError, setSaveError] = useState<string | null>(null);
const [isDirty, setIsDirty] = useState(false); // Track unsaved changes
const [currentRouteId, setCurrentRouteId] = useState<number | null>(
  routeId ? parseInt(routeId) : null
);

// Check if user is logged in
const token = typeof window !== 'undefined' ? localStorage.getItem('token') : null;
```

Add load existing route effect:
```typescript
useEffect(() => {
  if (currentRouteId) {
    loadExistingRoute(currentRouteId);
  }
}, [currentRouteId]);

async function loadExistingRoute(id: number) {
  try {
    setIsLoading(true);
    const route = await getRoute(id);

    setRouteName(route.name);

    if (route.gpx_data?.track_geojson) {
      setTrackGeojson(route.gpx_data.track_geojson);
    }

    // Convert backend waypoints to frontend format
    setWaypoints(route.waypoints.map(wp => ({
      id: String(wp.id), // Frontend uses string IDs
      backendId: wp.id,  // Keep backend ID for updates
      lat: wp.lat,
      lng: wp.lng,
      name: wp.name,
      type: wp.type as WaypointType,
      smsCode: wp.sms_code,
      elevation: wp.elevation
    })));

    setIsDirty(false);
  } catch (e) {
    setError('Failed to load route');
    console.error(e);
  } finally {
    setIsLoading(false);
  }
}
```

Add save function:
```typescript
async function handleSave() {
  if (!token) {
    // Redirect to login, then back here
    router.push(`/login?redirect=/create${currentRouteId ? `?id=${currentRouteId}` : ''}`);
    return;
  }

  setIsSaving(true);
  setSaveError(null);

  try {
    let routeIdToUse = currentRouteId;

    // Create route if new
    if (!routeIdToUse) {
      const newRoute = await createRoute({
        name: routeName || 'Untitled Route',
        gpx_data: trackGeojson ? {
          track_geojson: trackGeojson,
          metadata: { name: routeName }
        } : undefined
      });
      routeIdToUse = newRoute.id;
      setCurrentRouteId(routeIdToUse);

      // Update URL without full reload
      window.history.replaceState({}, '', `/create?id=${routeIdToUse}`);
    } else {
      // Update existing route
      await updateRoute(routeIdToUse, {
        name: routeName,
        gpx_data: trackGeojson ? {
          track_geojson: trackGeojson,
          metadata: { name: routeName }
        } : undefined
      });
    }

    // Sync waypoints to backend
    for (const wp of waypoints) {
      if (!wp.backendId) {
        // New waypoint - create
        const created = await addWaypoint(routeIdToUse, {
          name: wp.name,
          type: wp.type,
          lat: wp.lat,
          lng: wp.lng,
          elevation: wp.elevation
        });
        wp.backendId = created.id;
        wp.smsCode = created.sms_code; // Use server-generated code
      }
      // Note: Updates and deletes would need more sophisticated dirty tracking
      // For MVP, we do full sync on each save
    }

    setIsDirty(false);
    // Show success toast or message
  } catch (e) {
    setSaveError(e instanceof Error ? e.message : 'Failed to save route');
    console.error(e);
  } finally {
    setIsSaving(false);
  }
}
```

Add save button to UI:
```typescript
{trackGeojson && (
  <div className="flex items-center gap-4 mt-6">
    <button
      onClick={handleSave}
      disabled={isSaving || !isDirty}
      className={`
        px-6 py-2 rounded-lg font-medium transition-colors
        ${isSaving || !isDirty
          ? 'bg-gray-700 text-gray-400 cursor-not-allowed'
          : 'bg-blue-600 text-white hover:bg-blue-500'}
      `}
    >
      {isSaving ? 'Saving...' : isDirty ? 'Save Draft' : 'Saved'}
    </button>

    {!token && (
      <p className="text-sm text-yellow-400">
        Log in to save your route
      </p>
    )}

    {saveError && (
      <p className="text-sm text-red-400">{saveError}</p>
    )}
  </div>
)}
```

Mark dirty when changes occur:
```typescript
// In handleMapClick, handleWaypointUpdate, handleWaypointDrag, handleWaypointDelete:
setIsDirty(true);

// In handleGPXUpload after setting track:
setIsDirty(true);

// In setRouteName handler:
<input
  value={routeName}
  onChange={(e) => {
    setRouteName(e.target.value);
    setIsDirty(true);
  }}
  ...
/>
```

Add unsaved changes warning:
```typescript
useEffect(() => {
  const handleBeforeUnload = (e: BeforeUnloadEvent) => {
    if (isDirty) {
      e.preventDefault();
      e.returnValue = '';
    }
  };

  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [isDirty]);
```

Extend Waypoint type to track backend ID:
```typescript
interface WaypointWithBackend extends Waypoint {
  backendId?: number;
}
```
  </action>
  <verify>npm run dev, create route, add waypoints, save (requires login), reload page with ?id=X and verify data loads</verify>
  <done>Routes save to backend, persist across reloads, load for continued editing</done>
</task>

<task type="auto">
  <name>Task 3: Create My Routes list page</name>
  <files>app/routes/page.tsx</files>
  <action>
Create a page to list user's saved routes.

```typescript
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { getRoutes, deleteRoute, RouteResponse } from '../lib/api';
import { Map, Trash2, Edit, Plus } from 'lucide-react';

export default function MyRoutesPage() {
  const [routes, setRoutes] = useState<RouteResponse[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadRoutes();
  }, []);

  async function loadRoutes() {
    try {
      const data = await getRoutes();
      setRoutes(data);
    } catch (e) {
      setError('Failed to load routes. Please log in.');
    } finally {
      setIsLoading(false);
    }
  }

  async function handleDelete(id: number) {
    if (!confirm('Delete this route? This cannot be undone.')) return;

    try {
      await deleteRoute(id);
      setRoutes(routes.filter(r => r.id !== id));
    } catch (e) {
      alert('Failed to delete route');
    }
  }

  const statusColors = {
    draft: 'bg-yellow-500/20 text-yellow-400',
    active: 'bg-green-500/20 text-green-400',
    archived: 'bg-gray-500/20 text-gray-400'
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-950 text-white p-8">
        <div className="max-w-4xl mx-auto">
          <div className="animate-pulse space-y-4">
            <div className="h-8 bg-gray-800 rounded w-1/4"></div>
            <div className="h-24 bg-gray-800 rounded"></div>
            <div className="h-24 bg-gray-800 rounded"></div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-950 text-white">
      <div className="max-w-4xl mx-auto px-4 py-8">
        <div className="flex items-center justify-between mb-8">
          <h1 className="text-3xl font-bold">My Routes</h1>
          <Link
            href="/create"
            className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-500 transition-colors"
          >
            <Plus className="w-5 h-5" />
            Create New
          </Link>
        </div>

        {error && (
          <div className="mb-6 p-4 bg-red-900/50 border border-red-500 rounded-lg text-red-200">
            {error}
          </div>
        )}

        {routes.length === 0 ? (
          <div className="text-center py-12 bg-gray-900 rounded-lg">
            <Map className="w-16 h-16 mx-auto mb-4 text-gray-600" />
            <h2 className="text-xl font-semibold text-gray-300 mb-2">No routes yet</h2>
            <p className="text-gray-500 mb-6">Create your first route to get started</p>
            <Link
              href="/create"
              className="inline-flex items-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-500 transition-colors"
            >
              <Plus className="w-5 h-5" />
              Create Route
            </Link>
          </div>
        ) : (
          <div className="space-y-4">
            {routes.map((route) => (
              <div
                key={route.id}
                className="flex items-center gap-4 p-4 bg-gray-900 rounded-lg hover:bg-gray-800/50 transition-colors"
              >
                <div className="flex-1">
                  <div className="flex items-center gap-3 mb-1">
                    <h2 className="text-lg font-semibold text-white">{route.name}</h2>
                    <span className={`px-2 py-0.5 rounded text-xs font-medium ${statusColors[route.status]}`}>
                      {route.status}
                    </span>
                  </div>
                  <p className="text-sm text-gray-500">
                    {route.waypoint_count} waypoints &middot; Created {new Date(route.created_at).toLocaleDateString()}
                  </p>
                </div>

                <div className="flex items-center gap-2">
                  <Link
                    href={`/create?id=${route.id}`}
                    className="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded-lg transition-colors"
                    title="Edit route"
                  >
                    <Edit className="w-5 h-5" />
                  </Link>
                  <button
                    onClick={() => handleDelete(route.id)}
                    className="p-2 text-gray-400 hover:text-red-400 hover:bg-red-900/30 rounded-lg transition-colors"
                    title="Delete route"
                  >
                    <Trash2 className="w-5 h-5" />
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

Create directory:
```bash
mkdir -p app/routes
```
  </action>
  <verify>npm run dev, visit /routes, verify list shows saved routes, edit and delete work</verify>
  <done>My Routes page lists all user routes with edit/delete actions</done>
</task>

</tasks>

<verification>
1. New route saves to backend on "Save Draft" click
2. Saved route loads when visiting /create?id=X
3. Waypoints persist with correct SMS codes from server
4. /routes page lists all user's routes
5. Edit button opens route in editor
6. Delete button removes route after confirmation
7. Unsaved changes warning when navigating away
8. Login redirect when trying to save without auth
</verification>

<success_criteria>
- ROUT-09: User can save draft routes to account
- Routes persist across page reloads
- User can continue editing saved routes
- My Routes page provides route management
</success_criteria>

<output>
After completion, create `.planning/phases/03-route-creation/03-05-SUMMARY.md`
</output>
