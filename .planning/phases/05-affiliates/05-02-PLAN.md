---
phase: 05-affiliates
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/app/services/affiliates.py
  - backend/app/routers/webhook.py
  - backend/app/services/payments.py
autonomous: true

must_haves:
  truths:
    - "Commission calculated on actual paid amount (post-discount) in webhook"
    - "Commission created with 30-day pending period before available"
    - "Trailing attribution checked on top-up orders"
    - "Refunds trigger commission clawback"
    - "Affiliate metadata flows through Stripe checkout"
  artifacts:
    - path: "backend/app/services/affiliates.py"
      provides: "AffiliateService with commission calculation logic"
      exports: ["AffiliateService", "get_affiliate_service"]
    - path: "backend/app/routers/webhook.py"
      provides: "Commission creation in checkout.session.completed and charge.refunded handlers"
      contains: "affiliate_id"
  key_links:
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/affiliates.py"
      via: "calculate_commission() call in handle_checkout_completed"
      pattern: "affiliate_service\\.calculate_commission"
    - from: "backend/app/services/payments.py"
      to: "Stripe metadata"
      via: "affiliate_id and sub_id in checkout session metadata"
      pattern: "affiliate_id.*metadata"
---

<objective>
Implement affiliate service and integrate commission calculation into Stripe webhooks.

Purpose: Enable commission tracking on purchases. This is the core business logic - commissions must be calculated atomically with order fulfillment (in webhook, not checkout creation) to ensure accuracy and prevent fraud.

Output: AffiliateService with commission calculation, webhook handlers updated to create commissions on purchase and clawback on refund.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-affiliates/05-CONTEXT.md
@.planning/phases/05-affiliates/05-RESEARCH.md

# Prior plan context
@.planning/phases/05-affiliates/05-01-SUMMARY.md

# Key files to modify
@backend/app/routers/webhook.py
@backend/app/services/payments.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AffiliateService with commission calculation</name>
  <files>backend/app/services/affiliates.py</files>
  <action>
Replace the stub `backend/app/services/affiliates.py` with full implementation:

```python
"""
Affiliate service for commission tracking and management.

Handles AFFL-01 through AFFL-07.
"""
import logging
from datetime import datetime, timedelta
from typing import Optional
from dataclasses import dataclass

from app.models.affiliates import (
    affiliate_store, commission_store, attribution_store, click_store,
    Affiliate, Commission, Attribution
)

logger = logging.getLogger(__name__)


@dataclass
class CommissionResult:
    """Result of commission calculation."""
    success: bool
    commission_id: Optional[int] = None
    amount_cents: int = 0
    error: Optional[str] = None


class AffiliateService:
    """
    Affiliate commission and tracking service.

    Key rules from CONTEXT.md:
    - Commission on actual paid price (post-discount)
    - 30-day hold before available
    - Trailing commission tracked for configured duration
    - Full clawback on refunds
    """

    def record_click(
        self,
        affiliate_code: str,
        session_id: Optional[str] = None,
        sub_id: Optional[str] = None
    ) -> bool:
        """
        Record affiliate click for analytics.

        Deduplicates based on session_id within 24 hours.

        Args:
            affiliate_code: Affiliate code (e.g., "HIKER20")
            session_id: Browser session ID for deduplication
            sub_id: Campaign tracking ID

        Returns:
            True if click recorded, False if deduplicated or invalid affiliate
        """
        affiliate = affiliate_store.get_by_code(affiliate_code)
        if not affiliate or not affiliate.active:
            return False

        # Check for duplicate in last 24h if session_id provided
        if session_id:
            existing = click_store.get_recent_by_session(
                affiliate_id=affiliate.id,
                session_id=session_id,
                hours=24
            )
            if existing:
                logger.debug(f"Deduplicated click for affiliate {affiliate_code}")
                return False

        click_store.create(
            affiliate_id=affiliate.id,
            sub_id=sub_id,
            session_id=session_id
        )
        logger.info(f"Recorded click for affiliate {affiliate_code} (sub_id={sub_id})")
        return True

    def calculate_commission(
        self,
        affiliate_id: int,
        account_id: int,
        order_id: int,
        amount_cents: int,
        sub_id: Optional[str] = None,
        is_initial: bool = True
    ) -> CommissionResult:
        """
        Calculate and record commission for an order.

        AFFL-04: Commission on actual paid price (post-discount).

        Args:
            affiliate_id: Affiliate to credit
            account_id: Customer who purchased
            order_id: Order being commissioned
            amount_cents: Actual amount paid (post-discount)
            sub_id: Campaign tracking ID
            is_initial: True for initial purchase, False for top-up

        Returns:
            CommissionResult with commission details
        """
        affiliate = affiliate_store.get_by_id(affiliate_id)
        if not affiliate:
            return CommissionResult(success=False, error="Affiliate not found")

        if not affiliate.active:
            return CommissionResult(success=False, error="Affiliate inactive")

        # Calculate commission amount
        commission_cents = int(amount_cents * affiliate.commission_percent / 100)

        if commission_cents <= 0:
            return CommissionResult(success=False, error="Commission amount too small")

        # 30-day hold before available (from CONTEXT.md)
        now = datetime.utcnow()
        available_at = now + timedelta(days=30)

        # Create commission record
        commission = commission_store.create(
            affiliate_id=affiliate_id,
            account_id=account_id,
            order_id=order_id,
            amount_cents=commission_cents,
            status="pending",
            sub_id=sub_id,
            available_at=available_at.isoformat()
        )

        logger.info(
            f"Commission created: ${commission_cents/100:.2f} for affiliate {affiliate.code} "
            f"(order={order_id}, is_initial={is_initial})"
        )

        return CommissionResult(
            success=True,
            commission_id=commission.id,
            amount_cents=commission_cents
        )

    def create_attribution(
        self,
        affiliate_id: int,
        account_id: int,
        order_id: int,
        sub_id: Optional[str] = None
    ) -> Optional[Attribution]:
        """
        Create attribution record for trailing commissions.

        AFFL-05: Trailing commission tracked for configured duration.

        Args:
            affiliate_id: Referring affiliate
            account_id: Referred customer
            order_id: Initial purchase order
            sub_id: Campaign tracking ID

        Returns:
            Attribution record or None if account already attributed
        """
        # Check if account already attributed (one affiliate per account)
        existing = attribution_store.get_by_account_id(account_id)
        if existing:
            logger.debug(f"Account {account_id} already attributed to affiliate {existing.affiliate_id}")
            return None

        affiliate = affiliate_store.get_by_id(affiliate_id)
        if not affiliate:
            return None

        # Calculate trailing expiry
        trailing_expires_at = None
        if affiliate.trailing_months is not None:
            expires = datetime.utcnow() + timedelta(days=affiliate.trailing_months * 30)
            trailing_expires_at = expires.isoformat()

        attribution = attribution_store.create(
            affiliate_id=affiliate_id,
            account_id=account_id,
            order_id=order_id,
            sub_id=sub_id,
            trailing_expires_at=trailing_expires_at
        )

        logger.info(
            f"Attribution created: account {account_id} -> affiliate {affiliate.code} "
            f"(trailing_months={affiliate.trailing_months})"
        )

        return attribution

    def get_active_attribution(self, account_id: int) -> Optional[Attribution]:
        """
        Get active attribution for account (for trailing commissions on top-ups).

        Returns None if:
        - No attribution exists
        - Trailing period has expired

        Args:
            account_id: Customer account ID

        Returns:
            Active Attribution or None
        """
        return attribution_store.get_active_attribution(account_id)

    def clawback_commission(self, order_id: int) -> bool:
        """
        Clawback commission on refund.

        From CONTEXT.md: Full claw back on refunds - deduct from affiliate's available balance.

        Args:
            order_id: Refunded order ID

        Returns:
            True if commission clawed back, False if no commission found
        """
        commissions = commission_store.get_by_order_id(order_id)
        if not commissions:
            return False

        for commission in commissions:
            if commission.status in ("pending", "available"):
                commission_store.update_status(commission.id, "clawed_back")
                logger.info(f"Commission {commission.id} clawed back (order={order_id})")

        return True


# Singleton instance
_affiliate_service: Optional[AffiliateService] = None


def get_affiliate_service() -> AffiliateService:
    """Get singleton affiliate service instance."""
    global _affiliate_service
    if _affiliate_service is None:
        _affiliate_service = AffiliateService()
    return _affiliate_service
```

Also add `get_recent_by_session()` method to ClickStore in models/affiliates.py and `get_by_order_id()` and `update_status()` methods to CommissionStore.
  </action>
  <verify>
    python -c "from backend.app.services.affiliates import get_affiliate_service; svc = get_affiliate_service(); print('AffiliateService loaded OK')"
  </verify>
  <done>AffiliateService implements calculate_commission, create_attribution, get_active_attribution, clawback_commission, and record_click</done>
</task>

<task type="auto">
  <name>Task 2: Add affiliate metadata to Stripe checkout</name>
  <files>backend/app/services/payments.py</files>
  <action>
Update `backend/app/services/payments.py` to include affiliate tracking in Stripe metadata.

1. **Update create_checkout_session() method signature** to accept affiliate_id and sub_id:
   ```python
   async def create_checkout_session(
       self,
       account_id: int,
       discount_code: Optional[str] = None,
       success_url: Optional[str] = None,
       cancel_url: Optional[str] = None,
       entry_path: Optional[str] = None,
       route_id: Optional[int] = None,
       affiliate_id: Optional[int] = None,  # ADD
       sub_id: Optional[str] = None  # ADD
   ) -> PaymentResult:
   ```

2. **Add affiliate metadata** to the metadata dict:
   ```python
   metadata = {
       "account_id": str(account_id),
       "order_id": str(order.id),
       "purchase_type": "initial_access",
       "entry_path": entry_path or "unknown",
   }
   if route_id is not None:
       metadata["route_id"] = str(route_id)
   # ADD: Affiliate tracking
   if affiliate_id is not None:
       metadata["affiliate_id"] = str(affiliate_id)
   if sub_id:
       metadata["sub_id"] = sub_id
   ```

3. **Update create_checkout_session_with_metadata()** similarly (used by Buy Now flow)

4. **Update create_topup_checkout()** to accept and pass affiliate_id/sub_id (for trailing commissions)

The affiliate_id will be looked up from the discount code at checkout time in the router (next plan), but we need the service layer to accept it.
  </action>
  <verify>
    python -c "import inspect; from backend.app.services.payments import PaymentService; sig = inspect.signature(PaymentService.create_checkout_session); print('affiliate_id' in str(sig))"
  </verify>
  <done>PaymentService.create_checkout_session() and related methods accept affiliate_id and sub_id parameters and include them in Stripe metadata</done>
</task>

<task type="auto">
  <name>Task 3: Integrate commission calculation into Stripe webhooks</name>
  <files>backend/app/routers/webhook.py</files>
  <action>
Update `backend/app/routers/webhook.py` to create commissions on successful payments and clawback on refunds.

1. **Import affiliate service at top:**
   ```python
   from app.services.affiliates import get_affiliate_service
   ```

2. **Update handle_checkout_completed()** - after credits are added:
   ```python
   async def handle_checkout_completed(session):
       # ... existing order fulfillment code ...

       # After credits added, handle affiliate commission (AFFL-04)
       affiliate_id_str = metadata.get("affiliate_id")
       sub_id = metadata.get("sub_id")

       if affiliate_id_str:
           affiliate_service = get_affiliate_service()
           affiliate_id = int(affiliate_id_str)

           # Create commission on actual paid amount
           commission_result = affiliate_service.calculate_commission(
               affiliate_id=affiliate_id,
               account_id=account_id,
               order_id=order_id,
               amount_cents=order.amount_cents,  # Post-discount amount
               sub_id=sub_id,
               is_initial=(purchase_type == "initial_access")
           )

           if commission_result.success:
               logger.info(f"Commission created: ${commission_result.amount_cents/100:.2f}")

           # Create attribution for trailing commissions (initial purchase only)
           if purchase_type == "initial_access":
               affiliate_service.create_attribution(
                   affiliate_id=affiliate_id,
                   account_id=account_id,
                   order_id=order_id,
                   sub_id=sub_id
               )
   ```

3. **Update handle_payment_succeeded()** (for top-ups) - check for trailing attribution:
   ```python
   async def handle_payment_succeeded(payment_intent):
       # ... existing code ...

       # Check for trailing commission (AFFL-05)
       affiliate_service = get_affiliate_service()
       attribution = affiliate_service.get_active_attribution(account_id)

       if attribution:
           # Look up affiliate commission rate
           from app.models.affiliates import affiliate_store
           affiliate = affiliate_store.get_by_id(attribution.affiliate_id)

           if affiliate and affiliate.active:
               commission_result = affiliate_service.calculate_commission(
                   affiliate_id=attribution.affiliate_id,
                   account_id=account_id,
                   order_id=order_id,
                   amount_cents=amount_cents,
                   sub_id=attribution.sub_id,
                   is_initial=False
               )
               if commission_result.success:
                   logger.info(f"Trailing commission created: ${commission_result.amount_cents/100:.2f}")
   ```

4. **Add charge.refunded webhook handler** for commission clawback:
   ```python
   # In stripe_webhook() function, add to event type handling:
   elif event.type == "charge.refunded":
       charge = event.data.object
       await handle_charge_refunded(charge)

   # New function:
   async def handle_charge_refunded(charge):
       """
       Handle refund - clawback affiliate commission.
       From CONTEXT.md: Full claw back on refunds.
       """
       # Get payment intent to find order
       payment_intent_id = charge.get("payment_intent")
       if not payment_intent_id:
           return

       # Look up order by payment intent
       from app.models.payments import order_store
       orders = order_store.get_by_payment_intent(payment_intent_id)

       for order in orders:
           affiliate_service = get_affiliate_service()
           if affiliate_service.clawback_commission(order.id):
               logger.info(f"Clawed back commission for refunded order {order.id}")
   ```

5. **Add get_by_payment_intent() method to OrderStore** in models/payments.py if not exists.
  </action>
  <verify>
    grep -n "affiliate_service" backend/app/routers/webhook.py && grep -n "charge.refunded" backend/app/routers/webhook.py
  </verify>
  <done>Webhook handlers create commissions on checkout.session.completed and payment_intent.succeeded, and clawback commissions on charge.refunded</done>
</task>

</tasks>

<verification>
1. Service imports: `python -c "from backend.app.services.affiliates import get_affiliate_service"`
2. Payments accepts affiliate_id: Check method signatures
3. Webhook handles affiliates: `grep "affiliate" backend/app/routers/webhook.py`
4. Refund clawback: `grep "charge.refunded" backend/app/routers/webhook.py`
</verification>

<success_criteria>
- AffiliateService exists with calculate_commission(), create_attribution(), clawback_commission()
- PaymentService.create_checkout_session() accepts and includes affiliate_id in Stripe metadata
- handle_checkout_completed() creates commission for affiliate purchases
- handle_payment_succeeded() creates trailing commissions for attributed accounts
- handle_charge_refunded() claws back commissions on refunds
- Commission amount is calculated on post-discount amount (AFFL-04)
</success_criteria>

<output>
After completion, create `.planning/phases/05-affiliates/05-02-SUMMARY.md`
</output>
