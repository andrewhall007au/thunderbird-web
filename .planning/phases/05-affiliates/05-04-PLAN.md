---
phase: 05-affiliates
plan: 04
type: execute
wave: 4
depends_on: ["05-02", "05-03"]
files_modified:
  - backend/app/routers/affiliates.py
  - backend/app/services/affiliates.py
  - backend/app/routers/affiliate_landing.py
autonomous: true

must_haves:
  truths:
    - "Affiliates can view their earnings dashboard"
    - "Dashboard shows pending, available, and paid commission totals"
    - "Dashboard shows clicks, conversions, and conversion rate"
    - "Affiliate landing page records click and stores code in session"
    - "Time period filtering works (today, 7d, 30d, all-time)"
  artifacts:
    - path: "backend/app/routers/affiliates.py"
      provides: "Affiliate dashboard API endpoints"
      exports: ["router"]
    - path: "backend/app/routers/affiliate_landing.py"
      provides: "Public affiliate landing page with click tracking"
      contains: "ref="
  key_links:
    - from: "backend/app/routers/affiliates.py"
      to: "backend/app/services/affiliates.py"
      via: "get_affiliate_stats() for dashboard data"
      pattern: "affiliate_service\\.get_affiliate_stats"
    - from: "backend/app/routers/affiliate_landing.py"
      to: "backend/app/services/affiliates.py"
      via: "record_click() on page load"
      pattern: "affiliate_service\\.record_click"
---

<objective>
Build affiliate dashboard API and public landing page with click tracking.

Purpose: Enable AFFL-06 (affiliate analytics). Affiliates need visibility into their performance - clicks, conversions, earnings by period. Landing page records clicks for attribution.

Output: API endpoints for affiliate dashboard data, public landing route that records clicks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-affiliates/05-CONTEXT.md
@.planning/phases/05-affiliates/05-RESEARCH.md

# Prior plan context
@.planning/phases/05-affiliates/05-01-SUMMARY.md
@.planning/phases/05-affiliates/05-02-SUMMARY.md
@.planning/phases/05-affiliates/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add affiliate stats methods to AffiliateService</name>
  <files>backend/app/services/affiliates.py</files>
  <action>
Add analytics query methods to `backend/app/services/affiliates.py`:

```python
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from dataclasses import dataclass


@dataclass
class AffiliateStats:
    """Affiliate performance statistics."""
    affiliate_id: int
    period_start: Optional[datetime]
    period_end: Optional[datetime]

    # Clicks
    total_clicks: int
    unique_clicks: int  # By session_id dedup

    # Conversions
    total_conversions: int  # Unique accounts
    conversion_rate: float  # conversions / clicks * 100

    # Revenue (aggregate only - no per-user breakdown)
    total_revenue_cents: int  # Total revenue from referred users
    total_commission_cents: int  # Total commission earned

    # Commission breakdown
    pending_cents: int
    available_cents: int
    requested_cents: int
    paid_cents: int

    # Top-ups (trailing)
    topup_count: int
    topup_commission_cents: int


class AffiliateService:
    # ... existing methods ...

    def get_affiliate_stats(
        self,
        affiliate_id: int,
        period: str = "all"  # "today", "7d", "30d", "all"
    ) -> Optional[AffiliateStats]:
        """
        Get affiliate performance statistics.

        AFFL-06: Aggregate data only - no per-user breakdown (privacy).
        From CONTEXT.md: Numbers only, no charts or graphs.

        Args:
            affiliate_id: Affiliate to query
            period: Time period filter

        Returns:
            AffiliateStats or None if affiliate not found
        """
        affiliate = affiliate_store.get_by_id(affiliate_id)
        if not affiliate:
            return None

        # Calculate date range
        now = datetime.utcnow()
        if period == "today":
            period_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif period == "7d":
            period_start = now - timedelta(days=7)
        elif period == "30d":
            period_start = now - timedelta(days=30)
        else:  # "all"
            period_start = None

        # Query clicks
        clicks = click_store.count_by_affiliate(
            affiliate_id,
            start_date=period_start.isoformat() if period_start else None
        )
        unique_clicks = click_store.count_unique_by_affiliate(
            affiliate_id,
            start_date=period_start.isoformat() if period_start else None
        )

        # Query commissions
        commissions = commission_store.get_by_affiliate_id(
            affiliate_id,
            start_date=period_start.isoformat() if period_start else None
        )

        # Calculate metrics
        unique_accounts = set(c.account_id for c in commissions)
        initial_commissions = [c for c in commissions if c.order_id]  # Has order_id
        topup_commissions = [c for c in commissions if not c.is_initial]  # Trailing

        conversion_rate = (len(unique_accounts) / clicks * 100) if clicks > 0 else 0

        return AffiliateStats(
            affiliate_id=affiliate_id,
            period_start=period_start,
            period_end=now,
            total_clicks=clicks,
            unique_clicks=unique_clicks,
            total_conversions=len(unique_accounts),
            conversion_rate=round(conversion_rate, 1),
            total_revenue_cents=sum(self._get_order_amount(c.order_id) for c in commissions),
            total_commission_cents=sum(c.amount_cents for c in commissions),
            pending_cents=sum(c.amount_cents for c in commissions if c.status == "pending"),
            available_cents=sum(c.amount_cents for c in commissions if c.status == "available"),
            requested_cents=sum(c.amount_cents for c in commissions if c.status == "requested"),
            paid_cents=sum(c.amount_cents for c in commissions if c.status == "paid"),
            topup_count=len(topup_commissions),
            topup_commission_cents=sum(c.amount_cents for c in topup_commissions)
        )

    def _get_order_amount(self, order_id: int) -> int:
        """Get order amount for revenue calculation."""
        from app.models.payments import order_store
        order = order_store.get_by_id(order_id)
        return order.amount_cents if order else 0

    def get_recent_conversions(
        self,
        affiliate_id: int,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get recent conversions for affiliate.

        Returns aggregate info only - no personal data.

        Returns:
            List of {date, amount_cents, commission_cents, type}
        """
        commissions = commission_store.get_by_affiliate_id(affiliate_id)
        commissions = sorted(commissions, key=lambda c: c.created_at, reverse=True)[:limit]

        return [
            {
                "date": c.created_at.isoformat() if c.created_at else None,
                "amount_cents": self._get_order_amount(c.order_id),
                "commission_cents": c.amount_cents,
                "type": "initial" if c.is_initial else "top-up",
                "status": c.status,
            }
            for c in commissions
        ]
```

Also add `count_unique_by_affiliate()` and `is_initial` property/field tracking to ClickStore and Commission.
  </action>
  <verify>
    python -c "from backend.app.services.affiliates import get_affiliate_service, AffiliateStats; print('Stats methods loaded')"
  </verify>
  <done>AffiliateService has get_affiliate_stats() and get_recent_conversions() methods returning AffiliateStats dataclass</done>
</task>

<task type="auto">
  <name>Task 2: Create affiliate dashboard API router</name>
  <files>backend/app/routers/affiliates.py</files>
  <action>
Create `backend/app/routers/affiliates.py` with dashboard API endpoints:

```python
"""
Affiliate dashboard API endpoints.

Provides analytics data for affiliates to view their performance.
AFFL-06: Detailed metrics for affiliates.
"""
import logging
from typing import Optional, List
from datetime import datetime

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel

from app.services.affiliates import get_affiliate_service, AffiliateStats
from app.models.affiliates import affiliate_store

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/affiliates", tags=["affiliates"])


# Response models

class AffiliateStatsResponse(BaseModel):
    """Affiliate dashboard stats response."""
    affiliate_code: str
    affiliate_name: str
    period: str

    # Clicks
    total_clicks: int
    unique_clicks: int

    # Conversions
    total_conversions: int
    conversion_rate: float

    # Earnings (formatted)
    total_commission: str  # "$123.45"
    pending: str
    available: str
    requested: str
    paid: str

    # Trailing
    topup_count: int
    topup_commission: str


class ConversionItem(BaseModel):
    """Single conversion record (aggregate, no personal data)."""
    date: str
    amount: str  # "$29.99"
    commission: str  # "$5.99"
    type: str  # "initial" or "top-up"
    status: str


class RecentConversionsResponse(BaseModel):
    """Recent conversions response."""
    conversions: List[ConversionItem]


# Endpoints

@router.get("/stats/{affiliate_code}", response_model=AffiliateStatsResponse)
async def get_affiliate_stats(
    affiliate_code: str,
    period: str = Query("30d", regex="^(today|7d|30d|all)$")
):
    """
    Get affiliate performance stats.

    AFFL-06: Detailed metrics - clicks, signups, conversion rate, earnings by period.
    From CONTEXT.md: Preset time periods (today, 7d, 30d, all-time).

    Note: This endpoint requires affiliate authentication (code as secret).
    In production, add proper auth (email link, password, etc).
    """
    affiliate = affiliate_store.get_by_code(affiliate_code.upper())
    if not affiliate:
        raise HTTPException(status_code=404, detail="Affiliate not found")

    if not affiliate.active:
        raise HTTPException(status_code=403, detail="Affiliate account inactive")

    affiliate_service = get_affiliate_service()
    stats = affiliate_service.get_affiliate_stats(affiliate.id, period)

    if not stats:
        raise HTTPException(status_code=500, detail="Failed to load stats")

    def format_cents(cents: int) -> str:
        return f"${cents / 100:.2f}"

    return AffiliateStatsResponse(
        affiliate_code=affiliate.code,
        affiliate_name=affiliate.name,
        period=period,
        total_clicks=stats.total_clicks,
        unique_clicks=stats.unique_clicks,
        total_conversions=stats.total_conversions,
        conversion_rate=stats.conversion_rate,
        total_commission=format_cents(stats.total_commission_cents),
        pending=format_cents(stats.pending_cents),
        available=format_cents(stats.available_cents),
        requested=format_cents(stats.requested_cents),
        paid=format_cents(stats.paid_cents),
        topup_count=stats.topup_count,
        topup_commission=format_cents(stats.topup_commission_cents)
    )


@router.get("/conversions/{affiliate_code}", response_model=RecentConversionsResponse)
async def get_recent_conversions(
    affiliate_code: str,
    limit: int = Query(10, ge=1, le=50)
):
    """
    Get recent conversions for affiliate.

    Returns aggregate data only - no per-user breakdown (privacy).
    """
    affiliate = affiliate_store.get_by_code(affiliate_code.upper())
    if not affiliate:
        raise HTTPException(status_code=404, detail="Affiliate not found")

    affiliate_service = get_affiliate_service()
    conversions = affiliate_service.get_recent_conversions(affiliate.id, limit)

    def format_cents(cents: int) -> str:
        return f"${cents / 100:.2f}"

    return RecentConversionsResponse(
        conversions=[
            ConversionItem(
                date=c["date"] or "Unknown",
                amount=format_cents(c["amount_cents"]),
                commission=format_cents(c["commission_cents"]),
                type=c["type"],
                status=c["status"]
            )
            for c in conversions
        ]
    )


@router.get("/summary/{affiliate_code}")
async def get_affiliate_summary(affiliate_code: str):
    """
    Get quick summary for affiliate (for dashboard header).

    Returns available balance and lifetime earnings.
    """
    affiliate = affiliate_store.get_by_code(affiliate_code.upper())
    if not affiliate:
        raise HTTPException(status_code=404, detail="Affiliate not found")

    affiliate_service = get_affiliate_service()
    stats = affiliate_service.get_affiliate_stats(affiliate.id, "all")

    return {
        "affiliate_code": affiliate.code,
        "affiliate_name": affiliate.name,
        "available_balance_cents": stats.available_cents if stats else 0,
        "available_balance": f"${(stats.available_cents if stats else 0) / 100:.2f}",
        "lifetime_earnings_cents": stats.total_commission_cents if stats else 0,
        "lifetime_earnings": f"${(stats.total_commission_cents if stats else 0) / 100:.2f}",
        "payout_method": affiliate.payout_method,
        "can_request_payout": (stats.available_cents if stats else 0) >= 5000  # $50 minimum
    }
```

Register router in main.py:
```python
from app.routers import affiliates
app.include_router(affiliates.router)
```
  </action>
  <verify>
    grep -n "router = APIRouter" backend/app/routers/affiliates.py && python -c "from backend.app.routers.affiliates import router; print('Router loaded')"
  </verify>
  <done>Affiliate dashboard API exists at /api/affiliates/stats/{code}, /api/affiliates/conversions/{code}, /api/affiliates/summary/{code}</done>
</task>

<task type="auto">
  <name>Task 3: Create affiliate landing page with click tracking</name>
  <files>backend/app/routers/affiliate_landing.py</files>
  <action>
Create `backend/app/routers/affiliate_landing.py` for public affiliate links:

```python
"""
Affiliate landing page - records clicks and redirects.

URL format: /ref/{code} or /ref/{code}/{sub_id}
Alternative: /?ref=CODE&sub=SUBID (handled by frontend)
"""
import logging
import uuid
from typing import Optional

from fastapi import APIRouter, Request, Query
from fastapi.responses import RedirectResponse, HTMLResponse

from app.services.affiliates import get_affiliate_service
from app.models.affiliates import affiliate_store

logger = logging.getLogger(__name__)

router = APIRouter(tags=["affiliate_landing"])


@router.get("/ref/{affiliate_code}")
@router.get("/ref/{affiliate_code}/{sub_id}")
async def affiliate_landing(
    request: Request,
    affiliate_code: str,
    sub_id: Optional[str] = None
):
    """
    Affiliate landing page - records click and redirects to home.

    From RESEARCH.md: Server-side tracking, not cookie-based.
    Deduplication via session_id (from cookie or generated).

    Args:
        affiliate_code: Affiliate's unique code (e.g., "HIKER20")
        sub_id: Optional campaign tracking ID

    Returns:
        Redirect to home page with code stored in cookie
    """
    code = affiliate_code.upper()
    affiliate = affiliate_store.get_by_code(code)

    if not affiliate or not affiliate.active:
        # Invalid code - redirect to home without tracking
        logger.warning(f"Invalid affiliate code: {code}")
        return RedirectResponse("/", status_code=302)

    # Get or create session ID for click deduplication
    session_id = request.cookies.get("tb_session")
    if not session_id:
        session_id = str(uuid.uuid4())

    # Record click (handles deduplication internally)
    affiliate_service = get_affiliate_service()
    click_recorded = affiliate_service.record_click(
        affiliate_code=code,
        session_id=session_id,
        sub_id=sub_id
    )

    if click_recorded:
        logger.info(f"Click recorded for affiliate {code} (sub_id={sub_id})")

    # Redirect to home with affiliate code in cookie
    response = RedirectResponse("/", status_code=302)

    # Store affiliate code in cookie (30 days)
    # Frontend will read this and include in checkout
    response.set_cookie(
        "tb_affiliate",
        code,
        max_age=30 * 24 * 60 * 60,  # 30 days
        httponly=False,  # JS needs to read this
        samesite="lax"
    )

    if sub_id:
        response.set_cookie(
            "tb_sub_id",
            sub_id,
            max_age=30 * 24 * 60 * 60,
            httponly=False,
            samesite="lax"
        )

    # Set session cookie if new
    if not request.cookies.get("tb_session"):
        response.set_cookie(
            "tb_session",
            session_id,
            max_age=24 * 60 * 60,  # 24 hours (for click dedup)
            httponly=True,
            samesite="lax"
        )

    return response


@router.get("/api/affiliate/validate")
async def validate_affiliate_code(
    code: str = Query(..., description="Affiliate code to validate")
):
    """
    Validate affiliate code and return discount info.

    Used by frontend to show discount badge.
    """
    affiliate = affiliate_store.get_by_code(code.upper())

    if not affiliate or not affiliate.active:
        return {"valid": False}

    return {
        "valid": True,
        "code": affiliate.code,
        "discount_percent": affiliate.discount_percent,
        "discount_message": f"{affiliate.discount_percent}% off with code {affiliate.code}" if affiliate.discount_percent > 0 else None
    }
```

Register router in main.py:
```python
from app.routers import affiliate_landing
app.include_router(affiliate_landing.router)
```
  </action>
  <verify>
    grep -n "/ref/" backend/app/routers/affiliate_landing.py && python -c "from backend.app.routers.affiliate_landing import router; print('Landing router loaded')"
  </verify>
  <done>Affiliate landing page at /ref/{code} records click, sets cookie, and redirects; /api/affiliate/validate validates codes</done>
</task>

</tasks>

<verification>
1. Stats API works: `curl http://localhost:8000/api/affiliates/stats/TESTCODE?period=30d`
2. Click tracking works: Visit /ref/TESTCODE, check click recorded in database
3. Cookie set: Inspect browser cookies after visiting /ref/TESTCODE
4. Code validation: `curl http://localhost:8000/api/affiliate/validate?code=TESTCODE`
</verification>

<success_criteria>
- /api/affiliates/stats/{code} returns clicks, conversions, earnings by period
- /api/affiliates/conversions/{code} returns recent conversions (aggregate only)
- /api/affiliates/summary/{code} returns quick balance summary
- /ref/{code} records click and sets tb_affiliate cookie
- /ref/{code}/{sub_id} supports sub-ID tracking
- /api/affiliate/validate returns discount info for valid codes
- Click deduplication works (same session_id within 24h not counted twice)
</success_criteria>

<output>
After completion, create `.planning/phases/05-affiliates/05-04-SUMMARY.md`
</output>
