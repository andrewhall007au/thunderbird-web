---
phase: 05-affiliates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/affiliates.py
  - backend/alembic/versions/xxx_add_affiliate_tables.py
autonomous: true

must_haves:
  truths:
    - "Affiliate table stores name, email, code, discount_percent, commission_percent, trailing_months"
    - "Commission table tracks affiliate_id, account_id, order_id, amount_cents, status with 30-day holds"
    - "Attribution table links accounts to affiliates with trailing expiry"
    - "Click table enables deduplication via session_id"
    - "discount_codes table has affiliate_id column for linking"
  artifacts:
    - path: "backend/app/models/affiliates.py"
      provides: "Affiliate, Commission, Attribution, Click dataclasses and Store classes"
      exports: ["Affiliate", "AffiliateStore", "Commission", "CommissionStore", "Attribution", "AttributionStore", "AffiliateClick", "ClickStore"]
    - path: "backend/alembic/versions/xxx_add_affiliate_tables.py"
      provides: "Database migration for affiliate tables"
      contains: "op.create_table('affiliates'"
  key_links:
    - from: "backend/app/models/affiliates.py"
      to: "backend/app/models/payments.py"
      via: "discount_codes.affiliate_id foreign key concept"
      pattern: "affiliate_id.*Optional\\[int\\]"
---

<objective>
Create database models and migration for affiliate program foundation.

Purpose: Establish the data layer for affiliate tracking, commission management, and attribution. This is the foundation all other affiliate features build upon.

Output: Affiliate models following the established dataclass + Store pattern, plus Alembic migration to create tables.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-affiliates/05-CONTEXT.md
@.planning/phases/05-affiliates/05-RESEARCH.md

# Key patterns to follow
@backend/app/models/payments.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create affiliate models with dataclass + Store pattern</name>
  <files>backend/app/models/affiliates.py</files>
  <action>
Create `backend/app/models/affiliates.py` following the exact pattern from `payments.py`:

1. **Affiliate dataclass:**
   - id, code (unique, uppercase), name, email
   - discount_percent (int, default 0), commission_percent (int, default 20)
   - trailing_months (Optional[int], NULL = forever)
   - payout_method (Optional[str]: "paypal" | "bank")
   - payout_details (Optional[str]: JSON blob with PayPal email or bank details)
   - active (bool, default True)
   - created_at (datetime)

2. **Commission dataclass:**
   - id, affiliate_id, account_id, order_id
   - amount_cents (int)
   - status (str): "pending" | "available" | "requested" | "paid" | "clawed_back"
   - sub_id (Optional[str]): Campaign tracking
   - created_at, available_at (created_at + 30 days), paid_at (Optional)

3. **Attribution dataclass (tracks which accounts were referred by which affiliates):**
   - id, affiliate_id, account_id (unique - one affiliate per account)
   - order_id (initial referral order)
   - sub_id (Optional[str])
   - trailing_expires_at (Optional[datetime], NULL = forever)
   - created_at

4. **AffiliateClick dataclass (for analytics):**
   - id, affiliate_id, sub_id (Optional)
   - session_id (Optional, for 24h deduplication)
   - created_at

5. **Store classes for each (AffiliateStore, CommissionStore, AttributionStore, ClickStore):**
   - Follow BalanceStore/OrderStore pattern: `_get_connection()`, `_row_to_X()` methods
   - AffiliateStore: create(), get_by_id(), get_by_code(), list_all(), update(), deactivate()
   - CommissionStore: create(), get_by_affiliate_id(), get_pending(), mark_available(), mark_requested(), mark_paid(), clawback()
   - AttributionStore: create(), get_by_account_id(), get_active_attribution() (checks trailing_expires_at)
   - ClickStore: create(), count_by_affiliate(), count_by_date_range()

6. **Singleton instances:**
   - affiliate_store, commission_store, attribution_store, click_store

Use same DB_PATH pattern as payments.py. Store datetimes as ISO strings (SQLite compatibility).
  </action>
  <verify>
    python -c "from backend.app.models.affiliates import affiliate_store, commission_store, attribution_store, click_store; print('Models loaded OK')"
  </verify>
  <done>All four model classes with complete Store implementations exist and import without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for affiliate tables</name>
  <files>backend/alembic/versions/xxx_add_affiliate_tables.py</files>
  <action>
Create Alembic migration. First check existing migration naming pattern:
```bash
ls backend/alembic/versions/
```

Then create migration with proper revision ID (use `alembic revision --autogenerate -m "add affiliate tables"` or create manually).

Migration should create these tables:

1. **affiliates table:**
   ```sql
   CREATE TABLE affiliates (
     id INTEGER PRIMARY KEY,
     code VARCHAR(50) NOT NULL UNIQUE,
     name VARCHAR(255) NOT NULL,
     email VARCHAR(255) NOT NULL,
     discount_percent INTEGER NOT NULL DEFAULT 0,
     commission_percent INTEGER NOT NULL DEFAULT 20,
     trailing_months INTEGER,  -- NULL = forever
     payout_method VARCHAR(20),  -- "paypal", "bank"
     payout_details VARCHAR(500),  -- JSON blob
     active BOOLEAN NOT NULL DEFAULT 1,
     created_at VARCHAR(50) NOT NULL
   );
   CREATE INDEX ix_affiliates_code ON affiliates(code);
   ```

2. **commissions table:**
   ```sql
   CREATE TABLE commissions (
     id INTEGER PRIMARY KEY,
     affiliate_id INTEGER NOT NULL,
     account_id INTEGER NOT NULL,
     order_id INTEGER NOT NULL,
     amount_cents INTEGER NOT NULL,
     status VARCHAR(20) NOT NULL DEFAULT 'pending',
     sub_id VARCHAR(100),
     created_at VARCHAR(50) NOT NULL,
     available_at VARCHAR(50),  -- created_at + 30 days
     paid_at VARCHAR(50)
   );
   CREATE INDEX ix_commissions_affiliate_id ON commissions(affiliate_id);
   CREATE INDEX ix_commissions_status ON commissions(status);
   CREATE INDEX ix_commissions_account_id ON commissions(account_id);
   ```

3. **affiliate_attributions table:**
   ```sql
   CREATE TABLE affiliate_attributions (
     id INTEGER PRIMARY KEY,
     affiliate_id INTEGER NOT NULL,
     account_id INTEGER NOT NULL UNIQUE,  -- One affiliate per account
     order_id INTEGER NOT NULL,
     sub_id VARCHAR(100),
     trailing_expires_at VARCHAR(50),  -- NULL = forever
     created_at VARCHAR(50) NOT NULL
   );
   CREATE INDEX ix_affiliate_attributions_account_id ON affiliate_attributions(account_id);
   CREATE INDEX ix_affiliate_attributions_affiliate_id ON affiliate_attributions(affiliate_id);
   ```

4. **affiliate_clicks table:**
   ```sql
   CREATE TABLE affiliate_clicks (
     id INTEGER PRIMARY KEY,
     affiliate_id INTEGER NOT NULL,
     sub_id VARCHAR(100),
     session_id VARCHAR(255),  -- For deduplication
     created_at VARCHAR(50) NOT NULL
   );
   CREATE INDEX ix_affiliate_clicks_affiliate_id ON affiliate_clicks(affiliate_id);
   CREATE INDEX ix_affiliate_clicks_created_at ON affiliate_clicks(created_at);
   ```

5. **Alter discount_codes table** (add affiliate_id column):
   ```sql
   -- Use batch_alter_table for SQLite compatibility
   ALTER TABLE discount_codes ADD COLUMN affiliate_id INTEGER;
   ```

Include proper downgrade() to drop tables in reverse order.
  </action>
  <verify>
    cd backend && alembic upgrade head && alembic downgrade -1 && alembic upgrade head
  </verify>
  <done>Migration creates all affiliate tables and adds affiliate_id to discount_codes; upgrade and downgrade both work</done>
</task>

<task type="auto">
  <name>Task 3: Update DiscountCode model with affiliate_id field</name>
  <files>backend/app/models/payments.py</files>
  <action>
Update the existing DiscountCode dataclass and DiscountCodeStore in `backend/app/models/payments.py`:

1. **Add affiliate_id field to DiscountCode dataclass:**
   ```python
   @dataclass
   class DiscountCode:
       # ... existing fields ...
       affiliate_id: Optional[int] = None  # Links to affiliates table
   ```

2. **Update DiscountCodeStore._row_to_discount_code()** to handle affiliate_id field (may be NULL in existing rows)

3. **Update DiscountCodeStore.create()** to accept optional affiliate_id parameter

4. **Add method DiscountCodeStore.get_by_affiliate_id(affiliate_id: int)** to find discount code linked to affiliate

This allows affiliate codes to function as discount codes (AFFL-03).
  </action>
  <verify>
    python -c "from backend.app.models.payments import DiscountCode, discount_code_store; dc = DiscountCode(id=1, code='TEST', discount_type='percent', discount_value=10, affiliate_id=5); print(f'affiliate_id={dc.affiliate_id}')"
  </verify>
  <done>DiscountCode has affiliate_id field, DiscountCodeStore can create codes with affiliate_id and query by affiliate_id</done>
</task>

</tasks>

<verification>
1. All models import without errors: `python -c "from backend.app.models.affiliates import *; from backend.app.models.payments import DiscountCode"`
2. Migration runs cleanly: `cd backend && alembic upgrade head`
3. Tables exist: `sqlite3 thunderbird.db ".tables" | grep -E "(affiliates|commissions|affiliate_)"
</verification>

<success_criteria>
- Affiliate, Commission, Attribution, Click models exist with complete Store classes
- Alembic migration creates all required tables with proper indexes
- discount_codes table has affiliate_id column
- All migrations run forward and backward cleanly
- Models follow established dataclass + Store pattern from payments.py
</success_criteria>

<output>
After completion, create `.planning/phases/05-affiliates/05-01-SUMMARY.md`
</output>
